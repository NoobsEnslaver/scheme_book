# -*- fill-column: 120; -*-

* Начало

  Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
  параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

  После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
  Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
  данных и управляющие конструкции.

** Взаимодействие с интерактивной оболочкой Scheme

   Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
   разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
   "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
   или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
   выполнения на экран.

   Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
   выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
   работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
   и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
   в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
   реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
   качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
   программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
   для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
   образом, как если бы они были набраны на клавиатуре интерактивно.

   Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
   значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
   позволяет сконцентрироваться на написании программы.

   Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
   можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После ⇒ следует значение
   выражения, что следует читать как "имеет следующее значение". Знак ⇒ применим для определений и в тех случаях, когда
   значение выражения неопределено.

   Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
   потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
   строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
   выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
   она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

   Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
   будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
   набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
   значение вычисления любой константы - сама константа.

#+BEGIN_EXAMPLE
   "Hi Mom!" ⇒ "Hi Mom!"
#+END_EXAMPLE

   Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
   однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+BEGIN_EXAMPLE
   "hello" ⇒ "hello"
   42 ⇒ 42
   22/7 ⇒ 22/7
   3.141592653 ⇒ 3.141592653
   + ⇒ #<procedure>
   (+ 76 31) ⇒ 107
   (* -12 10) ⇒ -120
   '(a b c d) ⇒ (a b c d)
#+END_EXAMPLE

   Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
   одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
   попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
   ожидать её даже после окончания ввода.

   Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
   дождаться пояснений, найдя их далее в главе.

#+BEGIN_EXAMPLE
   (car '(a b c)) ⇒ a
   (cdr '(a b c)) ⇒ (b c)
   (cons 'a '(b c)) ⇒ (a b c)
   (cons (car '(a b c))
         (cdr '(d e f))) ⇒ (a e f)
#+END_EXAMPLE

   Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
   выражение по парным двойным кавычкам и скобкам.

   Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
   (define square
     (lambda (n)
       (* n n)))
#+end_src

   Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
   процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
   связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
   выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
   предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
   операций, вроде ~*~.

   Опробуем наш ~square~ в деле:

#+BEGIN_EXAMPLE
   (square 5) ⇒ 25
   (square -200) ⇒ 40000
   (square 0.5) ⇒ 0.25
   (square -1/2) ⇒ 1/4
#+END_EXAMPLE

   Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
   "reciprocal.ss."

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (if (= n 0)
           "oops!"
           (/ 1 n))))
#+end_src

   Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
   вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
   (load "reciprocal.ss")
#+end_src

   Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+BEGIN_EXAMPLE
   (reciprocal 10) ⇒ 1/10
   (reciprocal 1/10) ⇒ 10
   (reciprocal 0) ⇒ "oops!"
   (reciprocal (reciprocal 1/10)) ⇒ 1/10
#+END_EXAMPLE

** Простейшие выражения

   Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
   списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
   примеров со строками и числами.

   Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
   ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+BEGIN_EXAMPLE
   123456789987654321 ⇒ 123456789987654321
   3/4 ⇒ 3/4
   2.718281828 ⇒ 2.718281828
   2.2+1.1i ⇒ 2.2+1.1i
#+END_EXAMPLE

   Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
   целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
   используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

   Scheme предстадоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
   поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
   обозначают применение процедуры к набору аргументов.

#+BEGIN_EXAMPLE
   (+ 1/2 1/2) ⇒ 1
   (- 1.5 1/2) ⇒ 1.0

   (* 3 1/2) ⇒ 3/2
   (/ 1.5 3/4) ⇒ 2.0
#+END_EXAMPLE

   Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
   процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
   постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
   относительно приоритета или ассоциативности операторов.

   Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
   образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
   формул.

#+BEGIN_EXAMPLE
   (+ (+ 2 2) (+ 2 2)) ⇒ 8
   (- 2 (* 4 1/3)) ⇒ 2/3
   (* 2 (* 2 (* 2 (* 2 2)))) ⇒ 32
   (/ (* 6/7 7/2) (- 4.5 1.5)) ⇒ 1.0
#+END_EXAMPLE

   Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
   мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
   лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

   Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
   содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
   является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
   обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
   не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
   строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
   элементов, каждый из которых это список из двух элементов.

   Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
   Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
   ~(procedure arg ...)~?

   В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
   применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
   Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
   потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
   список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
   применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+BEGIN_EXAMPLE
   (quote (1 2 3 4 5)) ⇒ (1 2 3 4 5)
   (quote ("да" "это" "всё" "ещё" "список")) ⇒ ("да" "это" "всё" "ещё" "список")
   (quote (+ 3 4)) ⇒ (+ 3 4)
#+END_EXAMPLE

   С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
   ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
   третьего.

   Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
   обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
   аббривеатурой для ~quote~.

#+BEGIN_EXAMPLE
   '(1 2 3 4) ⇒ (1 2 3 4)
   '((1 2) (3 4)) ⇒ ((1 2) (3 4))
   '(/ (* 2 -1) 3) ⇒ (/ (* 2 -1) 3)
#+END_EXAMPLE

   Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
   будет заключён в выражение ~quote~.

   Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
   принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
   процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
   принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

   Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+BEGIN_EXAMPLE
   (quote hello) ⇒ hello
#+END_EXAMPLE

   Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hellp~ как
   переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
   выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
   об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
   думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
   списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
   идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
   используются для представления переменных в описании символьных уравнений или программ, символы могут также
   использоваться, например, как слова в описании предложений естественного языка.

   Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
   символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
   написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
   в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
   самых значительных особенностей Scheme.

   Числа и строки также могут цитироваться:

#+BEGIN_EXAMPLE
   '2 ⇒ 2
   '2/3 ⇒ 2/3
   (quote "Hi Mom!") ⇒ "Hi Mom!"
#+END_EXAMPLE

   Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

   Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
   значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
   оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
   на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+BEGIN_EXAMPLE
   (car '(a b c)) ⇒ a
   (cdr '(a b c)) ⇒ (b c)
   (cdr '(a)) ⇒ ()

   (car (cdr '(a b c))) ⇒ b
   (cdr (cdr '(a b c))) ⇒ (c)

   (car '((a b) (c d))) ⇒ (a b)
   (cdr '((a b) (c d))) ⇒ ((c d))
#+END_EXAMPLE

   Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
   /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

   Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
   ~cons~ вернёт список.

#+BEGIN_EXAMPLE
   (cons 'a '()) ⇒ (a)
   (cons 'a '(b c)) ⇒ (a b c)
   (cons 'a (cons 'b (cons 'c '()))) ⇒ (a b c)
   (cons '(a b) '(c d)) ⇒ ((a b) c d)

   (car (cons 'a '(b c))) ⇒ a
   (cdr (cons 'a '(b c))) ⇒ (b c)
   (cons (car '(a b c))
         (cdr '(d e f))) ⇒ (a e f)
   (cons (car '(a b c))
         (cdr '(a b c))) ⇒ (a b c)
#+END_EXAMPLE

   "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
   путём добавления элемента в начало списка называется /consing/.

   Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
   пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
   следующая пара в последовательности.

# +ATTR_ORG: :width 300
[[./images/1.gif]]

   /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
   /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
   /правильным/ становится любой список, /cdr/ которого /правильный/ список.

   Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
   списка.

#+BEGIN_EXAMPLE
   (cons 'a 'b) ⇒ (a . b)
   (cdr '(a . b)) ⇒ b
   (cons 'a '(b . c)) ⇒ (a b . c)
#+END_EXAMPLE

   Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
   чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
   /правильные/ списки без точек.

#+BEGIN_EXAMPLE
   '(a . (b . (c . ()))) ⇒ (a b c)
#+END_EXAMPLE

   Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
   строит /правильные/ списки.

#+BEGIN_EXAMPLE
   (list 'a 'b 'c) ⇒ (a b c)
   (list 'a) ⇒ (a)
   (list) ⇒ ()
#+END_EXAMPLE

   Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
   чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

   Упражнения

   1. Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
      1. ~1.2 × (2 - 1/3) + -8.7~
      2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
      3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
      4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~
   2. Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
      возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.
   3. Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
      ответы:
      1. ~(cons 'car 'cdr)~
      2. ~(list 'this '(is silly))~
      3. ~(cons 'is '(this silly?))~
      4. ~(quote (+ 2 3))~
      5. ~(cons '+ '(2 3))~
      6. ~(car '(+ 2 3))~
      7. ~(cdr '(+ 2 3))~
      8. ~cons~
      9. ~(quote cons)~
      10. ~(quote (quote cons))~
      11. ~(car (quote (quote cons)))~
      12. ~(+ 2 3)~
      13. ~(+ '2 '3)~
      14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
      15. ~((car (list + - * /)) 2 3)~
   4. ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
      которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.
   5. Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:
      #+ATTR_ORG: :width 300
      [[./images/2.gif]]
   6. Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
      ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~
   7. Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
      b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
      выражения ~((a b) (c d))~.
   8. Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
      объяснение?

** Выполнение Scheme выражений
** Variables and Let Expressions
** Lambda Expressions
** Top-Level Definitions
** Conditional Expressions
** Simple Recursion
** Assignment



#+BEGIN_EXAMPLE

#+END_EXAMPLE
