* Начало

  Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
  параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

  После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
  Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
  данных и управляющие конструкции.

** Взаимодействие с интерактивной оболочкой Scheme

   Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
   разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
   "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
   или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
   выполнения на экран.

   Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
   выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
   работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
   и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
   в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
   реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
   качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
   программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
   для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
   образом, как если бы они были набраны на клавиатуре интерактивно.

   Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
   значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
   позволяет сконцентрироваться на написании программы.

   Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
   можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После ⇒ следует значение
   выражения, что следует читать как "имеет следующее значение". Знак ⇒ применим для определений и в тех случаях, когда
   значение выражения неопределено.

   Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
   потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
   строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
   выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
   она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

   Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
   будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
   набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
   значение вычисления любой константы - сама константа.

#+BEGIN_EXAMPLE
  "Hi Mom!" ⇒ "Hi Mom!"
#+END_EXAMPLE

   Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
   однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+BEGIN_EXAMPLE
  "hello" ⇒ "hello"
  42 ⇒ 42
  22/7 ⇒ 22/7
  3.141592653 ⇒ 3.141592653
  + ⇒ #<procedure>
  (+ 76 31) ⇒ 107
  (* -12 10) ⇒ -120
  '(a b c d) ⇒ (a b c d)
#+END_EXAMPLE

  Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
  одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
  попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
  ожидать её даже после окончания ввода.

  Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
  дождаться пояснений, найдя их далее в главе.

#+BEGIN_EXAMPLE
  (car '(a b c)) ⇒ a
  (cdr '(a b c)) ⇒ (b c)
  (cons 'a '(b c)) ⇒ (a b c)
  (cons (car '(a b c))
        (cdr '(d e f))) ⇒ (a e f)
#+END_EXAMPLE

   Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
   выражение по парным двойным кавычкам и скобкам.

   Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
  (define square
    (lambda (n)
      (* n n)))
#+end_src

   Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
   процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
   связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
   выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
   предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
   операций, вроде ~*~.

   Опробуем наш ~square~ в деле:

#+BEGIN_EXAMPLE
(square 5) ⇒ 25
(square -200) ⇒ 40000
(square 0.5) ⇒ 0.25
(square -1/2) ⇒ 1/4
#+END_EXAMPLE

   Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
   "reciprocal.ss."

#+begin_src scheme
(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))
#+end_src

   Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
   вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
(load "reciprocal.ss")
#+end_src

   Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+BEGIN_EXAMPLE
(reciprocal 10) ⇒ 1/10
(reciprocal 1/10) ⇒ 10
(reciprocal 0) ⇒ "oops!"
(reciprocal (reciprocal 1/10)) ⇒ 1/10
#+END_EXAMPLE

** Simple Expressions
** Evaluating Scheme Expressions
** Variables and Let Expressions
** Lambda Expressions
** Top-Level Definitions
** Conditional Expressions
** Simple Recursion
** Assignment
