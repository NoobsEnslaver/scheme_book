# -*- fill-column: 120; -*-

* Начало

  Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
  параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

  После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
  Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
  данных и управляющие конструкции.

** Взаимодействие с интерактивной оболочкой Scheme

   Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
   разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
   "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
   или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
   выполнения на экран.

   Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
   выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
   работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
   и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
   в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
   реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
   качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
   программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
   для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
   образом, как если бы они были набраны на клавиатуре интерактивно.

   Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
   значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
   позволяет сконцентрироваться на написании программы.

   Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
   можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После ⇒ следует значение
   выражения, что следует читать как "имеет следующее значение". Знак ⇒ применим для определений и в тех случаях, когда
   значение выражения неопределено.

   Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
   потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
   строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
   выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
   она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

   Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
   будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
   набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
   значение вычисления любой константы - сама константа.

#+begin_src scheme
   "Hi Mom!" ⇒ "Hi Mom!"
#+end_src

   Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
   однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+begin_src scheme
   "hello" ⇒ "hello"
   42 ⇒ 42
   22/7 ⇒ 22/7
   3.141592653 ⇒ 3.141592653
   + ⇒ #<procedure>
   (+ 76 31) ⇒ 107
   (* -12 10) ⇒ -120
   '(a b c d) ⇒ (a b c d)
#+end_src

   Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
   одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
   попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
   ожидать её даже после окончания ввода.

   Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
   дождаться пояснений, найдя их далее в главе.

#+begin_src scheme
   (car '(a b c)) ⇒ a
   (cdr '(a b c)) ⇒ (b c)
   (cons 'a '(b c)) ⇒ (a b c)
   (cons (car '(a b c))
         (cdr '(d e f))) ⇒ (a e f)
#+end_src

   Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
   выражение по парным двойным кавычкам и скобкам.

   Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
   (define square
     (lambda (n)
       (* n n)))
#+end_src

   Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
   процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
   связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
   выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
   предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
   операций, вроде ~*~.

   Опробуем наш ~square~ в деле:

#+begin_src scheme
   (square 5) ⇒ 25
   (square -200) ⇒ 40000
   (square 0.5) ⇒ 0.25
   (square -1/2) ⇒ 1/4
#+end_src

   Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
   "reciprocal.ss."

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (if (= n 0)
           "oops!"
           (/ 1 n))))
#+end_src

   Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
   вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
   (load "reciprocal.ss")
#+end_src

   Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+begin_src scheme
   (reciprocal 10) ⇒ 1/10
   (reciprocal 1/10) ⇒ 10
   (reciprocal 0) ⇒ "oops!"
   (reciprocal (reciprocal 1/10)) ⇒ 1/10
#+end_src

** Простейшие выражения

   Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
   списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
   примеров со строками и числами.

   Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
   ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+begin_src scheme
   123456789987654321 ⇒ 123456789987654321
   3/4 ⇒ 3/4
   2.718281828 ⇒ 2.718281828
   2.2+1.1i ⇒ 2.2+1.1i
#+end_src

   Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
   целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
   используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

   Scheme предстадоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
   поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
   обозначают применение процедуры к набору аргументов.

#+begin_src scheme
   (+ 1/2 1/2) ⇒ 1
   (- 1.5 1/2) ⇒ 1.0

   (* 3 1/2) ⇒ 3/2
   (/ 1.5 3/4) ⇒ 2.0
#+end_src

   Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
   процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
   постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
   относительно приоритета или ассоциативности операторов.

   Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
   образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
   формул.

#+begin_src scheme
   (+ (+ 2 2) (+ 2 2)) ⇒ 8
   (- 2 (* 4 1/3)) ⇒ 2/3
   (* 2 (* 2 (* 2 (* 2 2)))) ⇒ 32
   (/ (* 6/7 7/2) (- 4.5 1.5)) ⇒ 1.0
#+end_src

   Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
   мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
   лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

   Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
   содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
   является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
   обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
   не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
   строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
   элементов, каждый из которых это список из двух элементов.

   Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
   Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
   ~(procedure arg ...)~?

   В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
   применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
   Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
   потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
   список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
   применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+begin_src scheme
   (quote (1 2 3 4 5)) ⇒ (1 2 3 4 5)
   (quote ("да" "это" "всё" "ещё" "список")) ⇒ ("да" "это" "всё" "ещё" "список")
   (quote (+ 3 4)) ⇒ (+ 3 4)
#+end_src

   С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
   ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
   третьего.

   Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
   обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
   аббривеатурой для ~quote~.

#+begin_src scheme
   '(1 2 3 4) ⇒ (1 2 3 4)
   '((1 2) (3 4)) ⇒ ((1 2) (3 4))
   '(/ (* 2 -1) 3) ⇒ (/ (* 2 -1) 3)
#+end_src

   Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
   будет заключён в выражение ~quote~.

   Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
   принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
   процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
   принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

   Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+begin_src scheme
   (quote hello) ⇒ hello
#+end_src

   Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hellp~ как
   переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
   выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
   об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
   думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
   списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
   идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
   используются для представления переменных в описании символьных уравнений или программ, символы могут также
   использоваться, например, как слова в описании предложений естественного языка.

   Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
   символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
   написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
   в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
   самых значительных особенностей Scheme.

   Числа и строки также могут цитироваться:

#+begin_src scheme
   '2 ⇒ 2
   '2/3 ⇒ 2/3
   (quote "Hi Mom!") ⇒ "Hi Mom!"
#+end_src

   Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

   Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
   значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
   оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
   на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+begin_src scheme
   (car '(a b c)) ⇒ a
   (cdr '(a b c)) ⇒ (b c)
   (cdr '(a)) ⇒ ()

   (car (cdr '(a b c))) ⇒ b
   (cdr (cdr '(a b c))) ⇒ (c)

   (car '((a b) (c d))) ⇒ (a b)
   (cdr '((a b) (c d))) ⇒ ((c d))
#+end_src

   Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
   /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

   Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
   ~cons~ вернёт список.

#+begin_src scheme
   (cons 'a '()) ⇒ (a)
   (cons 'a '(b c)) ⇒ (a b c)
   (cons 'a (cons 'b (cons 'c '()))) ⇒ (a b c)
   (cons '(a b) '(c d)) ⇒ ((a b) c d)

   (car (cons 'a '(b c))) ⇒ a
   (cdr (cons 'a '(b c))) ⇒ (b c)
   (cons (car '(a b c))
         (cdr '(d e f))) ⇒ (a e f)
   (cons (car '(a b c))
         (cdr '(a b c))) ⇒ (a b c)
#+end_src

   "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
   путём добавления элемента в начало списка называется /consing/.

   Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
   пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
   следующая пара в последовательности.

# +ATTR_ORG: :width 300
[[./images/1.gif]]

   /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
   /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
   /правильным/ становится любой список, /cdr/ которого /правильный/ список.

   Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
   списка.

#+begin_src scheme
   (cons 'a 'b) ⇒ (a . b)
   (cdr '(a . b)) ⇒ b
   (cons 'a '(b . c)) ⇒ (a b . c)
#+end_src

   Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
   чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
   /правильные/ списки без точек.

#+begin_src scheme
   '(a . (b . (c . ()))) ⇒ (a b c)
#+end_src

   Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
   строит /правильные/ списки.

#+begin_src scheme
   (list 'a 'b 'c) ⇒ (a b c)
   (list 'a) ⇒ (a)
   (list) ⇒ ()
#+end_src

   Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
   чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

*** Упражнение 2.2.1

    Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
    1. ~1.2 × (2 - 1/3) + -8.7~
    2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
    3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
    4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~

*** Упражнение 2.2.2

    Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
    возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.

*** Упражнение 2.2.3

    Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
    ответы:
    1. ~(cons 'car 'cdr)~
    2. ~(list 'this '(is silly))~
    3. ~(cons 'is '(this silly?))~
    4. ~(quote (+ 2 3))~
    5. ~(cons '+ '(2 3))~
    6. ~(car '(+ 2 3))~
    7. ~(cdr '(+ 2 3))~
    8. ~cons~
    9. ~(quote cons)~
    10. ~(quote (quote cons))~
    11. ~(car (quote (quote cons)))~
    12. ~(+ 2 3)~
    13. ~(+ '2 '3)~
    14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
    15. ~((car (list + - * /)) 2 3)~

*** Упражнение 2.2.4

    ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
    которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.

*** Упражнение 2.2.5

    Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:

#+ATTR_ORG: :width 300
[[./images/2.gif]]

*** Упражнение 2.2.6

    Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
    ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~

*** Упражнение 2.2.7

    Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
    b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
    выражения ~((a b) (c d))~.

*** Упражнение 2.2.8

    Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
    объяснение?

** Выполнение Scheme выражений

   Let's turn to a discussion of how Scheme evaluates the expressions you type. We have already established the rules
   for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out
   in your mind a rule for evaluating procedure applications of the form (procedure arg1 ... argn). Here, procedure is
   an expression representing a Scheme procedure, and arg1 ... argn are expressions representing its arguments. One
   possibility is the following.

   + Find the value of procedure.
   + Find the value of arg1.
   + ...
   + Find the value of argn.
   + Apply the value of procedure to the values of arg1 ... argn.

   For example, consider the simple procedure application (+ 3 4). The value of + is the addition procedure, the value
   of 3 is the number 3, and the value of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so our
   value is the object 7.

   By applying this process at each level, we can find the value of the nested expression (* (+ 3 4) 2). The value of *
   is the multiplication procedure, the value of (+ 3 4) we can determine to be the number 7, and the value of 2 is the
   number 2. Multiplying 7 by 2 we get 14, so our answer is 14.

   This rule works for procedure applications but not for quote expressions because the subexpressions of a procedure
   application are evaluated, whereas the subexpression of a quote expression is not. The evaluation of a quote
   expression is more similar to the evaluation of constant objects. The value of a quote expression of the form (quote
   object) is simply object.

   Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided
   by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme
   programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions
   defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining core syntactic forms and a
   few syntactic extensions in the remaining sections of this chapter. Section 3.1 summarizes the core syntactic forms
   and introduces the syntactic extension mechanism.

   Before we go on to more syntactic forms and procedures, two points related to the evaluation of procedure
   applications are worthy of note. First, the process given above is overspecified, in that it requires the
   subexpressions to be evaluated from left to right. That is, procedure is evaluated before arg1, arg1 is evaluated
   before arg2, and so on. This need not be the case. A Scheme evaluator is free to evaluate the expressions in any
   order---left to right, right to left, or any other sequential order. In fact, the subexpressions may be evaluated in
   different orders for different applications, even in the same implementation.

   The second point is that procedure is evaluated in the same way as arg1 ... argn. While procedure is often a variable
   that names a particular procedure, this need not be the case. Exercise 2.2.3 had you determine the value of the
   expression ((car (list + - * /)) 2 3). Here, procedure is (car (list + - * /)). The value of (car (list + - * /)) is
   the addition procedure, just as if procedure were simply the variable +.

*** Exercise 2.3.1

    Write down the steps necessary to evaluate the expression below.

#+begin_src scheme
    ((car (cdr (list + - * /))) 17 5)
#+end_src

** Variables and Let Expressions

   Suppose expr is a Scheme expression that contains a variable var. Suppose, additionally, that we would like var to
   have the value val when we evaluate expr. For example, we might like x to have the value 2 when we evaluate (+ x
   3). Or, we might want y to have the value 3 when we evaluate (+ 2 y). The following examples demonstrate how to do
   this using Scheme's let syntactic form.

#+begin_src scheme
   (let ((x 2))
     (+ x 3)) ⇒ 5

   (let ((y 3))
     (+ 2 y)) ⇒ 5

   (let ((x 2) (y 3))
     (+ x y)) ⇒ 5
#+end_src

   The let syntactic form includes a list of variable-expression pairs, along with a sequence of expressions referred to
   as the body of the let. The general form of a let expression is

#+begin_src scheme
   (let ((var expr) ...) body1 body2 ...)
#+end_src

   We say the variables are bound to the values by the let. We refer to variables bound by let as let-bound variables.

   A let expression is often used to simplify an expression that would contain two identical subexpressions. Doing so
   also ensures that the value of the common subexpression is computed only once.

#+begin_src scheme
   (+ (* 4 4) (* 4 4)) ⇒ 32

   (let ((a (* 4 4))) (+ a a)) ⇒ 32
#+end_src

   Brackets are often used in place of parentheses to delimit the bindings of a let expression.

#+begin_src scheme
   (let ([list1 '(a b c)] [list2 '(d e f)])
     (cons (cons (car list1)
                 (car list2))
           (cons (car (cdr list1))
                 (car (cdr list2))))) ⇒ ((a . d) b . e)
#+end_src

   Scheme treats forms enclosed in brackets just like forms enclosed in parentheses. An open bracket must be matched by
   a close bracket, and an open parenthesis must be matched by a close parenthesis. We use brackets for let (and, as
   we'll see, several other standard syntactic forms) to improve readability, especially when we might otherwise have
   two or more consecutive open parentheses.

   Since expressions in the first position of a procedure application are evaluated no differently from other
   expressions, a let-bound variable may be used there as well.

#+begin_src scheme
   (let ([f +])
     (f 2 3)) ⇒ 5

   (let ([f +] [x 2])
     (f x 3)) ⇒ 5

   (let ([f +] [x 2] [y 3])
     (f x y)) ⇒ 5
#+end_src

   The variables bound by let are visible only within the body of the let.

#+begin_src scheme
   (let ([+ *])
     (+ 2 3)) ⇒ 6

   (+ 2 3) ⇒ 5
#+end_src

   This is fortunate, because we would not want the value of + to be the multiplication procedure everywhere.

   It is possible to nest let expressions.

#+begin_src scheme
   (let ([a 4] [b -3])
     (let ([a-squared (* a a)]
           [b-squared (* b b)])
       (+ a-squared b-squared))) ⇒ 25
#+end_src

   When nested let expressions bind the same variable, only the binding created by the inner let is visible within its body.

#+begin_src scheme
   (let ([x 1])
     (let ([x (+ x 1)])
       (+ x x))) ⇒ 4
#+end_src

   The outer let expression binds x to 1 within its body, which is the second let expression. The inner let expression
   binds x to (+ x 1) within its body, which is the expression (+ x x). What is the value of (+ x 1)? Since (+ x 1)
   appears within the body of the outer let but not within the body of the inner let, the value of x must be 1 and hence
   the value of (+ x 1) is 2. What about (+ x x)? It appears within the body of both let expressions. Only the inner
   binding for x is visible, so x is 2 and (+ x x) is 4.

   The inner binding for x is said to shadow the outer binding. A let-bound variable is visible everywhere within the
   body of its let expression except where it is shadowed. The region where a variable binding is visible is called its
   scope. The scope of the first x in the example above is the body of the outer let expression minus the body of the
   inner let expression, where it is shadowed by the second x. This form of scoping is referred to as lexical scoping,
   since the scope of each binding can be determined by a straightforward textual analysis of the program.

   Shadowing may be avoided by choosing different names for variables. The expression above could be rewritten so that
   the variable bound by the inner let is new-x.

#+begin_src scheme
   (let ([x 1])
     (let ([new-x (+ x 1)])
       (+ new-x new-x))) ⇒ 4
#+end_src

   Although choosing different names can sometimes prevent confusion, shadowing can help prevent the accidental use of
   an "old" value. For example, with the original version of the preceding example, it would be impossible for us to
   mistakenly refer to the outer x within the body of the inner let.

*** Exercise 2.4.1

    Rewrite the following expressions, using let to remove common subexpressions and to improve the structure of the
    code. Do not perform any algebraic simplifications.

    + ~(+ (- (* 3 a) b) (+ (* 3 a) b))~
    + ~(cons (car (list a b c)) (cdr (list a b c)))~

*** Exercise 2.4.2

    Determine the value of the following expression. Explain how you derived this value.

#+begin_src scheme
    (let ([x 9])
      (* x
         (let ([x (/ x 3)])
           (+ x x))))
#+end_src

*** Exercise 2.4.3

    Rewrite the following expressions to give unique names to each different let-bound variable so that none of the
    variables is shadowed. Verify that the value of your expression is the same as that of the original expression.

    +
#+begin_src scheme
    (let ([x 'a] [y 'b])
      (list (let ([x 'c]) (cons x y))
            (let ([y 'd]) (cons x y))))
#+end_src

    +
#+begin_src scheme
    (let ([x '((a b) c)])
      (cons (let ([x (cdr x)])
              (car x))
            (let ([x (car x)])
              (cons (let ([x (cdr x)])
                      (car x))
                    (cons (let ([x (car x)])
                            x)
                          (cdr x))))))
#+end_src

** Lambda Expressions

   In the expression ~(let ([x (* 3 4)]) (+ x x))~, the variable x is bound to the value of (* 3 4). What if we would
   like the value of (+ x x) where x is bound to the value of (/ 99 11)? Where x is bound to the value of (- 2 7)? In
   each case we need a different let expression. When the body of the let is complicated, however, having to repeat it
   can be inconvenient.

   Instead, we can use the syntactic form lambda to create a new procedure that has x as a parameter and has the same
   body as the let expression.

#+begin_src scheme
   (lambda (x) (+ x x)) ⇒ #<procedure>
#+end_src

   The general form of a lambda expression is

#+begin_src scheme
   (lambda (var ...) body1 body2 ...)
#+end_src

   The variables var ... are the formal parameters of the procedure, and the sequence of expressions body1 body2 ... is
   its body. (Actually, the true general form is somewhat more general than this, as you will see later.)

   A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed
   representation as far as Scheme is concerned, however, so this book uses the notation #<procedure> to show that the
   value of an expression is a procedure.

   The most common operation to perform on a procedure is to apply it to one or more values.

#+begin_src scheme
   ((lambda (x) (+ x x)) (* 3 4)) ⇒ 24
#+end_src

   This is no different from any other procedure application. The procedure is the value of (lambda (x) (+ x x)), and
   the only argument is the value of (* 3 4), or 12. The argument values, or actual parameters, are bound to the formal
   parameters within the body of the lambda expression in the same way as let-bound variables are bound to their
   values. In this case, x is bound to 12, and the value of (+ x x) is 24. Thus, the result of applying the procedure to
   the value 12 is 24.

   Because procedures are objects, we can establish a procedure as the value of a variable and use the procedure more
   than once.

#+begin_src scheme
   (let ([double (lambda (x) (+ x x))])
     (list (double (* 3 4))
           (double (/ 99 11))
           (double (- 2 7)))) ⇒ (24 18 -10)
#+end_src

   Here, we establish a binding for double to a procedure, then use this procedure to double three different values.

   The procedure expects its actual parameter to be a number, since it passes the actual parameter on to +. In general,
   the actual parameter may be any sort of object. Consider, for example, a similar procedure that uses cons instead of
   +.

#+begin_src scheme
   (let ([double-cons (lambda (x) (cons x x))])
     (double-cons 'a)) ⇒ (a . a)
#+end_src

   Noting the similarity between double and double-cons, you should not be surprised to learn that they may be collapsed
   into a single procedure by adding an additional argument.

#+begin_src scheme
   (let ([double-any (lambda (f x) (f x x))])
     (list (double-any + 13)
           (double-any cons 'a))) ⇒ (26 (a . a))
#+end_src

   This demonstrates that procedures may accept more than one argument and that arguments passed to a procedure may
   themselves be procedures.

   As with let expressions, lambda expressions become somewhat more interesting when they are nested within other lambda
   or let expressions.

#+begin_src scheme
   (let ([x 'a])
     (let ([f (lambda (y) (list x y))])
       (f 'b))) ⇒ (a b)
#+end_src

   The occurrence of x within the lambda expression refers to the x outside the lambda that is bound by the outer let
   expression. The variable x is said to occur free in the lambda expression or to be a free variable of the lambda
   expression. The variable y does not occur free in the lambda expression since it is bound by the lambda expression. A
   variable that occurs free in a lambda expression should be bound, e.g., by an enclosing lambda or let expression,
   unless the variable is (like the names of primitive procedures) bound outside of the expression, as we discuss in the
   following section.

   What happens when the procedure is applied somewhere outside the scope of the bindings for variables that occur free
   within the procedure, as in the following expression?

#+begin_src scheme
   (let ([f (let ([x 'sam])
              (lambda (y z) (list x y z)))])
     (f 'i 'am)) ⇒ (sam i am)
#+end_src

   The answer is that the same bindings that were in effect when the procedure was created are in effect again when the
   procedure is applied. This is true even if another binding for x is visible where the procedure is applied.

#+begin_src scheme
   (let ([f (let ([x 'sam])
              (lambda (y z) (list x y z)))])
     (let ([x 'not-sam])
       (f 'i 'am))) ⇒ (sam i am)
#+end_src

   In both cases, the value of x within the procedure named f is sam.

   Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of
   argument expressions. For example, the two expressions below are equivalent.

#+begin_src scheme
   (let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)
#+end_src

   In fact, a let expression is a syntactic extension defined in terms of lambda and procedure application, which are
   both core syntactic forms. In general, any expression of the form

#+begin_src scheme
   (let ((var expr) ...) body1 body2 ...)
#+end_src

   is equivalent to the following.

#+begin_src scheme
   ((lambda (var ...) body1 body2 ...)
    expr ...)
#+end_src

   See Section 3.1 for more about core forms and syntactic extensions.

   As mentioned above, the general form of lambda is a bit more complicated than the form we saw earlier, in that the
   formal parameter specification, (var ...), need not be a proper list, or indeed even a list at all. The formal
   parameter specification can be in any of the following three forms:

   + a proper list of variables, (var1 ... varn), such as we have already seen,
   + a single variable, varr, or
   + an improper list of variables, (var1 ... varn . varr).

   In the first case, exactly n actual parameters must be supplied, and each variable is bound to the corresponding
   actual parameter. In the second, any number of actual parameters is valid; all of the actual parameters are put into
   a single list and the single variable is bound to this list. The third case is a hybrid of the first two cases. At
   least n actual parameters must be supplied. The variables var1 ... varn are bound to the corresponding actual
   parameters, and the variable varr is bound to a list containing the remaining actual parameters. In the second and
   third cases, varr is sometimes referred to as a "rest" parameter because it holds the rest of the actual parameters
   beyond those that are individually named.

   Let's consider a few examples to help clarify the more general syntax of lambda expressions.

#+begin_src scheme
   (let ([f (lambda x x)])
     (f 1 2 3 4)) ⇒ (1 2 3 4)

   (let ([f (lambda x x)])
     (f)) ⇒ ()

   (let ([g (lambda (x . y) (list x y))])
     (g 1 2 3 4)) ⇒ (1 (2 3 4))

   (let ([h (lambda (x y . z) (list x y z))])
     (h 'a 'b 'c 'd)) ⇒ (a b (c d))
#+end_src

   In the first two examples, the procedure named f accepts any number of arguments. These arguments are automatically
   formed into a list to which the variable x is bound; the value of f is this list. In the first example, the arguments
   are 1, 2, 3, and 4, so the answer is (1 2 3 4). In the second, there are no arguments, so the answer is the empty
   list (). The value of the procedure named g in the third example is a list whose first element is the first argument
   and whose second element is a list containing the remaining arguments. The procedure named h is similar but separates
   out the second argument. While f accepts any number of arguments, g must receive at least one and h must receive at
   least two.

*** Exercise 2.5.1
    Determine the values of the expressions below.

    +
#+begin_src scheme
    (let ([f (lambda (x) x)])
      (f 'a))
#+end_src

    +
#+begin_src scheme
    (let ([f (lambda x x)])
      (f 'a))
#+end_src

    +
#+begin_src scheme
    (let ([f (lambda (x . y) x)])
      (f 'a))
#+end_src

    +
#+begin_src scheme
    (let ([f (lambda (x . y) y)])
      (f 'a))
#+end_src

*** Exercise 2.5.2

    How might the primitive procedure list be defined?

*** Exercise 2.5.3

    List the variables that occur free in each of the lambda expressions below. Do not omit variables that name
    primitive procedures such as + or cons.

    +
#+begin_src scheme
    (lambda (f x) (f x))
#+end_src

    +
#+begin_src scheme
    (lambda (x) (+ x x))
#+end_src

    +
#+begin_src scheme
    (lambda (x y) (f x y))
#+end_src

    +
#+begin_src scheme
    (lambda (x)
      (cons x (f x y)))
#+end_src

    +
#+begin_src scheme
    (lambda (x)
      (let ([z (cons x y)])
        (x y z)))
#+end_src

    +
#+begin_src scheme
    (lambda (x)
      (let ([y (cons x y)])
        (x y z)))
#+end_src

** Top-Level Definitions

   The variables bound by let and lambda expressions are not visible outside the bodies of these expressions. Suppose
   you have created an object, perhaps a procedure, that must be accessible anywhere, like + or cons. What you need is a
   top-level definition, which may be established with define. Top-level definitions, which are supported by most
   interactive Scheme systems, are visible in every expression you enter, except where shadowed by another binding.

   Let's establish a top-level definition of the double-any procedure of the last section.

#+begin_src scheme
   (define double-any
     (lambda (f x)
       (f x x)))
#+end_src

   The variable double-any now has the same status as cons or the name of any other primitive procedure. We can use
   double-any as if it were a primitive procedure.

#+begin_src scheme
   (double-any + 10) ⇒ 20
   (double-any cons 'a) ⇒ (a . a)
#+end_src

   A top-level definition may be established for any object, not just for procedures.

#+begin_src scheme
   (define sandwich "peanut-butter-and-jelly")

   sandwich ⇒ "peanut-butter-and-jelly"

#+end_src

   Most often, though, top-level definitions are used for procedures.

   As suggested above, top-level definitions may be shadowed by let or lambda bindings.

#+begin_src scheme
   (define xyz '(x y z))
   (let ([xyz '(z y x)])
     xyz) ⇒ (z y x)
#+end_src

   Variables with top-level definitions act almost as if they were bound by a let expression enclosing all of the
   expressions you type.

   Given only the simple tools you have read about up to this point, it is already possible to define some of the
   primitive procedures provided by Scheme and described later in this book. If you completed the exercises from the
   last section, you should already know how to define list.

#+begin_src scheme
   (define list (lambda x x))
#+end_src

   Also, Scheme provides the abbreviations cadr and cddr for the compositions of car with cdr and cdr with cdr. That is,
   (cadr list) is equivalent to (car (cdr list)), and, similarly, (cddr list) is equivalent to (cdr (cdr list)). They
   are easily defined as follows.

#+begin_src scheme
   (define cadr
     (lambda (x)
       (car (cdr x))))

   (define cddr
     (lambda (x)
       (cdr (cdr x))))

   (cadr '(a b c)) ⇒ b
   (cddr '(a b c)) ⇒ (c)
#+end_src

   Any definition (define var expr) where expr is a lambda expression can be written in a shorter form that suppresses
   the lambda. The exact syntax depends upon the format of the lambda expression's formal parameter specifier, i.e.,
   whether it is a proper list of variables, a single variable, or an improper list of variables. A definition of the
   form

#+begin_src scheme
   (define var0
     (lambda (var1 ... varn)
       e1 e2 ...))
#+end_src

   may be abbreviated

#+begin_src scheme
   (define (var0 var1 ... varn)
     e1 e2 ...)
#+end_src

   while

#+begin_src scheme
   (define var0
     (lambda varr
       e1 e2 ...))
#+end_src

   may be abbreviated

#+begin_src scheme
   (define (var0 . varr)
     e1 e2 ...)
#+end_src

   and

#+begin_src scheme
   (define var0
     (lambda (var1 ... varn . varr)
       e1 e2 ...))
#+end_src

   may be abbreviated

#+begin_src scheme
   (define (var0 var1 ... varn . varr)
     e1 e2 ...)
#+end_src

   For example, the definitions of cadr and list might be written as follows.

#+begin_src scheme
   (define (cadr x)
     (car (cdr x)))

   (define (list . x) x)

#+end_src

   This book does not often employ this alternative syntax. Although it is shorter, it tends to mask the reality that
   procedures are not intimately tied to variables, or names, as they are in many other languages. This syntax is often
   referred to, somewhat pejoratively, as the "defun" syntax for define, after the defun form provided by Lisp languages
   in which procedures are more closely tied to their names.

   Top-level definitions make it easier for us to experiment with a procedure interactively because we need not retype
   the procedure each time it is used. Let's try defining a somewhat more complicated variation of double-any, one that
   turns an "ordinary" two-argument procedure into a "doubling" one-argument procedure.

#+begin_src scheme
   (define doubler
     (lambda (f)
       (lambda (x) (f x x))))
#+end_src

   doubler accepts one argument, f, which must be a procedure that accepts two arguments. The procedure returned by
   doubler accepts one argument, which it uses for both arguments in an application of f. We can define, with doubler,
   the simple double and double-cons procedures of the last section.

#+begin_src scheme
   (define double (doubler +))
   (double 13/2) ⇒ 13

   (define double-cons (doubler cons))
   (double-cons 'a) ⇒ (a . a)
#+end_src

   We can also define double-any with doubler.

#+begin_src scheme
   (define double-any
     (lambda (f x)
       ((doubler f) x)))
#+end_src

   Within double and double-cons, f has the appropriate value, i.e., + or cons, even though the procedures are clearly
   applied outside the scope of f.

   What happens if you attempt to use a variable that is not bound by a let or lambda expression and that does not have
   a top-level definition? Try using the variable i-am-not-defined to see what happens.

#+begin_src scheme
   (i-am-not-defined 3)
#+end_src

   Most Scheme systems print a message indicating that an unbound- or undefined-variable exception has occurred.

   The system should not, however, complain about the appearance of an undefined variable within a lambda expression,
   until and unless the resulting procedure is applied. The following should not cause an exception, even though we have
   not yet established a top-level definition of proc2.

#+begin_src scheme
   (define proc1
     (lambda (x y)
       (proc2 y x)))
#+end_src

   If you try to apply proc1 before defining proc2, you should get a undefined exception message. Let's give proc2 a
   top-level definition and try proc1.

#+begin_src scheme
   (define proc2 cons)
   (proc1 'a 'b) ⇒ (b . a)
#+end_src

   When you define proc1, the system accepts your promise to define proc2, and does not complain unless you use proc1
   before defining proc2. This allows you to define procedures in any order you please. This is especially useful when
   you are trying to organize a file full of procedure definitions in a way that makes your program more readable. It is
   necessary when two procedures defined at top level depend upon each other; we will see some examples of this later.

*** Exercise 2.6.1
    What would happen if you were to type

#+begin_src scheme
    (double-any double-any double-any)
#+end_src

    given the definition of double-any from the beginning of this section?

*** Exercise 2.6.2
    A more elegant (though possibly less efficient) way to define cadr and cddr than given in this section is to define a
    procedure that composes two procedures to create a third. Write the procedure compose, such that (compose p1 p2) is
    the composition of p1 and p2 (assuming both take one argument). That is, (compose p1 p2) should return a new
    procedure of one argument that applies p1 to the result of applying p2 to the argument. Use compose to define cadr
    and cddr.

*** Exercise 2.6.3
    Scheme also provides caar, cdar, caaar, caadr, and so on, with any combination of up to four a's (representing car)
    and d's (representing cdr) between the c and the r (see Section 6.3). Define each of these with the compose procedure
    of the preceding exercise.

** Conditional Expressions

   So far we have considered expressions that perform a given task unconditionally. Suppose that we wish to write the
   procedure abs. If its argument x is negative, abs returns -x; otherwise, it returns x. The most straightforward way
   to write abs is to determine whether the argument is negative and if so negate it, using the if syntactic form.

#+begin_src scheme
   (define abs
     (lambda (n)
       (if (< n 0)
           (- 0 n)
           n)))

   (abs 77) ⇒ 77
   (abs -77) ⇒ 77
#+end_src

   An if expression has the form (if test consequent alternative), where consequent is the expression to evaluate if
   test is true and alternative is the expression to evaluate if test is false. In the expression above, test is (< n
   0), consequent is (- 0 n), and alternative is n.

   The procedure abs could be written in a variety of other ways. Any of the following are valid definitions of abs.

#+begin_src scheme
   (define abs
     (lambda (n)
       (if (>= n 0)
           n
           (- 0 n))))

   (define abs
     (lambda (n)
       (if (not (< n 0))
           n
           (- 0 n))))

   (define abs
     (lambda (n)
       (if (or (> n 0) (= n 0))
           n
           (- 0 n))))

   (define abs
     (lambda (n)
       (if (= n 0)
           0
           (if (< n 0)
               (- 0 n)
               n))))

   (define abs
     (lambda (n)
       ((if (>= n 0) + -)
        0
        n)))
#+end_src

   The first of these definitions asks if n is greater than or equal to zero, inverting the test. The second asks if n
   is not less than zero, using the procedure not with <. The third asks if n is greater than zero or n is equal to
   zero, using the syntactic form or. The fourth treats zero separately, though there is no benefit in doing so. The
   fifth is somewhat tricky; n is either added to or subtracted from zero, depending upon whether n is greater than or
   equal to zero.

   Why is if a syntactic form and not a procedure? In order to answer this, let's revisit the definition of reciprocal
   from the first section of this chapter.

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (if (= n 0)
           "oops!"
           (/ 1 n))))
#+end_src

   The second argument to the division procedure should not be zero, since the result is mathematically undefined. Our
   definition of reciprocal avoids this problem by testing for zero before dividing. Were if a procedure, its arguments
   (including (/ 1 n)) would be evaluated before it had a chance to choose between the consequent and alternative. Like
   quote, which does not evaluate its only subexpression, if does not evaluate all of its subexpressions and so cannot
   be a procedure.

   The syntactic form or operates in a manner similar to if. The general form of an or expression is (or expr ...). If
   there are no subexpressions, i.e., the expression is simply (or), the value is false. Otherwise, each expr is
   evaluated in turn until either (a) one of the expressions evaluates to true or (b) no more expressions are left. In
   case (a), the value is true; in case (b), the value is false.

   To be more precise, in case (a), the value of the or expression is the value of the last subexpression
   evaluated. This clarification is necessary because there are many possible true values. Usually, the value of a test
   expression is one of the two objects #t, for true, or #f, for false.

#+begin_src scheme
   (< -1 0) ⇒ #t
   (> -1 0) ⇒ #f
#+end_src

   Every Scheme object, however, is considered to be either true or false by conditional expressions and by the
   procedure not. Only #f is considered false; all other objects are considered true.

#+begin_src scheme
   (if #t 'true 'false) ⇒ true
   (if #f 'true 'false) ⇒ false
   (if '() 'true 'false) ⇒ true
   (if 1 'true 'false) ⇒ true
   (if '(a b c) 'true 'false) ⇒ true

   (not #t) ⇒ #f
   (not "false") ⇒ #f
   (not #f) ⇒ #t

   (or) ⇒ #f
   (or #f) ⇒ #f
   (or #f #t) ⇒ #t
   (or #f 'a #f) ⇒ a
#+end_src

   The and syntactic form is similar in form to or, but an and expression is true if all its subexpressions are true,
   and false otherwise. In the case where there are no subexpressions, i.e., the expression is simply (and), the value
   is true. Otherwise, the subexpressions are evaluated in turn until either no more subexpressions are left or the
   value of a subexpression is false. The value of the and expression is the value of the last subexpression evaluated.

   Using and, we can define a slightly different version of reciprocal.

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (and (not (= n 0))
            (/ 1 n))))

   (reciprocal 3) ⇒ 1/3
   (reciprocal 0.5) ⇒ 2.0
   (reciprocal 0) ⇒ #f
#+end_src

   In this version, the value is #f if n is zero and 1/n otherwise.

   The procedures =, <, >, <=, and >= are called predicates. A predicate is a procedure that answers a specific question
   about its arguments and returns one of the two values #t or #f. The names of most predicates end with a question mark
   ( ? ); the common numeric procedures listed above are exceptions to this rule. Not all predicates require numeric
   arguments, of course. The predicate null? returns true if its argument is the empty list () and false otherwise.

#+begin_src scheme
   (null? '()) ⇒ #t
   (null? 'abc) ⇒ #f
   (null? '(x y z)) ⇒ #f
   (null? (cdddr '(x y z))) ⇒ #t
#+end_src

   The procedure cdr must not be passed anything other than a pair, and an exception is raised when this happens. Common
   Lisp, however, defines (cdr '()) to be (). The following procedure, lisp-cdr, is defined using null? to return () if
   its argument is ().

#+begin_src scheme
   (define lisp-cdr
     (lambda (x)
       (if (null? x)
           '()
           (cdr x))))

   (lisp-cdr '(a b c)) ⇒ (b c)
   (lisp-cdr '(c)) ⇒ ()
   (lisp-cdr '()) ⇒ ()
#+end_src

   Another useful predicate is eqv?, which requires two arguments. If the two arguments are equivalent, eqv? returns
   true. Otherwise, eqv? returns false.

#+begin_src scheme
   (eqv? 'a 'a) ⇒ #t
   (eqv? 'a 'b) ⇒ #f
   (eqv? #f #f) ⇒ #t
   (eqv? #t #t) ⇒ #t
   (eqv? #f #t) ⇒ #f
   (eqv? 3 3) ⇒ #t
   (eqv? 3 2) ⇒ #f
   (let ([x "Hi Mom!"])
     (eqv? x x)) ⇒ #t
   (let ([x (cons 'a 'b)])
     (eqv? x x)) ⇒ #t
   (eqv? (cons 'a 'b) (cons 'a 'b)) ⇒ #f
#+end_src

   As you can see, eqv? returns true if the arguments are the same symbol, boolean, number, pair, or string. Two pairs
   are not the same by eqv? if they are created by different calls to cons, even if they have the same
   contents. Detailed equivalence rules for eqv? are given in Section 6.2.

   Scheme also provides a set of type predicates that return true or false depending on the type of the object, e.g.,
   pair?, symbol?, number?, and string?. The predicate pair?, for example, returns true only if its argument is a pair.

#+begin_src scheme
   (pair? '(a . c)) ⇒ #t
   (pair? '(a b c)) ⇒ #t
   (pair? '()) ⇒ #f
   (pair? 'abc) ⇒ #f
   (pair? "Hi Mom!") ⇒ #f
   (pair? 1234567890) ⇒ #f
#+end_src

   Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
   example, the following version of reciprocal checks first to see that its argument is a number before testing against
   zero or performing the division.

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (if (and (number? n) (not (= n 0)))
           (/ 1 n)
           "oops!")))

   (reciprocal 2/3) ⇒ 3/2
   (reciprocal 'a) ⇒ "oops!"
#+end_src

   By the way, the code that uses reciprocal must check to see that the returned value is a number and not a string. To
   relieve the caller of this obligation, it is usually preferable to report the error, using assertion-violation, as
   follows.

#+begin_src scheme
   (define reciprocal
     (lambda (n)
       (if (and (number? n) (not (= n 0)))
           (/ 1 n)
           (assertion-violation 'reciprocal
             "improper argument"
             n))))

   (reciprocal .25) ⇒ 4.0
   (reciprocal 0) ⇒ exception in reciprocal: improper argument 0
   (reciprocal 'a) ⇒ exception in reciprocal: improper argument a
#+end_src

   The first argument to assertion-violation is a symbol identifying where the message originates, the second is a
   string describing the error, and the third and subsequent arguments are "irritants" to be included with the error
   message.

   Let's look at one more conditional expression, cond, that is often useful in place of if. cond is similar to if
   except that it allows multiple test and alternative expressions. Consider the following definition of sign, which
   returns -1 for negative inputs, +1 for positive inputs, and 0 for zero.

#+begin_src scheme
   (define sign
     (lambda (n)
       (if (< n 0)
           -1
           (if (> n 0)
               +1
               0))))

   (sign -88.3) ⇒ -1
   (sign 0) ⇒ 0
   (sign 333333333333) ⇒ 1
   (* (sign -88.3) (abs -88.3)) ⇒ -88.3
#+end_src

   The two if expressions may be replaced by a single cond expression as follows.

#+begin_src scheme
   (define sign
     (lambda (n)
       (cond
         [(< n 0) -1]
         [(> n 0) +1]
         [else 0])))
#+end_src

   A cond expression usually takes the form

#+begin_src scheme
   (cond (test expr) ... (else expr))
#+end_src

   though the else clause may be omitted. This should be done only when there is no possibility that all the tests will
   fail, as in the new version of sign below.

#+begin_src scheme
   (define sign
     (lambda (n)
       (cond
         [(< n 0) -1]
         [(> n 0) +1]
         [(= n 0) 0])))
#+end_src

   These definitions of sign do not depend on the order in which the tests are performed, since only one of the tests
   can be true for any value of n. The following procedure computes the tax on a given amount of income in a progressive
   tax system with breakpoints at 10,000, 20,000, and 30,000 dollars.

#+begin_src scheme
   (define income-tax
     (lambda (income)
       (cond
         [(<= income 10000) (* income .05)]
         [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
         [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
         [else (+ (* (- income 30000) .21) 2600.00)])))

   (income-tax 5000) ⇒ 250.0
   (income-tax 15000) ⇒ 900.0
   (income-tax 25000) ⇒ 1950.0
   (income-tax 50000) ⇒ 6800.0
#+end_src

   In this example, the order in which the tests are performed, left to right (top to bottom), is significant.

*** Exercise 2.7.1

    Define the predicate atom?, which returns true if its argument is not a pair and false if it is.

*** Exercise 2.7.2

    The procedure length returns the length of its argument, which must be a list. For example, (length '(a b c))
    is 3. Using length, define the procedure shorter, which returns the shorter of two list arguments. Have it return the
    first list if they have the same length.

#+begin_src scheme
    (shorter '(a b) '(c d e)) ⇒ (a b)
    (shorter '(a b) '(c d)) ⇒ (a b)
    (shorter '(a b) '(c)) ⇒ (c)
#+end_src

** Simple Recursion

   We have seen how we can control whether or not expressions are evaluated with if, and, or, and cond. We can also
   perform an expression more than once by creating a procedure containing the expression and invoking the procedure
   more than once. What if we need to perform some expression repeatedly, say for all the elements of a list or all the
   numbers from one to ten? We can do so via recursion. Recursion is a simple concept: the application of a procedure
   from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive
   power far beyond ordinary looping constructs.

   A recursive procedure is a procedure that applies itself. Perhaps the simplest recursive procedure is the following,
   which we will call goodbye.

#+begin_src scheme
   (define goodbye
     (lambda ()
       (goodbye)))

   (goodbye) ⇒
#+end_src

   This procedure takes no arguments and simply applies itself immediately. There is no value after the ⇒
   because goodbye never returns.

   Obviously, to make practical use out of a recursive procedure, we must have some way to terminate the recursion. Most
   recursive procedures should have at least two basic elements, a base case and a recursion step. The base case
   terminates the recursion, giving the value of the procedure for some base argument. The recursion step gives the
   value in terms of the value of the procedure applied to a different argument. In order for the recursion to
   terminate, the different argument must be closer to the base argument in some way.

   Let's consider the problem of finding the length of a proper list recursively. We need a base case and a recursion
   step. The logical base argument for recursion on lists is nearly always the empty list. The length of the empty list
   is zero, so the base case should give the value zero for the empty list. In order to become closer to the empty list,
   the natural recursion step involves the cdr of the argument. A nonempty list is one element longer than its cdr, so
   the recursion step gives the value as one more than the length of the cdr of the list.

#+begin_src scheme
   (define length
     (lambda (ls)
       (if (null? ls)
           0
           (+ (length (cdr ls)) 1))))

   (length '()) ⇒ 0
   (length '(a)) ⇒ 1
   (length '(a b)) ⇒ 2
#+end_src

   The if expression asks if the list is empty. If so, the value is zero. This is the base case. If not, the value is
   one more than the length of the cdr of the list. This is the recursion step.

   Many Scheme implementations allow you to trace the execution of a procedure to see how it operates. In Chez Scheme,
   for example, one way to trace a procedure is to type (trace name), where name is the name of a procedure you have
   defined at top level. If you trace length as defined above and pass it the argument '(a b c d), you should see
   something like this:

#+BEGIN_EXAMPLE
   |(length (a b c d))
   | (length (b c d))
   | |(length (c d))
   | | (length (d))
   | | |(length ())
   | | |0
   | | 1
   | |2
   | 3
   |4
#+END_EXAMPLE

   The indentation shows the nesting level of the recursion; the vertical lines associate applications visually with
   their values. Notice that on each application of length the list gets smaller until it finally reaches (). The value
   at () is 0, and each outer level adds 1 to arrive at the final value.

   Let's write a procedure, list-copy, that returns a copy of its argument, which must be a list. That is, list-copy
   returns a new list consisting of the elements (but not the pairs) of the old list. Making a copy might be useful if
   either the original list or the copy might be altered via set-car! or set-cdr!, which we discuss later.

#+begin_src scheme
   (list-copy '()) ⇒ ()
   (list-copy '(a b c)) ⇒ (a b c)
#+end_src

   See if you can define list-copy before studying the definition below.

#+begin_src scheme
   (define list-copy
     (lambda (ls)
       (if (null? ls)
           '()
           (cons (car ls)
                 (list-copy (cdr ls))))))
#+end_src

   The definition of list-copy is similar to the definition of length. The test in the base case is the same, (null?
   ls). The value in the base case is (), however, not 0, because we are building up a list, not a number. The recursive
   call is the same, but instead of adding one, list-copy conses the car of the list onto the value of the recursive
   call.

   There is no reason why there cannot be more than one base case. The procedure memv takes two arguments, an object and
   a list. It returns the first sublist, or tail, of the list whose car is equal to the object, or #f if the object is
   not found in the list. The value of memv may be used as a list or as a truth value in a conditional expression.

#+begin_src scheme
   (define memv
     (lambda (x ls)
       (cond
         [(null? ls) #f]
         [(eqv? (car ls) x) ls]
         [else (memv x (cdr ls))])))

   (memv 'a '(a b b d)) ⇒ (a b b d)
   (memv 'b '(a b b d)) ⇒ (b b d)
   (memv 'c '(a b b d)) ⇒ #f
   (memv 'd '(a b b d)) ⇒ (d)
   (if (memv 'b '(a b b d))
       "yes"
       "no") ⇒ "yes"
#+end_src

   Here there are two conditions to check, hence the use of cond. The first cond clause checks for the base value of ();
   no object is a member of (), so the answer is #f. The second clause asks if the car of the list is the object, in
   which case the list is returned, being the first tail whose car contains the object. The recursion step just
   continues down the list.

   There may also be more than one recursion case. Like memv, the procedure remv defined below takes two arguments, an
   object and a list. It returns a new list with all occurrences of the object removed from the list.

#+begin_src scheme
   (define remv
     (lambda (x ls)
       (cond
         [(null? ls) '()]
         [(eqv? (car ls) x) (remv x (cdr ls))]
         [else (cons (car ls) (remv x (cdr ls)))])))

   (remv 'a '(a b b d)) ⇒ (b b d)
   (remv 'b '(a b b d)) ⇒ (a d)
   (remv 'c '(a b b d)) ⇒ (a b b d)
   (remv 'd '(a b b d)) ⇒ (a b b)
#+end_src

   This definition is similar to the definition of memv above, except remv does not quit once it finds the element in
   the car of the list. Rather, it continues, simply ignoring the element. If the element is not found in the car of the
   list, remv does the same thing as list-copy above: it conses the car of the list onto the recursive value.

   Up to now, the recursion has been only on the cdr of a list. It is sometimes useful, however, for a procedure to
   recur on the car as well as the cdr of the list. The procedure tree-copy defined below treats the structure of pairs
   as a tree rather than as a list, with the left subtree being the car of the pair and the right subtree being the cdr
   of the pair. It performs a similar operation to list-copy, building new pairs while leaving the elements (leaves)
   alone.

#+begin_src scheme
   (define tree-copy
     (lambda (tr)
       (if (not (pair? tr))
           tr
           (cons (tree-copy (car tr))
                 (tree-copy (cdr tr))))))

   (tree-copy '((a . b) . c)) ⇒ ((a . b) . c)
#+end_src

   The natural base argument for a tree structure is anything that is not a pair, since the recursion traverses pairs
   rather than lists. The recursive step in this case is doubly recursive, finding the value recursively for the car as
   well as the cdr of the argument.

   At this point, readers who are familiar with other languages that provide special iteration constructs, e.g., while
   or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary;
   iteration in Scheme is expressed more clearly and succinctly via recursion. Recursion is more general and eliminates
   the need for the variable assignments required by many other languages' iteration constructs, resulting in code that
   is more reliable and easier to follow. Some recursion is essentially iteration and executes as such; Section 3.2 has
   more to say about this. Often, there is no need to make a distinction, however. Concentrate instead on writing clear,
   concise, and correct programs.

   Before we leave the topic of recursion, let's consider a special form of repetition called mapping. Consider the
   following procedure, abs-all, that takes a list of numbers as input and returns a list of their absolute values.

#+begin_src scheme
   (define abs-all
     (lambda (ls)
       (if (null? ls)
           '()
           (cons (abs (car ls))
                 (abs-all (cdr ls))))))

   (abs-all '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

   This procedure forms a new list from the input list by applying the procedure abs to each element. We say that
   abs-all maps abs over the input list to produce the output list. Mapping a procedure over a list is a fairly common
   thing to do, so Scheme provides the procedure map, which maps its first argument, a procedure, over its second, a
   list. We can use map to define abs-all.

#+begin_src scheme
   (define abs-all
     (lambda (ls)
       (map abs ls)))
#+end_src

   We really do not need abs-all, however, since the corresponding direct application of map is just as short and
   perhaps clearer.

#+begin_src scheme
   (map abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

   Of course, we can use lambda to create the procedure argument to map, e.g., to square the elements of a list of
   numbers.

#+begin_src scheme
   (map (lambda (x) (* x x))
        '(1 -3 -5 7)) ⇒ (1 9 25 49)
#+end_src

   We can map a multiple-argument procedure over multiple lists, as in the following example.

#+begin_src scheme
   (map cons '(a b c) '(1 2 3)) ⇒ ((a . 1) (b . 2) (c . 3))
#+end_src

   The lists must be of the same length, and the procedure should accept as many arguments as there are lists. Each
   element of the output list is the result of applying the procedure to corresponding members of the input list.

   Looking at the first definition of abs-all above, you should be able to derive, before studying it, the following
   definition of map1, a restricted version of map that maps a one-argument procedure over a single list.

#+begin_src scheme
   (define map1
     (lambda (p ls)
       (if (null? ls)
           '()
           (cons (p (car ls))
                 (map1 p (cdr ls))))))

   (map1 abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

   All we have done is to replace the call to abs in abs-all with a call to the new parameter p. A definition of the
   more general map is given in Section 5.4.

*** Exercise 2.8.1

    Describe what would happen if you switched the order of the arguments to cons in the definition of tree-copy.

*** Exercise 2.8.2

    Consult Section 6.3 for the description of append and define a two-argument version of it. What would happen if you
    switched the order of the arguments in the call to append within your definition of append?

*** Exercise 2.8.3

    Define the procedure make-list, which takes a nonnegative integer n and an object and returns a new list, n long,
    each element of which is the object.

#+begin_src scheme
    (make-list 7 '()) ⇒ (() () () () () () ())
#+end_src

    [Hint: The base test should be (= n 0), and the recursion step should involve (- n 1). Whereas () is the natural base
    case for recursion on lists, 0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
    1 is the natural way to bring a nonnegative integer closer to 0.]

*** Exercise 2.8.4

    The procedures list-ref and list-tail return the nth element and nth tail of a list ls.

#+begin_src scheme
    (list-ref '(1 2 3 4) 0) ⇒ 1
    (list-tail '(1 2 3 4) 0) ⇒ (1 2 3 4)
    (list-ref '(a short (nested) list) 2) ⇒ (nested)
    (list-tail '(a short (nested) list) 2) ⇒ ((nested) list)
#+end_src

    Define both procedures.

*** Exercise 2.8.5

    Exercise 2.7.2 had you use length in the definition of shorter, which returns the shorter of its two list arguments,
    or the first if the two have the same length. Write shorter without using length. [Hint: Define a recursive helper,
    shorter?, and use it in place of the length comparison.]

*** Exercise 2.8.6

    All of the recursive procedures shown so far have been directly recursive. That is, each procedure directly applies
    itself to a new argument. It is also possible to write two procedures that use each other, resulting in indirect
    recursion. Define the procedures odd? and even?, each in terms of the other. [Hint: What should each return when its
    argument is 0?]

#+begin_src scheme
    (even? 17) ⇒ #f
    (odd? 17) ⇒ #t
#+end_src

*** Exercise 2.8.7

    Use map to define a procedure, transpose, that takes a list of pairs and returns a pair of lists as follows.

#+begin_src scheme
    (transpose '((a . 1) (b . 2) (c . 3))) ⇒ ((a b c) 1 2 3)
#+end_src

    [Hint: ((a b c) 1 2 3) is the same as ((a b c) . (1 2 3)).]

** Assignment

   Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound
   variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the
   values of existing bindings. Assignments are performed with set!.

#+begin_src scheme
   (define abcde '(a b c d e))
   abcde ⇒ (a b c d e)
   (set! abcde (cdr abcde))
   abcde ⇒ (b c d e)
   (let ([abcde '(a b c d e)])
     (set! abcde (reverse abcde))
     abcde) ⇒ (e d c b a)
#+end_src

   Many languages require the use of assignments to initialize local variables, separate from the declaration or binding
   of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the
   separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to
   initialize them, a common source of errors in most languages.

   In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and
   inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One
   common practice in some languages is to sequence expression evaluation with a series of assignments, as in the
   following procedure that finds the roots of a quadratic equation.

#+begin_src scheme
   (define quadratic-formula
     (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
         (set! minusb (- 0 b))
         (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
         (set! divisor (* 2 a))
         (set! root1 (/ (+ minusb radical) divisor))
         (set! root2 (/ (- minusb radical) divisor))
         (cons root1 root2))))
#+end_src

   The roots are computed according to the well-known quadratic formula,

[[./images/4.gif]]

   which yields the solutions to the equation 0 = ax2 + bx + c. The let expression in this definition is employed solely
   to establish the variable bindings, corresponding to the declarations required in other languages. The first three
   assignment expressions compute subpieces of the formula, namely -b, [[./images/5.gif]] , and 2a. The last two assignment
   expressions compute the two roots in terms of the subpieces. A pair of the two roots is the value of
   quadratic-formula. For example, the two roots of 2x2 - 4x - 6 are x = 3 and x = -1.

#+begin_src scheme
   (quadratic-formula 2 -4 -6) ⇒ (3 . -1)
#+end_src

   The definition above works, but it can be written more clearly without the assignments, as shown below.

#+begin_src scheme
   (define quadratic-formula
     (lambda (a b c)
       (let ([minusb (- 0 b)]
             [radical (sqrt (- (* b b) (* 4 (* a c))))]
             [divisor (* 2 a)])
         (let ([root1 (/ (+ minusb radical) divisor)]
               [root2 (/ (- minusb radical) divisor)])
           (cons root1 root2)))))
#+end_src

   In this version, the set! expressions are gone, and we are left with essentially the same algorithm. By employing two
   let expressions, however, the definition makes clear the dependency of root1 and root2 on the values of minusb,
   radical, and divisor. Equally important, the let expressions make clear the lack of dependencies among minusb,
   radical, and divisor and between root1 and root2.

   Assignments do have some uses in Scheme, otherwise the language would not support them. Consider the following
   version of cons that counts the number of times it is called, storing the count in a variable named cons-count. It
   uses set! to increment the count; there is no way to achieve the same behavior without assignments.

#+begin_src scheme
   (define kons-count 0)
   (define kons
     (lambda (x y)
       (set! kons-count (+ kons-count 1))
       (cons x y)))
#+end_src

#+begin_src scheme
   (kons 'a '(b c)) ⇒ (a b c)
   kons-count ⇒ 1
   (kons 'a (kons 'b (kons 'c '()))) ⇒ (a b c)
   kons-count ⇒ 4
#+end_src

   Assignments are commonly used to implement procedures that must maintain some internal state. For example, suppose we
   would like to define a procedure that returns 0 the first time it is called, 1 the second time, 2 the third time, and
   so on indefinitely. We could write something similar to the definition of cons-count above:

#+begin_src scheme
   (define next 0)
   (define count
     (lambda ()
       (let ([v next])
         (set! next (+ next 1))
         v)))

   (count) ⇒ 0
   (count) ⇒ 1
#+end_src

   This solution is somewhat undesirable in that the variable next is visible at top level even though it need not
   be. Since it is visible at top level, any code in the system can change its value, perhaps inadvertently affecting
   the behavior of count in a subtle way. We can solve this problem by let-binding next outside of the lambda
   expression:

#+begin_src scheme
   (define count
     (let ([next 0])
       (lambda ()
         (let ([v next])
           (set! next (+ next 1))
           v))))
#+end_src

   The latter solution also generalizes easily to provide multiple counters, each with its own local counter. The
   procedure make-counter, defined below, returns a new counting procedure each time it is called.

#+begin_src scheme
   (define make-counter
     (lambda ()
       (let ([next 0])
         (lambda ()
           (let ([v next])
             (set! next (+ next 1))
             v)))))
#+end_src

   Since next is bound inside of make-counter but outside of the procedure returned by make-counter, each procedure it
   returns maintains its own unique counter.

#+begin_src scheme
   (define count1 (make-counter))
   (define count2 (make-counter))

   (count1) ⇒ 0
   (count2) ⇒ 0
   (count1) ⇒ 1
   (count1) ⇒ 2
   (count2) ⇒ 1
#+end_src

   If a state variable must be shared by more than one procedure defined at top level, but we do not want the state
   variable to be visible at top level, we can use let to bind the variable and set! to make the procedures visible at
   top level.

#+begin_src scheme
   (define shhh #f)
   (define tell #f)
   (let ([secret 0])
     (set! shhh
       (lambda (message)
         (set! secret message)))
     (set! tell
       (lambda ()
         secret)))

   (shhh "sally likes harry")
   (tell) ⇒ "sally likes harry"
   secret ⇒ exception: variable secret is not bound
#+end_src

   Variables must be defined before they can be assigned, so we define shhh and tell to be #f initially. (Any initial
   value would do.) We'll see this structure again in Section 3.5 and a better way to structure code like this as a
   library in Section 3.6.

   Local state is sometimes useful for caching computed values or allowing a computation to be evaluated lazily, i.e.,
   only once and only on demand. The procedure lazy below accepts a thunk, or zero-argument procedure, as an
   argument. Thunks are often used to "freeze" computations that must be delayed for some reason, which is exactly what
   we need to do in this situation. When passed a thunk t, lazy returns a new thunk that, when invoked, returns the
   value of invoking t. Once computed, the value is saved in a local variable so that the computation need not be
   performed again. A boolean flag is used to record whether t has been invoked and its value saved.

#+begin_src scheme
   (define lazy
     (lambda (t)
       (let ([val #f] [flag #f])
         (lambda ()
           (if (not flag)
               (begin (set! val (t))
                      (set! flag #t)))
           val))))
#+end_src

   The syntactic form begin, used here for the first time, evaluates its subexpressions in sequence from left to right
   and returns the value of the last subexpression, like the body of a let or lambda expression. We also see that the
   alternative subexpression of an if expression can be omitted. This should be done only when the value of the if is
   discarded, as it is in this case.

   Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the
   evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than
   once.

   The operation of lazy can best be illustrated by printing a message from within a thunk passed to lazy.

#+begin_src scheme
   (define p
     (lazy (lambda ()
             (display "Ouch!")
             (newline)
             "got me")))
#+end_src

   The first time p is invoked, the message Ouch! is printed and the string "got me" is returned. Thereafter, "got me"
   is returned but the message is not printed. The procedures display and newline are the first examples of explicit
   input/output we have seen; display prints the string without quotation marks, and newline prints a newline
   character.

   To further illustrate the use of set!, let's consider the implementation of stack objects whose internal workings are
   not visible on the outside. A stack object accepts one of four messages: empty?, which returns #t if the stack is
   empty; push!, which adds an object to the top of the stack; top, which returns the object on the top of the stack;
   and pop!, which removes the object on top of the stack. The procedure make-stack given below creates a new stack each
   time it is called in a manner similar to make-counter.

#+begin_src scheme
   (define make-stack
     (lambda ()
       (let ([ls '()])
         (lambda (msg . args)
           (cond
             [(eqv? msg 'empty?) (null? ls)]
             [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
             [(eqv? msg 'top) (car ls)]
             [(eqv? msg 'pop!) (set! ls (cdr ls))]
             [else "oops"])))))
#+end_src

   Each stack is stored as a list bound to the variable ls; set! is used to change this binding for push! and
   pop!. Notice that the argument list of the inner lambda expression uses the improper list syntax to bind args to a
   list of all arguments but the first. This is useful here because in the case of empty?, top, and pop! there is only
   one argument (the message), but in the case of push! there are two (the message and the object to push onto the
   stack).

#+begin_src scheme
   (define stack1 (make-stack))
   (define stack2 (make-stack))
   (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #t)

   (stack1 'push! 'a)
   (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #t)

   (stack1 'push! 'b)
   (stack2 'push! 'c)
   (stack1 'top) ⇒ b
   (stack2 'top) ⇒ c

   (stack1 'pop!)
   (stack1 'top) ⇒ a
   (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #f)

   (stack1 'pop!)
   (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #f)
#+end_src

   As with the counters created by make-counter, the state maintained by each stack object is directly accessible only
   within the object. Each reference or change to this state is made explicitly by the object itself. One important
   benefit is that we can change the internal structure of the stack, perhaps to use a vector (see Section 6.9) instead
   of a list to hold the elements, without changing its external behavior. Because the behavior of the object is known
   abstractly (not operationally), it is known as an abstract object. See Section 12.8 for more about creating abstract
   objects.

   In addition to changing the values of variables, we can also change the values of the car and cdr fields of a pair,
   using the procedures set-car! and set-cdr!.

#+begin_src scheme
   (define p (list 1 2 3))
   (set-car! (cdr p) 'two)
   p ⇒ (1 two 3)
   (set-cdr! p '())
   p ⇒ (1)
#+end_src

   We can use these operators to define a queue data type, which is like a stack except that new elements are added at
   one end and extracted from the other. The following queue implementation uses a tconc structure. A tconc consists of
   a nonempty list and a header. The header is a pair whose car points to the first pair (head) of the list and whose
   cdr points to the last pair (end) of the list.

[[./images/6.gif]]

   The last element of the list is a placeholder and not considered part of the queue.

   Four operations on queues are defined below: make-queue, which constructs a queue; putq!, which adds an element to
   the end of a queue; getq, which retrieves the element at the front of a queue; and delq!, which removes the element
   at the front of a queue.

#+begin_src scheme
   (define make-queue
     (lambda ()
       (let ([end (cons 'ignored '())])
         (cons end end))))

   (define putq!
     (lambda (q v)
       (let ([end (cons 'ignored '())])
         (set-car! (cdr q) v)
         (set-cdr! (cdr q) end)
         (set-cdr! q end))))

   (define getq
     (lambda (q)
       (car (car q))))

   (define delq!
     (lambda (q)
       (set-car! q (cdr (car q)))))
#+end_src

   All are simple operations except for putq!, which modifies the end pair to contain the new value and adds a new end
   pair.

#+begin_src scheme
   (define myq (make-queue))

   (putq! myq 'a)
   (putq! myq 'b)
   (getq myq) ⇒ a
   (delq! myq)
   (getq myq) ⇒ b
   (delq! myq)
   (putq! myq 'c)
   (putq! myq 'd)
   (getq myq) ⇒ c
   (delq! myq)
   (getq myq) ⇒ d
#+end_src

*** Exercise 2.9.1

    Modify make-counter to take two arguments: an initial value for the counter to use in place of 0 and an amount to
    increment the counter by each time.

*** Exercise 2.9.2

    Look up the description of case in Section 5.3. Replace the cond expression in make-stack with an equivalent case
    expression. Add mt? as a second name for the empty? message.

*** Exercise 2.9.3

    Modify the stack object to allow the two messages ref and set!. (stack 'ref i) should return the ith element from the
    top of the stack; (stack 'ref 0) should be equivalent to (stack 'top). (stack 'set! i v) should change the ith
    element from the top of the stack to v.

#+begin_src scheme
    (define stack (make-stack))

    (stack 'push! 'a)
    (stack 'push! 'b)
    (stack 'push! 'c)

    (stack 'ref 0) ⇒ c
    (stack 'ref 2) ⇒ a
    (stack 'set! 1 'd)
    (stack 'ref 1) ⇒ d
    (stack 'top) ⇒ c
    (stack 'pop!)
    (stack 'top) ⇒ d
#+end_src

    [Hint: Use list-ref to implement ref and list-tail with set-car! to implement set!.]

*** Exercise 2.9.4

    Scheme supports vectors as well as lists. Like lists, vectors are aggregate objects that contain other
    objects. Unlike lists, vectors have a fixed size and are laid out in one flat block of memory, typically with a
    header containing the length of the vector, as in the ten-element vector below.

[[./images/7.gif]]

    This makes vectors more suitable for applications needing fast access to any element of the aggregate but less
    suitable for applications needing data structures that grow and shrink as needed.

    Look up the basic vector operations in Section 6.9 and reimplement the stack object to use a vector instead of a list
    to hold the stack contents. Include the ref and set! messages of Exercise 2.9.3. Have the new make-stack accept a
    size argument n and make the vector length n, but do not otherwise change the external (abstract) interface.

*** Exercise 2.9.5

    Define a predicate, emptyq?, for determining if a queue is empty. Modify getq and delq! to raise an exception when an
    empty queue is found, using assertion-violation.

*** Exercise 2.9.6

    In the queue implementation, the last pair in the encapsulated list is a placeholder, i.e., it never holds anything
    useful. Recode the queue operators to avoid this wasted pair. Make sure that the series of queue operations given
    earlier works with the new implementation. Which implementation do you prefer?

*** Exercise 2.9.7

    Using set-cdr!, it is possible to create cyclic lists. For example, the following expression evaluates to a list
    whose car is the symbol a and whose cdr is the list itself.

#+begin_src scheme
    (let ([ls (cons 'a '())])
      (set-cdr! ls ls)
      ls)
#+end_src

    What happens when you enter the above expression during an interactive Scheme session? What will the implementation
    of length on page 42 do when given a cyclic list? What does the built-in length primitive do?

*** Exercise 2.9.8

    Define the predicate list?, which returns #t if its argument is a proper list and #f otherwise (see Section 6.3). It
    should return #f for cyclic lists as well as for lists terminated by objects other than ().

#+begin_src scheme
    (list? '()) ⇒ #t
    (list? '(1 2 3)) ⇒ #t
    (list? '(a . b)) ⇒ #f
    (list? (let ([ls (cons 'a '())])
             (set-cdr! ls ls)
             ls)) ⇒ #f
#+end_src

    First write a simplified version of list? that does not handle cyclic lists, then extend this to handle cyclic lists
    correctly. Revise your definition until you are satisfied that it is as clear and concise as possible. [Hint: Use the
    following "hare and tortoise" algorithm to detect cycles. Define a recursive help procedure of two arguments, the
    hare and the tortoise. Start both the hare and the tortoise at the beginning of the list. Have the hare advance by
    two cdrs each time the tortoise advances by one cdr. If the hare catches the tortoise, there must be a cycle.]
