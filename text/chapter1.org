* Введение.

  Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
  типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
  данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
  имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
  языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
  графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
  реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
  изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
  природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
  полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.

  Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
  Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
  между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
  "Revised Reports" для Scheme. Последний, "Revised6 Report" [fn:24], акцентирует внимание на переносимости, вводя ряд
  стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.

  Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
  реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
  языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
  проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
  информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.

  Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
  и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.

  Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
  пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
  от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
  списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
  освобождения памяти.

  Независимо от представления, /все/ данные являются объектами первого класса. Все они хранятся независимо и могут
  свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
  образования новых объектов.

  Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
  выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
  остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.

  Scheme относится к языкам с /вызовом-по-значению/ , но для, по меньшей мере,  мутабельных объектов (объекты, которые
  могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
  сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
  что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
  процедуры.

  В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
  ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
  составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
  надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
  реализацию и увеличивая надёжность.

  Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
  любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
  переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
  формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
  предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
  процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
  Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.

  В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
  Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
  кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
  т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
  пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
  блоке могут /затенять/ связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
  котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
  лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
  поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
  компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
  с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
  определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
  пока программа не выполнится.

  В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
  локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена пределах
  другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет конца блока.
  В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может быть
  произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже когда
  внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо самого
  кодом, хранит в себе лексический контекст (окружение).

  Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
  такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
  другим объектом.

  Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
  процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
  становятся элегантнее или эффективнее. Особый вид рекурсии, называемый ~хвостовая рекурсия~ , используется для
  выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
  другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
  самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
  (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
  Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
  обычным набором итерационных конструкций.

  Scheme поддерживает определение произвольных управляющих структур с помощью /продолжений/ . /Продолжение/ , это
  процедура, которая заключает в себе остальную часть программы в заданной точке. /Продолжение/ может быть получено в
  любой момент во время выполнения программы. Так же, как и с другими процедурами, /продолжение/ является объектом
  первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
  продолжает выполнение с той точки, где это /продолжение/ было создано. /Продолжения/ позволяют реализовать сложные
  механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.

  Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
  написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
  существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
  высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
  реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
  процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
  выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
  языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
  выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
  синтаксических выражений и объявлений процедур.

  Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
  объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
  многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
  60 [fn:21]. Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
  структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
  лексической областью действия.

  Common Lisp [fn:27] и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
  другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
  процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
  с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
  объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
  объектов первого класса. И хотя Common Lisp не поддерживает /продолжения/ или требует правильного обращения с
  хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
  похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
  универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).

  Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
  используемых в этой книге.

** Section 1.1. Scheme Syntax
** Section 1.2. Scheme Naming Conventions
** Section 1.3. Typographical and Notational Conventions
