;;; -*- coding: utf-8; tab-width: 4; c-basic-offset: 2; indent-tabs-mode: nil; fill-column: 120; -*-
(chapter :title [Введение]
   (chapter-image "images/ch1.png")
   (p [Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
       типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
       данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
       имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
       языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
       графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
       реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
       изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
       природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
       полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.])

   (p [Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
       Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
       между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
       'Revised Reports' для Scheme. Последний, 'Revised6 Report' ,(ref :bib 'b24), акцентирует внимание на переносимости, вводя ряд
       стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.])

   (p [Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
       реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
       языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
       проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
       информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.])

   (p [Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
       и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.])

   (p [Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
       пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
       от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
       списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
       освобождения памяти.])

   (p [Независимо от представления, ,(it [все]) данные являются объектами первого класса. Все они хранятся независимо и могут
       свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
       образования новых объектов.])

   (p [Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
       выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
       остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.])

   (p [Scheme относится к языкам с ,(it [вызовом-по-значению]), но для, по меньшей мере,  мутабельных объектов (объекты, которые
       могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
       сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
       что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
       процедуры.])

   (p [В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
       ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
       составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
       надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
       реализацию и увеличивая надёжность.])

   (p [Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
       любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
       переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
       формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
       предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
       процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
       Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.])

   (p [В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
       Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
       кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
       т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
       пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
       блоке могут ,(it [затенять]) связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
       котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
       лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
       поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
       компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
       с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
       определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
       пока программа не выполнится.])

   (p [В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
       локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена в
       пределах другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет
       конца блока. В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может
       быть произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже
       когда внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо
       самого кода, хранит в себе лексический контекст (окружение).])

   (p [Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
       такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
       другим объектом.])

   (p [Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
       процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
       становятся элегантнее или эффективнее. Особый вид рекурсии, называемый ,(it [хвостовая рекурсия]), используется для
       выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
       другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
       самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
       (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
       Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
       обычным набором итерационных конструкций.])

   (p [Scheme поддерживает определение произвольных управляющих структур с помощью ,(it [продолжений]). ,(it [Продолжение]), это
       процедура, которая заключает в себе остальную часть программы в заданной точке. ,(it [Продолжение]) может быть получено в
       любой момент во время выполнения программы. Так же, как и с другими процедурами, ,(it [продолжение]) является объектом
       первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
       продолжает выполнение с той точки, где это ,(it "продолжение") было создано. ,(it "Продолжения") позволяют реализовать сложные
       механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.])

   (p [Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
       написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
       существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
       высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
       реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
       процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
       выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
       языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
       выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
       синтаксических выражений и объявлений процедур.])

   (p [Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
       объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
       многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
       60 ,(ref :bib 'b21). Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
       структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
       лексической областью действия.])
   (p [Common Lisp ,(ref :bib 'b27) и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
       другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
       процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
       с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
       объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
       объектов первого класса. И хотя Common Lisp не поддерживает ,(it "продолжения") или требует правильного обращения с
       хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
       похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
       универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).])

   (p [Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
       используемых в этой книге.])

   (section :title [Синтаксис]
      (p [Программы на Scheme состоят из ключевых слов, переменных, структурирующих форм, константных данных (числа, буквы,
         строки, цитируемые векторы, цитируемые списки, цитируемые символы и т.д.), пробелов и комментариев.])

      (p [Ключевые слова, переменные и символы собирательно именуются идентификаторами. Идентификаторы могут быть образованы из
         букв, чисел и некоторых специальных символов, включающих ,(var "?"), ,(var "!"), ,(var "."), ,(var "+"), ,(var "-"), ,(var "*"), ,(var "/"), ,(var "<"), ,(var "="), ,(var ">"), ,(var ":"), ,(var "$"),
         ,(var "%"), ,(var "^"), ,(var "&"), ,(var "_"), ,(var "~"), и ,(var "@"), так же ряда дополнительных символов из Unicode. Идентификаторы не могут начинаться со
         знака @, а так же со знаков, с которых может начинаться число, таких как ,(var "+"), ,(var "-"), ,(var "."), исключение ,(var "-") знаки ,(var "+"), ,(var "-")
         и некоторые другие, которые могут быть идентификаторами сами по себе, а так же идентификаторы, начинающиеся с
         ,(var "->"). Например, ,(var "hi"), ,(var "Hello"), ,(var "n"), ,(var "x"), ,(var "x3"), ,(var "x+2"), и ,(var "?$&*!!!") - корректные идентификаторы. Идентификаторы
         отделяются пробелами, комментарием, скобками, фигурными скобками, двойными кавычками и знаком решётки. Разделитель,
         или любая другая буква Unicode, могут быть включены в любое место в имени идентификатора путём экранирования в виде
         ,(var "\\xsv"), где sv - скалярное значение символа в шестнадцатеричном представлении.])

      (p [На длину идентификаторов не накладывается никаких ограничений, программист использовать столько символов в имени,
         сколько посчитает нужным. Однако, длинные идентификаторы не заменят комментариев, в то же время, их частое
         использование может сделать код трудным для форматирования и чтения. Хорошее правило, это использовать короткие имена
         идентификаторов в тех случаях, когда область видимости идентификатора мала, и длинные тогда, когда область видимости
         велика.])

      (p [Идентификаторы могут содержать любую комбинацию символов верхнего или нижнего регистров, регистр учитывается т.е. два
         идентификатора считаются различными, даже если они отличаются только регистром. Например, ,(var "abcde"), ,(var "Abcde"), ,(var "AbCdE") и
         ,(var "ABCDE") - все различные идентификаторы. Это нововведение, по сравнению с предыдущими отчётами по стандарту языка.])

      (p [Структурированные формы и списки констант заключаются в скобки, например ,(var "(a b c)") или ,(var "(* (- x 2) y)"). Пустой список
         записывается как ,(var "()"). Другие парные наборы скобок, такие как ,(var "[") ,(var "]"), могут быть использованы вместо круглых скобок
         и часто используются для выделения подвыражений определенных стандартных синтаксических форм для удобочитаемости, как
         в примерах в этой книге. Векторы записываются таким же образом, как и списки, за исключением того, что они начинаются
         с ,(var "#(") и заканчиваются ,(var ")"), например ,(var "#(это вектор содержащий символы)"). Байт-векторы записываются как
         последовательность беззнаковых байтов (обычные целочисленные значения в диапазоне от 0 до 255), заключенных в ,(var "#vu8(")
         и ,(var ")"), например ,(var "#vu8(3 250 45 73)").])

      (p [Строки заключаются в двойные кавычки, например ,(var "\"Это строка\""). Буквы предваряются ,(var "#\\"), например ,(var "#\\a"). Когда речь
         идёт о строках или буквах - регистр имеет значение, так же как и в случае с идентификаторами. Числа могут быть
         записаны в виде целочисленного значения (integer), например ,(var "-123"), рационального числа, например ,(var "1/2"), числа с
         плавающей точкой или в научной форме, например ,(var "1.3") или ,(var "1e23"), как комплексное число, в прямоугольной или полярной
         системах координат например ,(var "1.3-2.7i") или ,(var "-1.2@73"). В случае чисел регистр не имеет значения. Булевы значения,
         представляющие ложь и истину, обозначаются ,(var "#f") и ,(var "#t") соответственно. В Scheme, условные выражения обычно считают
         ,(var "#f") ложью, а любой другой объект истиной, так что ,(var "3"), ,(var "0"), ,(var "()"), ,(var "\"false\"") или ,(var "nil") - всё это считается истиной.])

      (p [Детальное описание синтаксиса каждого константного типа данных дано в отдельной секции в главе 6 и в формальном
         описании синтаксиса, приведённом в конце книги.])

      (p [Выражения в Scheme могут занимать несколько строк, для этого не требуются специальные терминирующие
         символы. Учитывая, что количество пробельных символов и переводов строки между выражениями не имеет синтаксического
         значения, эту возможность следует использовать, чтобы программы на Scheme были выровнены таким образом, чтобы
         правильно отображать структуру кода и делать его настолько читаемым, насколько это возможно. Комментарии могут быть
         размещены в каждой строке программы, между символом ,(var ";") и концом строки. Комментарий, поясняющий конкретное выражение
         Scheme, обычно размещается в предыдущей строке, с тем же уровнем отступа. Комментарии, поясняющие процедуру или
         группу процедур, обычно размещаются перед процедурой, без отступа.])

      (p [Так же поддерживаются следующие два вида комментариев: блочные и комментарии по данным (datum). Блочные комментарии
         обосабливаются парой ,(var "#|") и ,(var "|"), и могут быть вложенными. Комментарии данных начинаются с префикса ,(var "#;") , за которым
         следует печатная версия объекта данных. Комментарии по данным обычно используются, чтобы закомментировать конкретное
         объявление или выражение. Например, ,(var "(список из трёх #;(а не четырёх) элементов)"). Комментарии по данным могут так же
         быть вложенными, например ,(var "#;#;(a)(b)"), но это не имеет какого то особого значения, в сравнении, если бы
         комментировался каждый элемент по отдельности.])

      (p [Некоторые значения в Scheme, такие как процедуры или порты, не имеют стандартизированного печатного представления и
         по этому не могут быть представлены константой при печати. В этой книге используется обозначение ,(var "#<пояснение>"),
         когда мы хотим оказать возвращаемый результат какой либо операции, возвращающей одно из таких значений, например
         ,(var "#<procedure>") или ,(var "#<port>").]))

   (section :title [Соглашения в именовании]
      (p [Соглашения по именованию, принятые в Scheme, разработаны так, чтобы обеспечивать высокий уровень системности и
          регулярности. Ниже приведён список таких соглашений:])

      (itemize
         (item
            [Имена предикатов заканчиваются символом вопроса (?). Предикаты, это процедуры, возвращающие истину или ложь, такие
            как ,(var "eq?"), ,(var "zero?") и ,(var "string=?"). Обычные для чисел операции сравнения, такие как ,(var "="), ,(var "<"), ,(var ">"), ,(var "<="), и ,(var ">=")
            являются исключением из правил.])
         (item
            [Предикаты типов, например ,(var "pair?"), составляются из имени типа, в данном случае ,(it "pair") и знака вопроса.])
         (item
            [Имена большинства процедур предикатов для букв, строк и векторов начинаются с префикса ,(var "char-"), ,(var "string-"),
            ,(var "vector-"), например ,(var "string-append"). (Имена некоторых процедур для списков начинаются с ,(var "list-"), но большинство
            нет)])
         (item
            [Имена процедур, которые преобразуют объект одного типа в объект другого типа, записываются как ,(var "type1->type2"),
            например ,(var "vector->list").])
         (item
            [Имена процедур и синтаксических форм, производящих побочные эффекты, оканчиваются знаком восклицательного знака
            (,(var "!")). Например ,(var "set!") и ,(var "vector-set!"). Процедуры, производящие операции ввода-вывода, формально так же считаются
            процедурами с побочными эффектами, однако они попадают под исключение из правил.])
         (item
            [Программистам следует следовать этим соглашениям по именованию там, где это возможно.])))

   (section :title [Типографические и нотационные соглашения]
      (p [Про стандартные процедуры или синтаксические формы, единственная цель которых выполнение побочных эффектов, сказано,
          что возвращаемый ими результат не определён. Это значит, что конкретная реализация свободна возвращать любое
          количество значений, каждое из которых может быть любым объектом Scheme. Не рассчитывайте на то, что эти возвращаемые
          значения одинаковы для всех реализаций, одинаковые для версий одной и той же реализации, или даже одинаковы между
          двумя вызовами одной и той же процедуры или синтаксической формы. Некоторые реализации Scheme используют специальные
          объекты для обозначения неопределённого значения. Печать этого объекта часто подавляется интерактивными системами
          Scheme, поэтому значения выражений, возвращающих неопределённые значения, не печатаются.])

      (p [В то время, как большинство стандартных процедур возвращает одно значение, язык поддерживает процедуры, которые
          возвращают ноль, одно, более одного, или переменное количество значений, используя механизм, описанный в главе
          5.8. Некоторые стандартные выражения могут вычисляться в множество значений, если одно из подвыражений вычисляется в
          множество значений т.е. когда вызывается процедура, возвращающая несколько значений. Когда такое случается, выражению
          предписано возвращать ,(it "значения"), а не ,(it "значение") его подвыражения. То же касается стандартных процедур, принимающих
          аргументом функцию - им предписывается возвращать множественное значение в том случае, если процедура-аргумент,
          влияющая на результат, возвращает множественное значение.])

      (p [В этой книге используются слова 'должен' и 'следует', чтобы описать программные требования, такие как требование,
          чтобы передаваемый индекс был меньше, чем длина вектора, при вызове ,(var "vector-ref"). Если использовано слово 'должен', это
          значит, что реализация будет отслеживать выполнение этих требований т.е. будет выброшено исключение, обычно с типом
          условия ,(var "&assertion"). Если используется слово 'следует', исключение может быть выброшено, а может не быть, если нет -
          поведение программы не определено. Фраза 'нарушение синтаксиса' используется, чтобы описать ситуацию, когда программа
          сформирована неправильно. Нарушения синтаксиса обнаруживаются в основном при выполнении программы. Когда нарушение
          синтаксиса обнаружено, выбрасывается исключение типа ,(var "&syntax") и программа прекращает работу.])

      (p [Типографические соглашения, используемые в этой книге весьма просты. Все объекты напечатаны таким же образом, как они
          выглядели бы, если бы их набрали на клавиатуре. Это касается ключевых слов синтаксиса, переменных, константных
          объектов, выражений Scheme, и примеров программ. Выделение ,(it "курсивом") используется для обозначения синтаксических
          переменных в пояснениях синтаксических форм, аргументов и процедур. Так же курсивом выделены технических термины,
          используемые впервые. Обычно, имена и синтаксические формы находятся в нижнем регистре, даже если они начинают новое
          предложение.  То же касается и синтаксических переменных, выделенных курсивом.])

      (p [В описании синтаксических форм и процедур, один или несколько прототипов шаблонов показывают синтаксическую форму или
          формы или корректное количество аргументов для применения процедуры. Ключевое слово или имя процедуры выделяются
          машинописным шрифтом, так же как и круглые скобки. Остальные части синтаксиса или аргументы выделяются курсивом,
          используя имя, обозначающее тип выражения или аргумента, ожидаемого синтаксической формой или процедурой. Окружности
          используются для обозначения нуля или более вхождений подвыражения или аргумента. Например, ,(var "(or expr ...)")
          описывает синтаксическую форму ,(var "or"), которая имеет ноль или более подвыражений, и ,(var "(member obj list)") описывает
          процедуру ,(var "member"), которая ожидает два аргумента - объект и список.])
      (p [Нарушением синтаксиса считается случай, когда структура синтаксической формы не совпадает с её прототипом. Обычно,
          выбрасывается исключение типа ,(var "&assertion"), если количество аргументов, переданных в стандартную процедуру не
          совпадает с тем, которое ожидается к получению. Исключение с типом условия ,(var "&assertion") также выбрасывается, если
          стандартная процедура получает аргумент, который не подразумевается в его названии, или не удовлетворяет другим
          критериям, указанным в описании процедуры. Например, прототип для ,(var "vector-set!") таков:])

      (src :line #f
         [(vector-set! vector n obj)])

      (p [и в описании говорится, что ,(var "n") должен быть неотрицательным целым числом, строго меньшим, чем длина вектора. Таким
          образом, ,(var "vector-set!") должен получить три аргумента, первый из которых должен быть вектором, второй должен быть
          неотрицательным целым числом, меньше длины вектора, и третьим может быть любой объект Scheme. В противном случае,
          будет выброшено исключение с типом условий ,(var "&assertion").])
      (p [В большинстве случаев тип ожидаемого аргумента очевиден, как в случае в ,(var "vector"), ,(var "obj") или ,(var "binary-input-port"). В
          остальных же случаях, по большей части использующихся в описании числовых операций, используются сокращения, такие
          как ,(it "int") для целочисленных, ,(it "exint") (от exact integer) для строгого указания целочисленного типа и ,(it "fx") для типа
          ,(it "fixnum"). Эти сокращения поясняются в начале разделов, где мы их впервые коснёмся.])))