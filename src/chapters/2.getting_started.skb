;;; -*- coding: utf-8; tab-width: 4; c-basic-offset: 2; indent-tabs-mode: nil; fill-column: 120; -*-

(chapter :title [Начало]
   (chapter-image "images/ch2.png")
   (p [Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
       параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.])
   (p [После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
       Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
       данных и управляющие конструкции.])

   (section :title [Взаимодействие с интерактивной оболочкой Scheme]
      (p [Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
          разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
          "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
          или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
          выполнения на экран.])
      (p [Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
          выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
          работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
          и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
          в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
          реализаций файл может быть загружен с помощью нестандартизированной процедуры ,(var "load") , принимающую путь к файлу в
          качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
          программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
          для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
          образом, как если бы они были набраны на клавиатуре интерактивно.])
      (p [Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
          значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
          позволяет сконцентрироваться на написании программы.])
      (p [Примеры в этой и остальных главах книги следуют определённым соглашениям в форматировании. Выражения, которые вы
          можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После → следует значение
          выражения, что следует читать как "имеет следующее значение". Знак → применим для определений и в тех случаях, когда
          значение выражения неопределено.])
      (p [Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
          потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
          строки, так что, мы вольны выбирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
          выбранный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
          она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.])
      (p [Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
          будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
          набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить ,(var "\"Hi Mom!\""), потому что
          значение вычисления любой константы - сама константа.])

      (include-src "src/scheme/getting_started.scm" 1 1)

      (p [Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
          однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.])

      (include-src "src/scheme/getting_started.scm" 3 10)

      (p [Будьте внимательны и не пропустите не одной одинарной кавычки ( ,(var "'") ), двойной кавычки, или скобки. Если вы пропустите
          одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
          попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
          ожидать её даже после окончания ввода.])
      (p [Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
          дождаться пояснений, найдя их далее в главе.])

      (include-src "src/scheme/getting_started.scm" 12 16)

      (p [Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
          выражение по парным двойным кавычкам и скобкам.])
      (p [Теперь, давайте попробуем определить новую процедуру.])

      (include-src "src/scheme/getting_started.scm" 18 20)

      (p [Процедура ,(var "square") вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
          процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет достаточно сказать, что ,(var "define") производит
          связывание переменной, ,(var "lambda") создаёт процедуру, а ,(var "*") - имя процедуры умножения. Обратите внимание на форму этих
          выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
          предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
          операций, вроде ,(var "*").])
      (p [Опробуем наш ,(var "square") в деле:])

      (include-src "src/scheme/getting_started.scm" 22 25)

      (p [Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл "reciprocal.ss."])

      (include-src "src/scheme/getting_started.scm" 27 31)

      (p [Эта процедура, ,(var "reciprocal") (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ,(var "reciprocal")
          вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ,(var "load"):])

      (src
         [> (load "reciprocal.ss")])

      (p [Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:])

      (include-src "src/scheme/getting_started.scm" 33 36))

   (section :title [Простейшие выражения]
      (p [Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
          списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
          примеров со строками и числами.])
      (p [Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
          ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:])

      (include-src "src/scheme/getting_started.scm" 38 41)

      (p [Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
          целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
          используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.])
      (p [Scheme предоставляет имена ,(var "+"), ,(var "-"), ,(var "*"), и ,(var "/") для соответствующих арифметических операций. Каждая процедура
          поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
          обозначают применение процедуры к набору аргументов.])

      (include-src "src/scheme/getting_started.scm" 43 47)

      (p [Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
          процедура принимающая ноль, один, два или больше аргументов, записывается как ,(var "(процедура аргумент ...)"). Это
          постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
          относительно приоритета или ассоциативности операторов.])
      (p [Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
          образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
          формул.])

      (include-src "src/scheme/getting_started.scm" 49 52)

      (p [Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
          мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
          лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.])
      (p [Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
          содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
          является массив (,(var "array")). В Scheme же это список (,(var "list")). Списки записываются как последовательности объектов,
          обособленные скобками. Например, ,(var "(1 2 3 4 5)") это список чисел, и ,(var "(\"это\" \"тоже\" \"список\")") это список строк. Списки
          не обязательно содержат объекты одного типа, так что ,(var "(4.2 \"привет\")") это корректный список, содержащий число и
          строку. Списки могут быть вложенными (содержать другие списки), так что ,(var "((1 2) (3 4))") это корректный список из двух
          элементов, каждый из которых это список из двух элементов.])
      (p [Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
          Scheme различает их. Например, как Scheme отличит список объектов ,(var "(obj1 obj2 ...)") от применения процедуры
          ,(var "(procedure arg ...)")?])
      (p [В некоторых случаях различие может показаться очевидным. Список чисел ,(var "(1 2 3 4 5)") довольно сложно спутать с
          применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
          Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
          потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ,(var "(+ 3 4)"), как
          список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
          применение процедуры. Это делается с помощью ,(var "quote") (пер. цитата, кавычка).])

      (include-src "src/scheme/getting_started.scm" 54 56)

      (p [С помощью ,(var "quote") мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
          ,(var "quote"), скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
          третьего.])
      (p [Поскольку использование ,(var "quote") крайне востребовано в Scheme коде, для него было введено специальное сокращённое
          обозначение в виде одинарной цитирующей кавычки (,(var "`")), предшествующей выражению, которая является просто
          аббривеатурой для ,(var "quote").])

      (include-src "src/scheme/getting_started.scm" 58 60)

      (p [Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
          будет заключён в выражение ,(var "quote").])
      (p [Выражение ,(var "quote") это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
          принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
          процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
          принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.])
      (p [Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение ,(it "с") и ,(it "без") оператора ,(var "quote").])

      (include-src "src/scheme/getting_started.scm" 62 62)

      (p [Символ ,(var "hello") должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ,(var "hello") как
          переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
          выражениях и уравнениях. Когда мы вычисляем математическое выражение ,(var "1 - x") для некоторого значения ,(var "x"), мы думаем
          об ,(var "x") как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ,(it [x,(sup 2) -1 = (x - 1)(x + 1)]) мы
          думаем об ,(var "x") как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
          списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
          идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
          используются для представления переменных в описании символьных уравнений или программ, символы могут также
          использоваться, например, как слова в описании предложений естественного языка.])
      (p [Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
          символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
          написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
          в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
          самых значительных особенностей Scheme.])
      (p [Числа и строки также могут цитироваться:])

      (include-src "src/scheme/getting_started.scm" 64 66)

      (p [Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.])
      (p [Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
          значения из списка: ,(var "car") и ,(var "cdr") (произносится 'кудр'). ,(var "car") возвращает первый элемент из списка, ,(var "cdr") возвращает
          оставшуюся часть, хвост списка. Имена ,(var "car") и ,(var "cdr") произошли от операций, поддерживаемых первым компьютером,
          на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:])

      (include-src "src/scheme/getting_started.scm" 68 76)

      (p [Первый элемент списка, часто называют ,(it "car") или ,(it "головой") списка, остальную часть списка часто называют ,(it "cdr") или
          ,(it "хвостом"). ,(var "cdr") от списка с одним элементом это ,(var "()"), пустой список.])

      (p [Процедура ,(var "cons") создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
          ,(var "cons") вернёт список.])

      (include-src "src/scheme/getting_started.scm" 78 88)

      (p ["car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
          путём добавления элемента в начало списка называется ,(it "consing") (устоявшегося перевода на русский язык нет, но
          примерный - ,(it "кортежирование"), или возможно ,(it "спаривание"), ведь здесь речь идёт о кортежах именно длины 2, у которых
          есть устоявшееся название - пары).])
      (p [Обратите внимание на слово "обычно" в описании второго аргумента ,(var "cons"). Процедура ,(var "cons"), на самом деле, создаёт
          пары и вовсе не обязательно, чтобы ,(it "cdr") пары был списком. Список - это последовательность пар. ,(it "cdr") каждой пары это
          следующая пара в последовательности.])

      (p (center (image :file "images/1.png" :width 200)))

      (p [,(it "cdr") последней пары в ,(it "правильном") списке это пустой список. В противном случае, последовательность пар формирует
          ,(it "неправильный") список. Если говорить более формально, то пустой список - это ,(it "правильный") список, а так же
          ,(it "правильным") становится любой список, ,(it "cdr") которого ,(it "правильный") список.])
      (p [Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу списка.])

      (include-src "src/scheme/getting_started.scm" 90 92)

      (p [Из за этих соглашений о печати, пары, чей ,(it "cdr") не является списком, часто называют ,(it "точечными парами"). Так же пары,
          чей ,(it "cdr") является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
          ,(it "правильные") списки без точек.])

      (include-src "src/scheme/getting_started.scm" 94 94)

      (p [Процедура ,(var "list") похожа на ,(var "cons"), с той разницей, что она принимает произвольное количество аргументов и всегда
          строит ,(it "правильные") списки.])

      (include-src "src/scheme/getting_started.scm" 96 98)

      (p [Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
          чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.])
      (subsection :title "Упражнение"
         (p [Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:])
         (itemize
          (item (var "1.2 × (2 - 1/3) + -8.7"))
          (item (var "(2/3 + 4/9) ÷ (5/11 - 4/3)"))
          (item (var "1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))"))
          (item (var "1 × -2 × 3 × -4 × 5 × -6 × 7"))))
      (subsection :title "Упражнение"
         (p [Поэксперементируйте с процедурами ,(var "+"), ,(var "-"), ,(var "*"), и ,(var "/") чтобы разобраться с правилами Scheme для типа значения,
             возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.]))
      (subsection :title "Упражнение"
         (p [Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои ответы:])
         (itemize
          (item (code "(cons 'car 'cdr)"))
          (item (code "(list 'this '(is silly))"))
          (item (code "(cons 'is '(this silly?))"))
          (item (code "(quote (+ 2 3))"))
          (item (code "(cons '+ '(2 3))"))
          (item (code "(car '(+ 2 3))"))
          (item (code "(cdr '(+ 2 3))"))
          (item (code "cons"))
          (item (code "(quote cons)"))
          (item (code "(quote (quote cons))"))
          (item (code "(car (quote (quote cons)))"))
          (item (code "(+ 2 3)"))
          (item (code "(+ '2 '3)"))
          (item (code "(+ (car '(2 3)) (car (cdr '(2 3))))"))
          (item (code "((car (list + - * /)) 2 3)"))))
      (subsection :title "Упражнение"
         (p [,(var "(car (car '((a b) (c d))))") возвращает ,(var "a"). Определите необходимую комбинацию из ,(var "car") и ,(var "cdr"), применение
             которой к ,(var "((a b) (c d))") вернёт ,(var "b"), ,(var "c"), ,(var "d").]))
      (subsection :title "Упражнение"
         (p [Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:])
         (center (image :file "images/2.png" :width 200)))

      (subsection :title "Упражнение"
         (p [Нарисуйте, как будет выглядить список, возвращённый следующим выражением:])
         (var "(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))"))
      (subsection :title "Упражнение"
         (p [Поведение выражения ,(var "(car (car (car '((a b) (c d)))))") неопределено, потому что  ,(var "(car '((a b) (c d)))") это  ,(var "(a b)"),
             ,(var "(car '(a b))") это ,(var "a"), а ,(var "(car 'a)") неопределно. Определите все корректные комбинации ,(var "car") и ,(var "cdr") для
             выражения ,(var "((a b) (c d))").]))
      (subsection :title "Упражнение"
         (p [Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше объяснение?])))

   (section :title [Выполнение Scheme-выражений]
      (p [Давайте вернёмся к обсуждению, как всётаки Scheme выполняет набранные Вами выражения. Мы уже установили правила для
          константных  объектов, таких как строки и числа: эти объекты являются значениями сами по себе. Вы возможно уже
          выработали у себя в голове некоторые правила для вычисления применения процедур вида ,(var "(procedure arg1 ... argN)").
          Здесь, ,(var "procedure") это выражение, представляющее Scheme процедуру, а ,(var "arg1 ... argN") выражения,
          представляющие её аргументы. Один из возможных вариантов её применения следующий:])

      (itemize
         (item [Определить значение ,(var "procedure").])
         (item [Определить значение ,(var "arg1").])
         (item [...])
         (item [Определить значение ,(var "argN").])
         (item [Применить значение ,(var "procedure") к значениям ,(var "arg1 ... argN").]))

      (p [Для примера, рассмотрим применение простой процедуры ,(var "(+ 3 4)"). Значение ,(var "+") это процедура сложения, значение ,(var "3")
          это число ,(var "3"), значение ,(var "4") это число ,(var "4"). Применение процедуры сложения к ,(var "3") и ,(var "4") даёт ,(var "7"), так что мы получаем
          значение ,(var "7").])
      (p [Применяя данный алгоритм на каждом уровне, мы можем найти значения вложенного выражения ,(var "(* (+ 3 4) 2)"). Значение
          ,(var "*") это процедура умножения, значение ,(var "(+ 3 4)"), как мы выяснили выше, это ,(var "7"), а значение ,(var "2") это ,(var "2"). Перемножив
          ,(var "7") и ,(var "2") мы получаем ,(var "14"), так что наш ответ ,(var "14").])
      (p [Это правило работает для применения процедуры, но не работает для ,(it "цитированного") выражения, потому что подвыражения
          примененияя процедуры вычисляются, в то время как подвыражения ,(it "цитированного") выражения нет. Вычисление
          ,(it "цитированного") выражения более похоже на вычисление константного объекта. Значение ,(it "цитированного") выражения ,(var "(quote
          object)") это просто ,(var "object").])
      (p [Константные объекты, применения процедур и ,(it "цитированные") выражения это только три из множества синтаксических форм,
          предоставляемых Scheme. К счастью, лишь немногие из оставшихся синтаксических форм неприменно должны быть понимаемы
          Scheme программистом. Они называются ,(it "основными синтаксическими формами"). Остальные синтаксические формы это
          синтаксические выражения, преимущественное, выраженные в терминах основных синтаксических форм. Мы обсудим
          оставшиеся синтаксические формы и некоторые синтаксические выражение ниже в этой главе. Секция 3.1 подытоживает
          обзор основных синтаксических форм и даёт введение в механизм расширения синтаксиса.])
      (p [Прежде чем мы перейдём к новым синтаксическим формам и процедурам, будет не лишним сказать пару слов о вычислении
          применения процедур. Во-первых, описанный выше процесс слишком строг, поскольку он требует вычисления подвыражений
          слева направо, это значит, что значение ,(var "procedure") будет вычислено до вычисления ,(var "arg1"), ,(var "arg1") до ,(var "arg2") и
          т.д. Это вовсе не обязательно. ,(it "Вычислитель") Scheme свободен вычислять выражения в любом порядке - слева направо,
          справо налево, или в любой другой последовательности. На деле, подвыражения могут вычисляться в различном порядке в
          различных случаях, даже в рамках одной и той же реализации.])
      (p [Во-вторых ,(var "procedure") вычисляется таким же образом, как и ,(var "arg1 ... argN"). Хотя процедура часто является переменной,
          которая указывает на конкретную процедуру, это не обязательно. Упражнение 2.2.3 предложит Вам определить значение
          выражения ,(var "((car (list + - * /)) 2 3)"). Здесь процедура это ,(var "(car (list + - * /))"). Значение ,(var "(car (list + - * /))")
          это процедура сложения, как если бы была просто записана переменная +.])

      (subsection :title "Упражнение"
         (p [Опишите шаги, необходимые для вычисления выражения ниже:])
         (src-lite "((car (cdr (list + - * /))) 17 5)")))

   (section :title [Переменные и ,(var "let") выражения]
      (p [Пусть ,(var "expr") это Scheme выражение, содержащее переменную ,(var "var"). Допустим также, что нам хотелось бы, чтобы
          переменная ,(var "var") содержала бы значение ,(var "val"), когда мы вычисляем значение ,(var "expr"). Например, мы хотим, чтобы ,(var "x") имел
          значение ,(var "2"), когда вычисляется выражение ,(var "(+ x 3)"). Или, мы хотим, чтобы ,(var "y") имел значение ,(var "3"), при вычислении
          выражения ,(var "(+ 2 y)"). Примеры ниже показывают, как добиться такого поведения при помощи синтаксической формы ,(var "let"):])

      (include-src "src/scheme/getting_started.scm" 100 107)

      (p [Синтаксическая форма ,(var "let") включает в себя список пар ,(it "переменная->выражение"), а так же список выражений,
          использующих эти переменные, называемый телом (,(it "body")) ,(var "let"). В общем виде выражение ,(var "let") имеет следующую форму:])

      (src
         [(let ((var expr) ...) body1 body2 ...)])

      (p [Таким образом, с помощью ,(var "let"), мы говорим, что переменные связываются со своими значениями, и далее мы можем
          ссылаться на них в теле выражения.])

      (p [,(var "let") выражения применяются очень часто и служат средством упрощения выражений, которые содержат несколько
          идентичных подвыражений. Вынесение этого подвыражения в секцию связывания переменных гарантирует, что выражение
          будет вычислено лишь единожды.])

      (include-src "src/scheme/getting_started.scm" 109 111)

      (p [В секции связывания переменных часто вместо круглых скобок применяют квадратные, чтобы визуально отделить эту
          область от остального тела:])

      (include-src "src/scheme/getting_started.scm" 113 117)

      (p [Scheme интерпретирует формы, заключённые в квадратные скобки так, как будто они заключены в круглые скобки, но
          нельзя их смешивать - открывающей круглой скобке должна соответствовать закрывающая круглая скобка, а открывающей
          квадратной - квадратная. Мы используем квадратные скобки для ,(var "let") (и как вы скоро увидите, так же ещё для некоторых
          стандартных синтаксических форм), чтобы улучшить читаемость кода, особенно когда мы могли бы иметь две или более
          последовательные открывающие круглые скобки.])
      (p [Поскольку, при применении процедуры, вычисление выражения, стоящего в первой позиции, происходит таким же образом,
          как и любого другого выражения, здесь так же может быть использована ,(it "let-связанная") переменная:])

      (include-src "src/scheme/getting_started.scm" 119 126)

      (p [Переменные, связанные с помощью ,(var "let") видны только в пределах ,(it "тела"):])

      (include-src "src/scheme/getting_started.scm" 128 132)

      (p [И это очень хорошо, что оно работает именно так, потому что мы не хотели бы, чтобы значение + было методом умножения всюду.])
      (p [Так же выражения ,(var "let") могут быть вложенными:])

      (include-src "src/scheme/getting_started.scm" 133 137)

      (p [Когда во вложенном ,(var "let") выражении производят связывание той же переменной, что и во внешнем, только связывание,
          выполненное последним, на более глубоком уровне, считается действующим в пределах тела внутреннего ,(var "let")-выражения:])

      (include-src "src/scheme/getting_started.scm" 138 140)

      (p [Здесь внешнее ,(var "let") выражение связывает ,(var "x") и 1 в пределах своего тела, место которого занимает второе ,(var "let")
          выражение. Внутреннее ,(var "let") выражение связывает ,(var "x") со значением ,(var "(+ x 1)") в рамках своего тела, которое
          представлено выражением ,(var "(+ x x)"). Каково значение выражения ,(var "(+ x 1)")? Поскольку ,(var "(+ x 1)") появляется в теле
          внешнего ,(var "let"), но не в теле внутреннего ,(var "let"), значение ,(var "x") должно быть 1, и, следовательно, значение ,(var "(+ x 1)")
          равно 2. А что насчёт ,(var "(+ x x)")? Оно появляется в теле обоих выражений ,(var "let"). Видно только внутреннее связывание для
          ,(var "x"), поэтому ,(var "x") равно 2, а ,(var "(+ x x)") равно 4.])
      (p [Про внутреннее связывание для ,(var "x") говорят, что оно ,(it "затеняет") внешнее связывание. let-связанная переменная видна
          везде внутри тела ее выражения ,(var "let"), кроме случаев, когда она затенена. Область, в которой действует связывание
          переменной, называется ,(it "областью видимости") (scope). Область видимости первого ,(var "x") в приведенном выше примере - это
          тело внешнего выражения ,(var "let") минус тело внутреннего выражения ,(var "let"), где он затеняется вторым ,(var "x"). Эта форма
          определения области видимости называется ,(it "лексической областью видимости"), поскольку область видимости каждого
          связывания может быть определена путем простого текстового анализа программы.])
      (p [Затенения можно избежать, дав различные имена переменным. Выражение выше может быть переписано так, что во
          внутреннем ,(var "let") выражении будет производиться связывание значения с именем ,(var "new-x"):])

      (include-src "src/scheme/getting_started.scm" 142 144)

      (p [Хотя выбор разных имен иногда может предотвратить путаницу, затенение может помочь предотвратить случайное
          использование "старого" значения. Например, в исходной версии предыдущего примера мы не могли бы ошибочно сослаться
          на внешний ,(var "x") в теле внутреннего ,(var "let").])

      (subsection :title "Упражнение"
         (p [Перепишите выражения ниже, используя ,(var "let"), чтобы вынести общие подвыражения и улучшить структуру кода. Не
             используйте математических упрощений.])
         (itemize
            (item (src-lite "(+ (- (* 3 a) b) (+ (* 3 a) b))"))
            (item (src-lite "(cons (car (list a b c)) (cdr (list a b c)))"))))
      (subsection :title "Упражнение"
         (p [Определите значение вычисления следующего выражение. Поясните, как вы получили это значение.])
         (src-lite "
(let ([x 9])
   (* x
      (let ([x (/ x 3)])
        (+ x x))))"))
      (subsection :title "Упражнение"
         (p [Перепишите следующие выражения, чтобы дать уникальные имена каждой отдельной let-связанной переменной, чтобы ни
             одна из переменных не была затенена. Убедитесь, что значение вашего выражения совпадает со значением исходного
             выражения.])
        (itemize
         (item (src-lite "
(let ([x 'a] [y 'b])
   (list (let ([x 'c]) (cons x y))
         (let ([y 'd]) (cons x y))))"))
         (item (src-lite "
(let ([x '((a b) c)])
   (cons (let ([x (cdr x)])
           (car x))
         (let ([x (car x)])
           (cons (let ([x (cdr x)])
                   (car x))
                 (cons (let ([x (car x)])
                         x)
                       (cdr x))))))")))))

   (section :title [Лямбда выражения]
      (p [В выражении ,(var "(let ([x (* 3 4)]) (+ x x))") переменная ,(var "x") связана со значением ,(var "(* 3 4)"). Что будет, если мы захотим
          получить значение выражения ,(var "(+ x x)") где  ,(var "x") связана со значением ,(var "(/ 99 11)")? А где ,(var "x") связана со значением
          ,(var "(- 2 7)")? В каждом случае нам потребуется новое ,(var "let")-выражение. И чем сложнее становится тело ,(var "let"), тем менее
          удобно становится повторять его.])
      (p [Вместо этого мы можем использовать синтаксическую форму ,(var "lambda") для создания новой процедуры, которая имеет ,(var "x") в
          качестве входного параметра и имеет такое же тело, как у ,(var "let")-выражения.])

      (src
           [(lambda (x) (+ x x)) → #<procedure>])

      (p [Общая форма лямбда-выражения:])

      (src
           [(lambda (var ...) body1 body2 ...)])

      (p [Переменные ,(var "var ...") это формальные параметры процедуры, а последовательность выражений ,(var "body1 body2 ...") это её
          тело. (В действительности, по-настоящему общая форма это нечто более обобщённое, чем это, как вы увидите позже).])
      (p [Процедура - это такой же объект, как число, строка, символ или пара. У неё нет какого-либо вменяемого печатного
          представления, по крайней мере в Scheme, тем не менее, в этой книге мы будем использовать обозначение ,(var "#<procedure>")
          чтобы показать, что значение выражения это процедура.])
      (p [Простейшая операция, которую можно совершить над процедурой - это применить её к одному или более значений:])

      (include-src "src/scheme/getting_started.scm" 146 146)

      (p [Здесь нет никакого отличия от какого-то другого способа применения процедуры. Процедура это результат вычисления
          выражения ,(var "(lambda (x) (+ x x))") и единственный агрумент это значение выражения ,(var "(* 3 4)"), или 12. Значения
          аргументов, или параметры, связываются с формальными параметрами в пределах тела лямбда-выражения таким же образом,
          как и let-связывание связывает переменные с их значениями. В этом случае, ,(var "x") связывается с 12, а значение ,(var "(+ x x)")
          равно 24. Таким образом, результат применения процедуры к значению 12 равен 24.])
      (p [Посколько процедуры это объекты, мы можем установить процедуру как значение переменной и использовать эту процедуру
          в дальнейшем не раз.])

      (include-src "src/scheme/getting_started.scm" 148 151)

      (p [Здесь мы установили связывание между ,(var "double") и процедурой, а затем использовали эту процедуру, чтобы удвоить три
          различных значения.])
      (p [Наша процедура ожидает, что её фактическим параметром будет число, поскольку он передаётся фактическим параметром в
          ,(var "+"). В общем же случае, фактическим параметром может быть объект любого сорта. Рассмотрим, для примера, простейшую
          процедуру, которая использует ,(var "cons") вместо ,(var "+"):])

      (include-src "src/scheme/getting_started.scm" 153 154)

      (p [Отмечая сходство между ,(var "double") и ,(var "double-cons"), вы не должны удивляться, узнав, что они могут быть объединены в
          одну процедуру путем добавления дополнительного аргумента.])

      (include-src "src/scheme/getting_started.scm" 156 158)

      (p [Здесь демонстрируется, что процедуры могут принимать более одного аргумента и эти аргументы, передаваемые в
          процедуру, сами могу быть процедурами.])
      (p [Как и с ,(var "let")-выражениями, лямбда-выражения становятся несколько интереснее, когда они вложены в другие
          лямбда- или let-выражения.])

      (include-src "src/scheme/getting_started.scm" 160 162)

      (p [Вхождение ,(var "x") в лямбда-выражение ссылается на ,(var "x") за пределами лямбды, который был связан внешним
          let-выражением. Говорят, что переменная ,(var "x") в лямбда-выражении свободна или является свободной переменной
          лямбда-выражения. Переменная ,(var "y") не является свободной переменной в лямбда-выражении, поскольку она была связана в
          лямбда-выражении. Переменная, которая становится свободной в лямбда-выражении должна уже быть связана, например,
          окружающим лямбда- или let-выражением, кроме случая, когда переменная связывается вне выражения, который мы обсудим
          в следующем разделе.])
      (p [Что происходит, когда процедура применяется где-то вне области привязок для переменных, которые встречаются в
          процедуре свободно, как в следующем выражении?])

      (include-src "src/scheme/getting_started.scm" 164 166)

      (p [Ответ заключается в том, что те же привязки, которые действовали при создании процедуры, снова применяются при
          применении процедуры. Это верно, даже если другая привязка для ,(var "x") видна там, где применяется процедура.])

      (include-src "src/scheme/getting_started.scm" 168 171)

      (p [В обоих случаях, значение ,(var "x") за пределами процедуры названой ,(var "f") это ,(var "sam").])
      (p [Примечательно, что let-выражение это ни что иное, как прямое применение лямбда-выражения с целью задать аргументы
          выражения. Например, два выражения ниже эквивалентны:])

      (src
           "(let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)")

      (p [В действительности, let-выражение это синтаксическое выражение, определённое в терминах лямбда-выражения и
          применения процедуры, которые оба являются базовыми синтаксическими формами. В общем случае, любое выражение вида])

      (src [(let ((var expr) ...) body1 body2 ...)])

      (p [эквивалентно следующему])

      (src [((lambda (var ...) body1 body2 ...) expr ...)])

      (p [В секции 3.1 будут более подробно обсуждаться базовые формы и расширения синтаксиса.])
      (p [Как упоминалось выше, общая форма лямбда-выражения несколько сложнее, чем форма, рассмотренная нами ранее, в том,
          что формальное объявление параметра, ,(var "(var ...)"), не обязано быть правильным списом, или даже списком
          вообще. Формальное объявление параметра может быть любой из трёх форм ниже:])

      (itemize
         (item [правильный список переменных ,(var "(var1 ... varN)"), как мы видели только что])
         (item [одна переменная ,(var "varR")])
         (item [неправильный список переменных, ,(var "(var1 ... varN . varR)").]))

      (p [В первом случае должно быть передано ровно ,(var "N") параметров, и каждая переменная связана с соответствующим
          переданным параметром. Во втором, любое количество переданных параметров валидно, все переданные параметры
          собираются в один список и единственная переменная связывается с этим списком. Третий случай это гибрид первых
          двух. По меньшей мере ,(var "N") параметров должно быть передано. Переменные ,(var "var1 ... varN") связываются с соответствующими
          переданными параметрами, а переменная ,(var "varR") связывается со списком, содержащим остальные переданные параметры. Во
          втором и третьем случаях, параметр ,(var "varR") иногда обозначают как "rest" (англ. остальные), потому что он содержит
          оставшиеся переданные параметры, помимо тех, которые индивидуально названы.])
      (p [Давайте рассмотрим несколько примеров, чтобы прояснить более общий синтаксис лямбда-выражений:])

      (include-src "src/scheme/getting_started.scm" 173 183)

      (p [В первых двух примерах, процедура, названная ,(var "f") принимает любое количество аргументов. Эти аргументы автоматически
          групируются в список, с которым связывается переменная ,(var "x"), значение ,(var "f") это этот список. В первом примере,
          аргументы 1, 2, 3, 4, так что ответ ,(var "(1 2 3 4)"). Во втором примере нет аргументов, так что ответ это пустой список
          ,(var "()"). Значение процедуры названой ,(var "g"), в третьем примере, это список, чей первый элемент это первый аргумент, а
          второй элемент это список, содержащий остальные аргументы. Процедура под именем ,(var "h") похожа, но здесь второй аргумент
          отделён. Если процедура ,(var "f") принимает любое количество агрументов, ,(var "g") должен иметь по меньшей мере один, то ,(var "h")
          должен получать не меньше двух аргументов.])
      (subsection :title "Упражнение"
         (p [Определите значения выражений ниже.])
         (itemize
            (item (src-lite "(let ([f (lambda (x) x)])\n   (f 'a))"))
            (item (src-lite "(let ([f (lambda x x)])\n   (f 'a))"))
            (item (src-lite "(let ([f (lambda (x . y) x)])\n   (f 'a))"))
            (item (src-lite "(let ([f (lambda (x . y) y)])\n   (f 'a))"))))
      (subsection :title "Упражнение"
         (p [Как может выглядеть определение примитивной процедуры ,(var "list")?]))
      (subsection :title "Упражнение"
         (p [Найдите все свободные переменные в лямбда-выражениях ниже. Переменные, указывающие на примитивные процедуры, такие
             как ,(var "+") и ,(var "cons") не в счёт.])
         (itemize
            (item (src-lite "(lambda (f x) (f x))"))
            (item (src-lite "(lambda (x) (+ x x))"))
            (item (src-lite "(lambda (x y) (f x y))"))
            (item (src-lite "(lambda (x)\n   (cons x (f x y)))"))
            (item (src-lite "(lambda (x)\n   (let ([z (cons x y)])\n      (x y z)))"))
            (item (src-lite "(lambda (x)\n   (let ([y (cons x y)])\n      (x y z)))")))))

   (section :title [Определения верхнего уровня]
      (p [Переменные, связанные с помощью ,(var "let") и ,(var "lambda") не видны за пределами тел этих выражений. Допустим, у вас есть
          некий объект или процедура, который должен быть доступи отовсюду, например, как ,(var "+") или ,(var "cons"). Вам нужно
          определение верхнего уровня, которое может быть установлено с помощью ,(var "define"). Определения верхнего уровня,
          поддерживаемые большенством интерактивных систем Scheme, доступны в любом введённом вами выражении, за исключением
          случаев, когда оно затенено другим локальным связыванием.])
      (p [Давайте установим определение верхнего уровня для процедуры ,(var "double-any") из последней секции:])

      (include-src "src/scheme/getting_started.scm" 185 187)

      (p [Теперь переменная ,(var "double-any") имеет тот же статус, что и ,(var "cons") или любая другая примитивная процедура. Мы можем
          использовать ,(var "double-any") так, как если бы это была примитивная процедура.])

      (include-src "src/scheme/getting_started.scm" 189 190)

      (p [Определение верхнего уровня может быть установлено для любого объекта, не только процедур.])

      (include-src "src/scheme/getting_started.scm" 192 194)

      (p [Однако чаще всего определения верхнего уровня используются для процедур.])
      (p [Как было отмечено выше, определения верхнего уровня могут быть затенены связываниями в ,(var "let") или ,(var "lambda").])

      (include-src "src/scheme/getting_started.scm" 196 198)

      (p [Переменные, объявленные на верхнем уровне действуют почти так-же, как если бы они были связаны при помощи
          let-выражения, охватывающего весь ваш код.])
      (p [Учитывая только простые инструменты, о которых вы читали до этого момента, уже можно определить некоторые
          примитивные процедуры, предоставляемые Scheme и описанные далее в этой книге. Если вы прошли упражнения из прошлой
          главы, вы должны уже знать, как определить функцию ,(var "list").])

      (include-src "src/scheme/getting_started.scm" 200 200)

      (p [Также, Scheme предоставляет сокращения ,(var "cadr") и ,(var "cddr") для сочетаний ,(var "car") и ,(var "cdr") с ,(var "cdr"). Так, ,(var "(cadr list)")
          равнозначно ,(var "(car (cdr list))"), а ,(var "(cddr list)") это ,(var "(cdr (cdr list))"). Эти функции легко определяются, как описано
          ниже.])

      (include-src "src/scheme/getting_started.scm" 202 211)

      (p [Любое определение ,(var "(define var expr)"), где ,(var "expr") это лямбда, может быть записано в сокращённой форме, которая
          скрывает ,(var "lambda"). Явный синтаксис зависит от формата спецификатора формального параметра лямбда-выражения,
          т.е. будь то правильный список переменных, единственная переменная или неправильный список переменных. Определение
          формы])

      (src
            "(define var0\n   (lambda (var1 ... varN)\n      e1 e2 ...))")

      (p [может быть сокращено до])

      (src
           "(define (var0 var1 ... varN)\n   e1 e2 ...)")

      (p [в то время как])

      (src
           "(define var0\n   (lambda varR\n      e1 e2 ...))")

      (p [может быть сокращено до])

      (src
           "(define (var0 . varR)\n   e1 e2 ...)")

      (p [и])

      (src
           "(define var0\n   (lambda (var1 ... varN . varR)\n      e1 e2 ...))")

      (p [может быть сокращено до])

      (src
           "(define (var0 var1 ... varN . varR)\n   e1 e2 ...)")

      (p [Например, определения ,(var "cadr") и ,(var "list") могут быть записаны следующим образом])

      (include-src "src/scheme/getting_started.scm" 213 216)

      (p [В этой книге данный альтернативный синтаксис используется редко. Несмотря на короткую запись, это приводит к
          сокрытию того факта, что процедура не имеет такой тесной связи с переменными или именами, как во многих других
          языках. Этот синтаксис часто называют несколько уничижительно, как «defun» для define, после формы defun,
          введённой языками Lisp, в которой процедуры более тесно связаны с их именами.])
      (p [Определения верхнего уровня облегчают нам эксперименты с процедурой в интерактивном режиме, поскольку нам не нужно
          повторно вводить процедуру каждый раз, когда она используется.])
      (p [Давайте попробуем определить несколько более сложный вариант ,(var "double-any"), который превращает «обычную» процедуру с
          двумя аргументами в «дублирующую» процедуру с одним аргументом.])

      (include-src "src/scheme/getting_started.scm" 218 220)

      (p [,(var "doubler") принимает один аргумент, ,(var "f"), который должен быть процедурой, принимающей два аргумента. Процедура,
          возвращаемая ,(var "doubler") принимает один аргумент, который используется как оба аргумента при применении ,(var "f"). Мы можем
          определить с помощью ,(var "doubler") процедуры ,(var "double") и ,(var "double-cons") из прошлой главы:])

      (include-src "src/scheme/getting_started.scm" 222 226)

      (p [Также мы можем определить ,(var "double-any") с помощью ,(var "doubler").])

      (include-src "src/scheme/getting_started.scm" 228 230)

      (p [В ,(var "double") и ,(var "double-cons"), ,(var "f") преобретает собственное значение т.е. ,(var "+") или ,(var "cons"), даже если процедуры явно
          применяются вне области действия ,(var "f").])
      (p [Что произойдёт, если вы попробуете использовать пременную, не связанную ,(var "let") или ,(var "lambda"), а так же не имеющую
          определения на верхнем уровне? Попробуйт использовать переменную ,(var "i-am-not-defined") чтобы увидеть, что произойдёт.])

      (src-lite "(i-am-not-defined 3)")

      (p [Большенство реализаций Scheme выведет сообщение, уведомляющее о том, что произошло исключение из за использования
          несвязанной или неопределённой переменной.])
      (p [Однако система не должна жаловаться на появление неопределенной переменной в лямбда-выражении до тех пор, пока не
          будет применена результирующая процедура. Следующее не должно вызывать исключения, хотя мы еще не установили
          определение верхнего уровня для ,(var "proc2").])

      (include-src "src/scheme/getting_started.scm" 232 234)

      (p [Если вы попробуете применить ,(var "proc1") до определения ,(var "proc2"), вы должны получить сообщение об исключении из за
          неопределённости переменной. Давайте дадим ,(var "proc2") определение верхнего уровня и опробуем ,(var "proc1").])

      (include-src "src/scheme/getting_started.scm" 236 237)

      (p [Когда вы определяете ,(var "proc1") система принимает ваше обещание определить ,(var "proc2") и не жалуется до тех пор, пока вы не
          используете ,(var "proc1"), так и не определив ,(var "proc2"). Это позволяет вам определять процедуры в любом удобном для вас
          порядке. Это особенно удобно, когда ты пытаешься организовать файл, полный определений процедур, таким образом,
          чтобы сделать его более читаемым. Это так же нужно, когда две процедуры, определённых на верхнем уровне, зависят
          друг от друга, вы увидите такие примеры далее.])

      (subsection :title "Упражнение"
         [Что произойдёт, если вы наберёте ,(code "(double-any double-any double-any)") давая определение ,(var "double-any") в начале этого раздела?])
      (subsection :title "Упражнение"
         (p [Более элегантный (а также возможно менее эффективный) способ определения ,(var "cadr") и ,(var "cddr"), чем данный в этой главе,
           это определить процедуру, которая объединяет две процедуры, чтобы создать третью. Создайте процедуру ,(var "compose"),
           вида ,(var "(compose p1 p2)"), которая будет создавать композицию процедур ,(var "p1") и ,(var "p2") (предполагается, что они ожидают по
           одному аргументу). Применение этой процедуры, ,(var "(compose p1 p2)"), должно возвращать новую процедуру от одного
           аргумента, которая применяет ,(var "p1") к результату применения ,(var "p2") к аргументу. Используйте эту процедуру, чтобы
           определить ,(var "cadr") и ,(var "cddr").]))
      (subsection :title "Упражнение"
         (p [Scheme также предоставляет процедуры ,(var "caar"), ,(var "cdar"), ,(var "caaar"), ,(var "caadr") и т.д., все компинации до четырёх ,(it "a")
           (обозначающих ,(var "car")) или ,(it "d") (обозначающих ,(var "cdr")) между ,(it "c") и ,(it "r") (см. Главу 6.3). Определите каждую из них с
           помощью процедуры ,(var "compose") из предыдущего упражнения.])))

   (section :title [Условные выражения]
      (p [До сих пор мы рассматривали выражения, которые выполняют свою задачу безоговорочно. Предположим, что мы хотим
          написать процедуру ,(var "abs"). Если аргумент ,(var "x") отрицательный, ,(var "abs") возвращает ,(var "-x"); в противном случае возвращает
          ,(var "х"). Самый простой способ написать ,(var "abs") - это определить, является ли аргумент отрицательным и, если это так,
          инвертировать его, используя синтаксическую форму ,(var "if").])

      (include-src "src/scheme/getting_started.scm" 239 246)

      (p [Выражение ,(var "if") имеет форму ,(var "(if тест следствие альтернатива)"), где ,(var "следствие") это выражение, которое будет
          вычислено, если ,(var "тест") будет истиной (true), а ,(var "альтернатива"), соответственно, выражение, которое будет выполнено в
          обратном случае т.е. если ,(var "тест") будет ложью (false). В выражении выше, тест это ,(var "(< n 0)"), следствие ,(var "(- 0 n)"), а
          альтернатива это ,(var "n").])
      (p [Процедура ,(var "abs") может быть написана множеством других способов. Любое из следующего является корректным определением
          ,(var "abs").])

      (include-src "src/scheme/getting_started.scm" 248 278)

      (p [Первое из этих определений спрашивает, является ли ,(var "n") больше или равно нулю, инвертируя тест. Второе спрашивает, если
          ,(var "n") не меньше нуля, используя процедуру ,(var "not") с ,(var "<"). Третье спрашивает, является ли ,(var "n") больше нуля или ,(var "n") равно нулю,
          используя синтаксическую форму ,(var "or"). Четвертое рассматривает ноль отдельно, хотя в этом нет никакой пользы. Пятое
          несколько хитрее; ,(var "n") либо прибавляется, либо вычитается из нуля, в зависимости от того, больше или равно ,(var "n") чем
          ноль.])
      (p [Почему ,(var "if") это синтаксическая форма, а не процедура? Чтобы ответить на этот вопрос, давайте вернемся к определению
          обратной величины из первого раздела этой главы.])

      (include-src "src/scheme/getting_started.scm" 280 284)

      (p [Второй аргумент процедуры деления не должен быть нулевым, поскольку результат математически не определен. Наше
          определение обратной величины позволяет избежать этой проблемы путем проверки на ноль перед делением. Если бы ,(var "if")
          была процедурой, её аргументы (включая ,(var "(/ 1 n)")) были бы вычислены прежде, чем у нее была возможность выбора между
          следствием и альтернативой. Как и цитирование (,(var "quote")), которое не вычисляет своё единственное подвыражение, ,(var "if")
          не вычисляет все его подвыражения и поэтому не может быть процедурой.])
      (p [Синтаксическая форма ,(var "or") действует аналогично ,(var "if"). Общая форма выражения ,(var "or") является ,(var "(or expr ...)"). Если нет
          подвыражений, то есть выражение просто ,(var "(or)"), значение ложно. В противном случае каждое выражение вычисляется по
          очереди, пока либо (а) одно из выражений не станет истинным, либо (б) больше не останется выражений. В случае (а)
          значение истинно; в случае (б) значение ложно.])
      (p [Чтобы быть более точным, в случае (a) значение выражения ,(var "or") является значением последнего вычисленного
          подвыражения. Это уточнение необходимо, потому что существует много возможных истинных значений. Обычно результатом
          тестового выражения является один из двух объектов ,(var "#t") для обозначения истины или ,(var "#f") для лжи.])

      (include-src "src/scheme/getting_started.scm" 286 287)

      (p [Каждый объект Scheme, любой, является либо истиной либо ложью, для условных выражений, но не для процедур. Только
          ,(var "#f") считается ложью, любой другой объект считается истиной.])

      (include-src "src/scheme/getting_started.scm" 289 302)

      (p [Синтаксическая форма ,(var "and") похожа на ,(var "or") или, но выражение ,(var "and") является истинным, если все его подвыражения
          истинны, и ложным в противном случае. В случае, когда нет никаких подвыражений, то есть выражение просто ,(var "(and)"),
          значение равно ,(var "true"). В противном случае подвыражения вычисляются по очереди до тех пор, пока либо не останется
          подвыражений, либо значение подвыражения будет ложным. Результатом выполнения ,(var "and") является значение последнего
          вычисленного подвыражения.])
      (p [Используя ,(var "and") мы можем определить ,(var "reciprocal") несколько иначе:])

      (include-src "src/scheme/getting_started.scm" 304 311)

      (p [В этой версии значение равно ,(var "#f"), если ,(var "n") равно нулю, и ,(var "1/n") в противном случае.])
      (p [Процедуры ,(var "="), ,(var "<"), ,(var ">"), ,(var "<="), и ,(var ">=") называются предикатами. Предикаты это процедуры, которые отвечают на
          специальный вопрос о своём аргументе и возвращают одно из двух значений, ,(var "#t") или ,(var "#f"). Имена большинства предикатов
          заканчиваются знаком вопроса (?). Простейшие численные процедуры, перечисленные выше, исключение из правил. Конечно
          же не все предикаты требуют в качестве аргументов числа. Предикат ,(var "null?") возвращает истину, если его аргумент
          пустой список ,(var "()"), иначе ложь.])

      (include-src "src/scheme/getting_started.scm" 314 316)

      (p [Процедуре ,(var "cdr") нельзя передавать ничего, кроме пары, иначе это приведёт к исключению. В Common Lisp, однако,
          результат ,(var "(cdr '())") определен как ,(var "()"). Следующая процедура, ,(var "lisp-cdr"), определена с использованием ,(var "null?"),
          чтобы вернуть ,(var "()"), если её аргумент был ,(var "()").])

      (include-src "src/scheme/getting_started.scm" 318 326)

      (p [Еще один полезный предикат - ,(var "eqv?"), который ожидает два аргумента. Если два аргумента эквивалентны, ,(var "eqv?")
          возвращает истину. Иначе ,(var "eqv?") возвращает ложь.])

      (include-src "src/scheme/getting_started.scm" 328 339)

      (p [Как видите, ,(var "eqv?") возвращает истину, если аргументы - это один и тот же символ, логическое значение, число, пара
          или строка. Две пары не считаются эквивалентными с точки зрения ,(var "eqv?"), если они были созданы различными вызовами
          ,(var "cons"), даже если их содержимое одинаково. Подробные правила эквивалентности для ,(var "eqv?") приведены в разделе 6.2.])
      (p [Scheme также предоставляет набор предикатов типа, которые возвращают истину или ложь в зависимости от типа объекта,
          например, ,(var "pair?"), ,(var "symbol?"), ,(var "number?"), и ,(var "string?"). Предикат ,(var "pair?"), например, возвращает истину только в случае,
          если его аргумент - пара.])

      (include-src "src/scheme/getting_started.scm" 341 346)

      (p [Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
          example, the following version of reciprocal checks first to see that its argument is a number before testing against
          zero or performing the division.])

      (include-src "src/scheme/getting_started.scm" 348 352)

      (p [Между прочим, код, использующий ,(var "reciprocal") должен проверять, что было возвращено процедурой - число или
          строка. Чтобы освободить пользователя процедуры от этого обязательства, обычно предпочтительно сообщить об ошибке,
          используя ,(var "assertion-violation") (науршение соглашения) следующим образом:])

      (include-src "src/scheme/getting_started.scm" 357 367)

      (p [Первый аргумент ,(var "assertion-violation") это символ, показывающий, откуда исходит сообщение, второй является строкой,
          описывающей ошибку, а третий и последующие аргументы являются «раздражителями», которые будут включены в сообщение
          об ошибке.])
      (p [Давайте рассмотрим ещё одно условное выражение, ,(var "cond"), которое часто оказывается более полезно, чем ,(var "if"). ,(var "cond")
          похож на ,(var "if") с той разницей, что он позволяет указывать множество пар тест -> выражение. Рассмотрим следующее
          определение процедуры ,(var "sign"), которая возвращает -1, если ей передали негативный аргумент, +1 если позитивный, иначе
          ноль.])

      (include-src "src/scheme/getting_started.scm" 369 380)

      (p [Эти два ,(var "if") выражения могут быть заменены одним ,(var "cond") следующим образом:])

      (include-src "src/scheme/getting_started.scm" 382 387)

      (p [Выражение ,(var "cond") обычно имеет следующую форму:])

      (src-lite "(cond (test expr) ... (else expr))")

      (p [Конечно же клауза ,(var "else") может быть опущена. Это следует делать только в том случае, если невозможно, чтобы все
          тесты провалились, как в новой версии ,(var "sign") ниже:])

      (include-src "src/scheme/getting_started.scm" 389 394)

      (p [В этом определении ,(var "sign") не зависит от порядка в котором тесты будут проводиться, потому что только один из тестов
          может быть истиной, для любого ,(var "n"). Следующая процедура рассчитывает налог для указанного дохода в прогрессивной
          налоговой системе с контрольными точками для 10000, 20000, 30000 долларов.])

      (include-src "src/scheme/getting_started.scm" 396 407)

      (p [В этом примере важен порядок выполнения тестов - слева направо (сверху вниз).])

      (subsection :title "Упражнение"
         (p [Определите предикат ,(var "atom?"), который возвращает истину, если его аргумент не пара и ложь в обратном случае.]))
      (subsection :title "Упражнение"
         (p [Процедура ,(var "length") возвращает длину своего аргумента, который должен быть списком. Например, ,(var "(length '(a b c))")
     это 3. Используя ,(var "length"), определите процедуру ,(var "shorter"), возвращающую кратчайший из двух списков в
     аргументах. Пусть она возвращает первый список, если длины равны.])
         (src-lite "
(shorter '(a b) '(c d e)) → (a b)
(shorter '(a b) '(c d)) → (a b)
(shorter '(a b) '(c)) → (c)")))

   (section :title [Простая рекурсия]
      (p [Мы видели, кака можно контролировать выполнение с помощью ,(var "if"), ,(var "or") и ,(var "cond"). Мы также можем выполнить выражение
          более одного раза, создав процедуру, содержащую это выражение и вызвав её несколько раз. Но что, если нам необходимо
          повторять некоторое выражение, например, для каждого элемента в списке или для каждого числа от одного до десяти? Мы
          можем сделать это с помощью рекурсии. В основе рекурсии лежит простая идея: вызов процедуры из самой этой
          процедуры. Освоение рекурсии может показаться сложным, на первых порах, однако освоившись с ней, вы получаете в своё
          распоряжение мощную силу, намного превосходящую обычные циклы.])
      (p [Рекурсивная процедура это процедура, вызывающая саму себя. Ниже представлен, возможно, самый простой вариант
          рекурсивной процедуры, которую мы назвали ,(var "goodbye").])

      (src "
(define goodbye
   (lambda ()
      (goodbye)))
(goodbye) →")

      (p [Эта процедура не принимает аргументов и просто немедленно вызывает саму себя. Здесь нет значения после → потому что
          ,(var "goodbye") никогда не вернёт управление (и результат).])
      (p [Обычно, чтобы получить практическую пользу от рекурсивной процедуры мы должны предусмотреть некое условие остановки
          рекурсии. Большинство рекурсивных процедур должно содержать по меньшей мере два базовых элемента - ,(it "базовый вариант")
          и ,(it "шаг рекурсии"). Базовый вариант останавливает процедуру, возвращая значение в случае получения некого базового
          аргумента. Шаг рекурсии описывает результат в терминах вызова этой же процедуры, примененной к новому аргументу. Чтобы
          завершить рекурсию, этот новый аргумент должен быть ближе к базовому случаю, чем предыдущий.])
      (p [Давайте рассмотрим проблему поиска длины правильного списка рекурсивным способом. Нам нужны базовый случай и шаг
          рекурсии. Логичным базовым аргументом при рекурсии по списку почти всегда будет пустой список. Длина пустого списка
          равна нулю, так что базовый случай должен возвращать ноль, если его аргументом будет пустой список. Чтобы
          последовательно приближаться к пустому списку, естественнно будет на  шаге рекурсии применять ,(var "cdr") к
          аргументу. Непустой список на один элемент длинее, чем его ,(var "cdr"), так что шаг рекурсии дает значение на единицу
          больше длины ,(var "cdr") списка.])

      (include-src "src/scheme/getting_started.scm" 409 417)

      (p [Выражение ,(var "if") проверяет не пуст ли список. Если это так, результат - ноль. Это базовый случай. Если нет, результат
          будет на единицу больше, чем длина ,(var "cdr") этого списка. Это шаг рекурсии.])
      (p [Многие реализации Scheme позволяют отслеживать выполнение процедуры, чтобы увидеть, как она работает. Например, в
          Chez Scheme одним из способов трассировки процедуры является ввод ,(var "(trace name)"), где ,(var "name") - это имя процедуры,
          которую вы определили на верхнем уровне. Если вы трассируете ,(var "length"), как определено выше, и передадите ей аргумент
          ,(var "'(a b c d)"), вы должны увидеть что-то вроде этого:])

      (src "
|(length (a b c d))
| (length (b c d))
| |(length (c d))
| | (length (d))
| | |(length ())
| | |0
| | 1
| |2
| 3
|4")

      (p [Отступами обозначен уровень глубины рекурсии; вертикальные линии визуально соотносят вызовы процедур с их
          результатами. Обратите внимание, что с каждым вызовом ,(var "length") список становится меньше, пока окончательно не станет
          ,(var "()"). Результат для ,(var "()") известен - это 0, и каждый уровень глубины добавляет к этому результату единицу.])
      (p [Давайте напишем процедуру ,(var "list-copy"), возвращающую копию своего аргумента, который должен быть списком. Именно
          новый список из заново спареных элементов (но не старых пар) старого списка. Создание копии может быть полезным,
          если исходный список или копия могут быть модифицированы с помощью ,(var "set-car!") или ,(var "set-cdr!"), о которые мы поговорим
          позже.])

      (include-src "src/scheme/getting_started.scm" 419 420)

      (p [Посмотрите, можете ли вы определить ,(var "list-copy"), прежде чем изучать определение ниже.])

      (include-src "src/scheme/getting_started.scm" 422 427)

      (p [Определение ,(var "list-copy") аналогично определению ,(var "length"). Тест в базовом случае такой же, ,(var "(null? ls)").  Значение в
          базовом случае равно ,(var "()"), а не 0, потому что мы строим список, а не число. Рекурсивный вызов такой же, но вместо
          добавления единицы, ,(var "list-copy") спаривает ,(var "car") списка-аргумента с результатом рекурсивного вызова.])
      (p [Нет причин, по которым не может быть более одного базового случая. Процедура ,(var "memv") принимает два аргумента, объект
          и список. Возвращает первый подсписок (хвост списка), чей ,(var "car") равен объекту, или ,(var "#f"), если объект не найден в
          списке. Значение ,(var "memv") может использоваться как список или как значение истинности в условном выражении.])

      (include-src "src/scheme/getting_started.scm" 429 442)

      (p [Здесь есть два условия для проверки, так что используем ,(var "cond"). Первое условие ,(var "cond") проверяет базовое
          значение ,(var "()"); ни один объект не является членом ,(var "()"), поэтому ответ ,(var "#f"). Вторая клауза проверяет, является ли
          ,(var "car") списка искомым объектом, и в этом случае возвращается список, являющийся первым хвостом, ,(var "car") которого
          содержит искомый объект. Шаг рекурсии просто продолжает обход дальше по списку.])
      (p [Также может быть более одного случая рекурсии. Как и ,(var "memv"), процедура ,(var "remv"), определенная ниже, принимает два
          аргумента, объект и список. Возвращает новый список, в котором все вхождения объекта удалены из списка.])

      (include-src "src/scheme/getting_started.scm" 444 454)

      (p [Это определение аналогично определению ,(var "memv") выше, за исключением того, что ,(var "remv") не завершает работу, когда находит
          нужный элемент в ,(var "car") списка. Выполнение продолжается, просто игнорируя элемент. Если элемент не найден в ,(var "car"),
          ,(var "remv") делает то же самое, что и ,(var "list-copy") выше: он спаривает ,(var "car") списка с результатом рекурсии.])
      (p [До сих пор рекурсия проходила только по ,(var "cdr") списка. Однако иногда полезно, чтобы процедура повторялась как на
          ,(var "cdr"), так и на ,(var "car") списка. Процедура ,(var "tree-copy"), определённая ниже, интерпретирует структуру пар как дерево, а
          не как список, где левое поддерево является ,(var "car") от пары, а правое - ,(var "cdr"). Процедура совершает схожие с
          ,(var "list-copy") операции, образуя новые пары, но оставляя старые элементы (листья).])

      (include-src "src/scheme/getting_started.scm" 456 463)

      (p [Естественным базовым аргументом для древовидной структуры является все, что не является парой, поскольку рекурсия
          проходит через пары, а не списки. В этом случае рекурсивный шаг вдвойне рекурсивен, рекурсивно находит значение для
          ,(var "car"), а также ,(var "cdr") аргумента.])
      (p [На этом этапе читатели, знакомые с другими языками, которые предоставляют специальные итерационные конструкции,
          например циклы ,(var "while") или ,(var "for"), могут задаться вопросом, требуются ли подобные конструкции в Scheme. Такие
          конструкции не нужны; итерация в Scheme выражается более ясно и лаконично через рекурсию. Рекурсия носит более общий
          характер и устраняет необходимость назначения переменных, требуемых итерационными конструкциями многих других
          языков, в результате чего получается более надежный и понятный код. Некоторая рекурсия по сути является итерацией и
          выполняется таким же образом; Раздел 3.2 может сказать больше об этом. Однако зачастую нет необходимости проводить
          различие. Вместо этого сконцентрируйтесь на написании ясных, кратких и правильных программ.])
      (p [Прежде чем мы оставим тему рекурсии, давайте рассмотрим специальную форму повторения, называемую ,(it "отображением").
          Рассмотрим следующую процедуру ,(var "abs-all"), которая принимает список чисел в качестве входных данных и возвращает
          список их абсолютных значений.])

      (include-src "src/scheme/getting_started.scm" 465 472)

      (p [Эта процедура формирует новый список из входного списка, применяя процедуру ,(var "abs") к каждому элементу. Мы говорим,
          что ,(var "abs-all") отображает входной список в выходной при помощи ,(var "abs"). Отображение списков через процедуры - довольно
          распространенная вещь, поэтому Scheme предоставляет процедуру ,(var "map"), которая отображает с помощью своего первого
          аргумента, процедуры, свой второй аргумент, список. Мы можем использовать ,(var "map"), чтобы определить ,(var "abs-all").])

      (include-src "src/scheme/getting_started.scm" 474 476)

      (p [Однако в действительности мы не нуждаемся в ,(var "abs-all"), поскольку соответствующее прямое применение ,(var "map") такое же
          короткое и, возможно, более понятное.])

      (include-src "src/scheme/getting_started.scm" 478 478)

      (p [Конечно, мы можем использовать ,(var "lambda") чтобы создать аргумент-процедуру для ,(var "map"), например, чтобы возводить в
          квадрат числа в списке.])

      (include-src "src/scheme/getting_started.scm" 480 481)

      (p [Мы можем отображать сразу несколько списков с помощью процедуры, имеющей столько же аргументов, например:])

      (include-src "src/scheme/getting_started.scm" 483 483)

      (p [Списки должны иметь одинаковую длину, и процедура должна принимать столько аргументов, сколько списков
          передано. Каждый элемент выходного списка является результатом применения процедуры к соответствующим элементам
          входных списков.])
      (p [Глядя на первое определение ,(var "abs-all") выше, вы должны были уже начать догадываться, ещё до изученного только что,
          как могла бы быть устроена процедура ,(var "map1") - ограниченная версия ,(var "map"), которая отображает процедуру с одним
          аргументом в одном списке.])

      (include-src "src/scheme/getting_started.scm" 485 492)

      (p [Все, что мы сделали, это заменили вызов ,(var "abs") в ,(var "abs-all") вызовом нового параметра ,(var "p"). Определение более общего
          ,(var "map") дано в разделе 5.4.])

      (subsection :title "Упраженение"
         (p [Опишите, что произойдет, если вы измените порядок аргументов ,(var "cons") в определении ,(var "tree-copy").]))
      (subsection :title "Упраженение"
         (p [Обратитесь к разделу 6.3 для описания ,(var "append") и напишите её новую версию с двумя аргументами. Что произойдет, если
             вы измените порядок аргументов в вызове ,(var "append") в пределах вашего определения ,(var "append")?]))
      (subsection :title "Упраженение"
         (p [Определите процедуру ,(var "make-list"), которая принимает неотрицательное целое число ,(var "n") и объект и возвращает новый
             список длиной ,(var "n"), каждый элемент которого является этим объектом.])

         (src-lite "(make-list 7 '()) → (() () () () () () ())")

         (p [\[Подсказка: базовый тест должен быть ,(var "(= n 0)"), а шаг рекурсии должен включать ,(var "(- n 1)"). Тогда как ,(var "()") -
               естественный базовый случай для рекурсии по спискам, 0 - естественный базовый случай для рекурсии по
               неотрицательным целым числам. Точно так же вычитание 1 является естественным способом приблизить неотрицательное
               целое число к 0.\]]))
      (subsection :title "Упраженение"
         (p [Процедуры ,(var "list-ref") и ,(var "list-tail") возвращают N-ный элемент и N-ный хвост списка соответственно.])

         (src-lite "
(list-ref '(1 2 3 4) 0) → 1
(list-tail '(1 2 3 4) 0) → (1 2 3 4)
(list-ref '(a short (nested) list) 2) → (nested)
(list-tail '(a short (nested) list) 2) → ((nested) list)")

         (p [Определите обе процедуры.]))

      (subsection :title "Упраженение"
         (p [В упражнении 2.7.2 вы использовали ,(var "length") в определении процедуры ,(var "shorter"), возвращающей кратчайший из двух
             переданных списков, или первый, если длины равны. Напишите ,(var "shorter") без использования ,(var "length"). \[Подсказка:
             определите рекурсивную процедуру-помошник ,(var "shorter?") и используйте её вместо сравнения длин списков.\]]))

      (subsection :title "Упраженение"
         (p [Все рекурсивные процедуры, показанные до сих пор, были непосредственно рекурсивными. То есть каждая процедура
             непосредственно применяет себя к новому аргументу. Также возможно написать две процедуры, которые используют друг
             друга, что приводит к косвенной рекурсии. Определите процедуры ,(var "even?") (чётно?) и ,(var "odd?") (нечётно?), каждую в
             терминах другой. \[Подсказка: что каждый должен возвращать, когда его аргумент равен 0?\]])
         (src-lite "(even? 17) → #f\n(odd? 17) → #t"))

      (subsection :title "Упраженение"
         (p [Используйте ,(var "map"), чтобы определить процедуру ,(var "transpose"), которая берет список пар и возвращает пару списков
             следующим образом.])

         (src-lite "(transpose '((a . 1) (b . 2) (c . 3))) → ((a b c) 1 2 3)")

         (p [\[Подсказка: ,(var "((a b c) 1 2 3)") это то же, что и ,(var "((a b c) . (1 2 3))").\]])))

   (section :title [Присваивания]
      (p [Хотя многие программы могут быть написаны без них, иногда полезны определения переменных верхнего уровня,
          let-связывания и lambda-связывания. ,(it "Присваивания") не создают новые связывания, как в случае ,(var "let") или ,(var "lambda"), а
          скорее изменяют значения существующих связываний. Присваивания выполняются с помощью  ,(var "set!").])

      (include-src "src/scheme/getting_started.scm" 494 500)

      (p [Многие языки требуют использования присваиваний для инициализации локальных переменных, отдельно от объявления или
          связывания переменных. В Scheme все локальные переменные получают значение сразу после связывания. Помимо
          необходимости выполнять отдельное присваивание для инициализации локальных переменных, это гарантирует, что
          программист не сможет забыть инициализировать их, что является распространенным источником ошибок в большинстве
          языков.])
      (p [Фактически, большинство назначений, которые либо необходимы, либо удобны в других языках, в Scheme как ненужны, так
          и неудобные, поскольку обычно существует более понятный способ выражения того же алгоритма без присвоений. Обычной
          практикой в некоторых языках является последовательное выполнение выражений и присваиваний, как в следующей
          процедуре, которая находит корни квадратного уравнения.])

      (include-src "src/scheme/getting_started.scm" 502 510)

      (p [Корни вычисляются по известной формуле поиска корней квадратного уравнения, ,(image :width 60 :file "images/4.png")
          что дает решения уравнения ,(it [0 = ax,(sup 2) + bx + c]). Выражение ,(var "let") в этом определении используется исключительно для
          установления привязок переменных, соответствующих объявлениям, требуемым в других языках. Первые три выражения
          присваивания вычисляют части формулы, а именно ,(it "-b"), ,(image :width 60 :file "images/5.png") и ,(it "2а").
          Последние два выражения присваивания вычисляют два корня. Пара из двух корней является результатом вычисления
          квадратичной формулы. Например, два корня ,(it [2x,(sup 2) - 4x - 6]) - это x = 3 и x = -1.])

      (include-src "src/scheme/getting_started.scm" 512 512)

      (p [Вышеприведенное определение работает, но оно может быть написано более четко без присвоений, как показано ниже.])

      (include-src "src/scheme/getting_started.scm" 514 521)

      (p [В этой версии ,(var "set!") выражения ушли, и у нас остался по сути тот же алгоритм. Однако, используя два выражения ,(var "let"),
          определение яснее показывает зависимость ,(var "root1") и ,(var "root2") от значений ,(var "minusb"), ,(var "radius") и ,(var "divisor"). Не менее
          важно, что выражения let ясно показывают отсутствие зависимостей между собой для ,(var "minusb"), ,(var "radical") и ,(var "divisor"), а
          также между ,(var "root1") и ,(var "root2").])
      (p [Присвоения действительно имеют определённые применения в Scheme, иначе язык бы их не поддерживал. Рассмотрим
          следующую версию ,(var "cons"), которая подсчитывает количество её вызовов, сохраняя счетчик в переменной с именем
          ,(var "cons-count"). Здесь используется ,(var "set!") чтобы увеличить счетчик; нет способа добиться того же поведения без
          использования подобного рода присвоений.])

      (include-src "src/scheme/getting_started.scm" 523 532)

      (p [Присвоения обычно используются для реализации процедур, которые должны поддерживать некоторое внутреннее
          состояние. Например, предположим, что мы хотим определить процедуру, которая возвращает 0 в первый раз, когда она
          вызывается, 1 во второй раз, 2 в третий раз и так далее до бесконечности. Мы могли бы написать что-то похожее на
          определенный выше ,(var "cons-count"):])

      (include-src "src/scheme/getting_started.scm" 534 542)

      (p [Это решение несколько нежелательно в том смысле, что переменная ,(var "next") видна на верхнем уровне, даже если это не
          обязательно. Так как она видна на верхнем уровне, любой код в системе может изменить её значение, возможно,
          непреднамеренно повлиять на поведение счетчика неявным образом. Мы можем решить эту проблему с помощью
          let-связывания вне лямбда-выражения:])

      (include-src "src/scheme/getting_started.scm" 544 549)

      (p [Последнее решение также легко обобщается для предоставления нескольких счетчиков, каждый из которых имеет свой
          собственный локальный счетчик. Процедура ,(var "make-counter"), определенная ниже, возвращает новую процедуру подсчета
          каждый раз, когда она вызывается.])

      (include-src "src/scheme/getting_started.scm" 551 557)

      (p [Поскольку ,(var "next") связывается внутри ,(var "make-counter"), но вне процедуры, возвращаемой ,(var "make-counter"), каждая
          возвращаемая процедура использует свой уникальный счетчик.])

      (include-src "src/scheme/getting_started.scm" 559 566)

      (p [Если переменная состояния должна совместно использоваться более чем одной процедурой, определенной на верхнем уровне,
         но мы не хотим, чтобы переменная состояния была видимой на верхнем уровне, мы можем использовать ,(var "let"), чтобы связать
         переменную и ,(var "set!") сделать процедуры видимыми на верхнем уровне.])

      (include-src "src/scheme/getting_started.scm" 568 580)

      (p [Переменные должны быть определены до того, как им будет присвоено значение, поэтому мы вначале определяем ,(var "shhh") и
          присваиваем ему ,(var "#f") (подойдет любое начальное значение). Мы увидим эту структуру снова в Разделе 3.5, а лучший
          способ структурировать подобный код как библиотеку в Разделе 3.6.])
      (p [Локальное состояние иногда полезно для кэширования вычисленных значений, а так же позволяет производить ленивые
          вычисления, т. е. производить вычисления только один раз и только по требованию. Процедура ,(var "lazy") ниже принимает
          чанк (англ. thunk), процедуру нулевой арности, в качестве аргумента. Чанки часто используются для «замораживания»
          вычислений, которые по какой-то причине должны быть отложены, что в точности то, что нам нужно в данной
          ситуации. При передаче чанка ,(var "t"), ,(var "lazy") возвращает новый чанк, который при вызове возвращает значение вызова
          ,(var "t"). Единожды вычисленое, значение сохраняется в локальной переменной, так что вычисление больше не
          требуется. Логический флаг используется для записи того, был ли вычислен ,(var "t") и сохранено ли его значение.])

      (include-src "src/scheme/getting_started.scm" 582 589)

      (p [Синтаксическая форма ,(var "begin"), используемая здесь впервые, выполняет свои подвыражения в последовательности слева
          направо и возвращает значение последнего подвыражения, как тело выражения ,(var "let") или лямбда-выражения. Мы также
          видим, что альтернативное подвыражение выражения ,(var "if") может быть опущено. Это должно быть сделано только тогда,
          когда значение ,(var "if") отбрасывается, как в этом случае.])
      (p [Ленивые вычисления особенно полезны для значений, которые требуют значительного времени для рассчёта. Откладывая
          вычисление, мы можем избежать рассчёта значения в целом, а сохраняя результат, мы избегаем вычисления его более
          одного раза.])
      (p [Функционирование ,(var "lazy") может быть лучше всего проиллюстрирована выводом сообщения из чанка, переданного в
          ,(var "lazy") в качестве аргумента.])

      (include-src "src/scheme/getting_started.scm" 591 595)

      (p [При первом вызове ,(var "p")  печатается сообщение ,(var "\"Ouch!\"") , и возвращается строка ,(var "\"got me\"") . Последующие вызовы
          возвращают ,(var "\"got me\"") , но сообщение не печатают. Процедуры ,(var "display") и ,(var "newline") - это первые примеры явного
          ввода/вывода, которые мы видели; ,(var "display") выводит строку без кавычек, а ,(var "newline")  печатает символ новой строки.])
      (p [Чтобы дополнительно проиллюстрировать использование ,(var "set!"), давайте рассмотрим реализацию объектов стека, внутренняя
          работа которых не видна снаружи. Объект стека принимает одно из четырех сообщений: ,(var "empty?"), которое возвращает
          ,(var "#t"), если стек пуст; ,(var "push!"), который добавляет объект на вершину стека; ,(var "top"), который возвращает объект с
          вершины стека; и ,(var "pop!"), который удаляет объект сверху стека. Приведенная ниже процедура ,(var "make-stack") создает новый
          стек каждый раз, когда она вызывается, аналогично ,(var "make-counter").])

      (include-src "src/scheme/getting_started.scm" 597 606)

      (p [Каждый стек хранится в виде списка, привязанного к переменной ,(var "ls"); ,(var "set!") используется для изменения этой привязки
          в ,(var "push!") и ,(var "pop!"). Обратите внимание, что список аргументов внутреннего лямбда-выражения использует синтаксис
          неправильного списка для связывания всех аргументов, кроме первого, со списком. Это полезно здесь, потому что в
          случае ,(var "empty?"), ,(var "top") и ,(var "pop!") есть только один аргумент (сообщение), но в случае ,(var "push!") их два (сообщение и
          объект, который нужно поместить в стек).])

      (include-src "src/scheme/getting_started.scm" 608 625)

      (p [Как и в случае счетчиков, созданных ,(var "make-counter"), состояние, используемое каждым объектом стека, напрямую доступно
          только внутри объекта. Каждый доступ или изменение этого состояния выполняется явно самим объектом. Одним из важных
          преимуществ является то, что мы можем изменить внутреннюю структуру стека, например, использовав вектор (см. Раздел
          6.9) вместо списка для хранения элементов без изменения его внешнего поведения. Поскольку поведение объекта известно
          абстрактно (не операционно), он считается абстрактным объектом. Смотри раздел 12.8 для получения дополнительной
          информации о создании абстрактных объектов.])
      (p [Помимо изменения значений переменных, мы также можем изменять значения полей пар ,(var "car") и ,(var "cdr"), используя процедуры
          ,(var "set-car!") и ,(var "set-cdr!").])

      (include-src "src/scheme/getting_started.scm" 627 631)

      (p [Мы можем использовать эти операторы для определения типа данных 'очередь', который похож на стек, за исключением
          того, что новые элементы добавляются на одном конце и извлекаются из другого. Следующая реализация очереди
          использует структуру ,(var "tconc"). ,(var "tconc") состоит из непустого списка и заголовка. Заголовок - это пара, ,(var "car") которой
          указывает на первую пару (заголовок) списка, а ,(var "cdr") указывает на последнюю пару (конец) списка.])

      (p (center (image :file "images/6.png" :width 250)))

      (p [Последний элемент списка является заполнителем и не считается частью очереди.])
      (p [Ниже приведены четыре операции с очередями: ,(var "make-queue"), которая создает очередь; ,(var "putq!") , которая добавляет
          элемент в конец очереди; ,(var "getq"), которая извлекает элемент в начале очереди; и ,(var "delq!"), который удаляет элемент из
          начала очереди.])

      (include-src "src/scheme/getting_started.scm" 633 651)

      (p [Все это простые операции, кроме ,(var "putq!"), которая изменяет конечную пару, чтобы она содержала новое значение, и
          добавляет новую конечную пару.])

      (include-src "src/scheme/getting_started.scm" 653 665)

      (subsection :title "Упражнение"
         (p [Измените ,(var "make-counter") так, чтобы он принимал два аргумента: начальное значение для счетчика, которое будет
            использоваться вместо 0, и значение, на которое счетчик увеличивается каждый раз.]))
      (subsection :title "Упражнение"
         (p [Посмотрите описание случая в разделе 5.3. Замените выражение ,(var "cond") в ,(var "make-stack") на эквивалентное выражение
             ,(var "case"). Добавить ,(var "mt?") как второе имя для сообщения ,(var "empty?").]))
      (subsection :title "Упражнение"
         (p [Измените объект стека, чтобы разрешить два сообщения ,(var "ref") и ,(var "set!"). ,(var "(stack 'ref i)") должен возвращать i-й элемент
             от верхушки стека; ,(var "(stack 'ref 0)") должен быть эквивалентен ,(var "(stack 'top)"). ,(var "(stack 'set! i v)") должен изменить
             i-й элемент с вершины стека на v.])
         (src-lite "
(define stack (make-stack))

(stack 'push! 'a)
(stack 'push! 'b)
(stack 'push! 'c)

(stack 'ref 0) → c
(stack 'ref 2) → a
(stack 'set! 1 'd)
(stack 'ref 1) → d
(stack 'top) → c
(stack 'pop!)
(stack 'top) → d")
         (p [\[Подсказка: используйте ,(var "list-ref") для реализации ,(var "ref") и ,(var "list-tail") с ,(var "set-car!") чтобы реализовать ,(var "set!").\]]))
      (subsection :title "Упражнение"
         (p [Scheme поддерживает также векторы, как и списки. Как и списки, векторы являются собирательными объектами, которые
             содержат другие объекты. В отличие от списков, векторы имеют фиксированный размер и располагаются в одном плоском
             блоке памяти, обычно с заголовком, содержащим длину вектора, как в векторе из десяти элементов ниже.])
         (p (center (image :file "images/7.png" :width 250)))
         (p [Это делает векторы более подходящими для приложений, нуждающихся в быстром доступе к любому элементу
             последовательности, но менее подходящими для приложений, которым требуются структуры данных, которые растут и
             сжимаются по мере необходимости.])
         (p [Посмотрите основные векторные операции в Разделе 6.9 и переопределите объект стека, чтобы использовать вектор
             вместо списка для хранения содержимого стека. Добавьте ,(var "ref") и ,(var "set!") сообщения из упражнения 2.9.3. Пусть новый
             ,(var "make-stack") принимает аргумент размера ,(var "n") и задает длину вектора ,(var "n"), но никак иначе не изменяет внешний
             (абстрактный) интерфейс.]))
      (subsection :title "Упражнение"
         (p [Определите предикат ,(var "emptyq?"), определяющий, пуста ли очередь. Измените ,(var "getq") и ,(var "delq!") так, чтобы вызвать
             исключение при обнаружении пустой очереди, используя ,(var "assertion-violation").]))
      (subsection :title "Упражнение"
         (p [В реализации очереди последняя пара в инкапсулированном списке является заполнителем, то есть никогда не содержит
             ничего полезного. Перепишите операторы очереди, чтобы избежать этой потраченной впустую пары. Убедитесь, что серия
             операций с очередями, приведенная ранее, работает с новой реализацией. Какую реализацию вы бы предпочли?]))
      (subsection :title "Упражнение"
         (p [Используя ,(var "set-cdr!"), можно создавать циклические списки. Например, следующее выражение возвращает список, ,(var "car")
             которого является символ ,(var "a"), а ,(var "cdr") является самим списком.])
         (src-lite "
(let ([ls (cons 'a '())])
  (set-cdr! ls ls)
  ls)")
         (p [Что произойдёт, если вы введёте вышеприведенное выражение во время интерактивного сеанса Scheme? Что будет делать
             реализация ,(var "length") из раздела 2.8, если ей передать циклический список? Как поведёт себя встроенный примитив
             ,(var "length")?]))
      (subsection :title "Упражнение"
         (p [Определите предикат ,(var "list?"), который возвращает ,(var "#t"), если его аргумент является правильным списком, и ,(var "#f") в
             противном случае (см. Раздел 6.3). Он должен возвращать ,(var "#f") для циклических списков, а также для списков,
             оканчивающихся объектами, отличными от ,(var "()").])
         (src-lite "
(list? '()) → #t
(list? '(1 2 3)) → #t
(list? '(a . b)) → #f
(list? (let ([ls (cons 'a '())])
         (set-cdr! ls ls)
         ls)) → #f")
         (p [Сначала напишите упрощенную версию ,(var "list?") которая не обрабатывает случай с циклическими списки, а затем расширьте
             её для правильной обработки циклических списков. Пересматривайте свое определение, пока не убедитесь, что оно
             максимально четкое и краткое. \[Подсказка: используйте следующий алгоритм "заяц и черепаха" для определения
             цикличных списков. Определите рекурсивную вспомогательную процедуру с двумя аргументами: заяц и черепаха. Запустите
             зайца и черепаху в начале списка. Сделайте так, чтобы заяц продвигался на два ,(var "cdr") каждый раз,
             когда черепаха продвигается на один ,(var "cdr"). Если заяц ловит черепаху, значит это цикл.\]]))))
