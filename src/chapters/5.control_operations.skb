;;; -*- coding: utf-8; tab-width: 4; c-basic-offset: 2; indent-tabs-mode: nil; fill-column: 120; -*-

(chapter :title "Управляющие структуры"
   (chapter-image "images/ch5.png")
   (p [В этой главе представлены синтаксические формы и процедуры, которые служат в качестве управляющих структур для программ Scheme.
       Первый раздел охватывает самую базовую структуру управления, применение процедуры, а остальные разделы охватывают последовательное и
       условное выполнение, рекурсию, отображение (mapping), продолжения, отложенные вычисления (delayed evaluation), множественные значения
       и выполнение программ, созданных во время выполнения.])

   (section :title [Применение процедуры]
      (formdef
      :syntax "(expr0 expr1 ...)"
      :returns "значение(я), как результат применения результата вычисления expr0 к результату вычисления expr1 ...")
      (p [Применение процедуры - самая базовая управляющая структура в Scheme. Любая составная форма, у которой в первой позиции не
          стоит синтаксическое ключевое слово, это применение процедуры. Выражения ,(var "expr0, expr1 ...") вычисляются, каждое должно быть
          вычислено в единственное значение. После того, как каждое из этих выражений вычислено, результат вычисления ,(var "expr0") применяется
          к результатам вычисления ,(var "expr1 ..."). Если expr0 вычисляется не в процедуру, или в процедуру с количеством аргементов, отличным
          от представленного, возбуждается исключение типа ,(var "&assertion").])
      (p [Порядок, в котором вычисляются выражения процедуры и аргумента, не указан. Он может быть слева направо, справа налево или в любом
          другом порядке. Однако гарантируется, что вычисление будет последовательным: какой бы порядок ни был выбран, каждое выражение
          должно быть полностью вычислено до начала вычисления следующего.])
      (include-src "src/scheme/5.control_operations.scm" "#|+procedure-application-1|#")

      (formdef
      :syntax "(apply procedure obj ... list)"
      :returns "значение(я), как результат применения procedure к obj ... и элементам списка list"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "apply") выполняет процедуру ,(var "procedure"), передавая первый объект ,(var "obj") в качестве первого аргумента,
          второй в качестве второго и так далее, для каждого объекта из ,(var "..."), а элементы из ,(var "list") добавляются к
          списку аргументов в порядке, в котором они находятся в списке. Таким образом, процедура вызывается с таким количеством
          аргументов, сколько есть объектов плюс элементы списка.])
      (p [,(var "apply") полезен, когда некоторые или все аргументы, которые должны быть переданы процедуре, находятся в списке,
          поскольку он освобождает программиста от явного деструктурирования списка.])
      (include-src "src/scheme/5.control_operations.scm" "#|+procedure-application-2|#"))

   (section :title [Последовательное выполнение]
      (formdef
      :syntax "(begin expr1 expr2 ...)"
      :returns "результат(ы) вычисления последнего подвыражения"
      :libraries "(rnrs base), (rnrs)")
      (p [Выражения ,(var "expr1 expr2 ...") выполняются последовательно слева направо. ,(var "begin") используется для упорядочивания
          присваиваний, операций ввода/вывода и других операций с побочными эффектами.])
      (include-src "src/scheme/5.control_operations.scm" "#|+sequencing-1|#")
      (p [,(var "begin") может содеждать ноль и более объявлений на местах выражений ,(var "expr1 expr2 ..."), тогда эти объявления
          учитываются и считаются действительными в области их действия.])
      (include-src "src/scheme/5.control_operations.scm" "#|+sequencing-2|#")
      (p [Подобным образом ,(var "begin") используется в основном в расширениях синтаксиса, которые должны раскрыться в несколко объявлений.
          (,(ref :text "см." :ident "variable-definitions-2" :page #t))])
      (p [Тела многих синтаксических форм, таких как ,(var "lambda"), ,(var "case-lambda"), ,(var "let"), ,(var "let*"), ,(var "letrec"),
          ,(var "letrec*"), так же как и клаузы результата в ,(var "cond"), ,(var "case"), и ,(var "do") обрабатываются, как будто они неявно
          заключены в ,(var "begin") т.е. выражения, составляющие тело, или результирующую клаузу выполняются последовательно, а значение
          последнего выражения возвращается в качестве результата]))

   (section :title [Условия]
      (formdef
      :syntax '("(if test consequent alternative)"
                "(if test consequent)")
      :returns "результат(ы) вычисления выражения consequent или выражения alternative в зависимости от результата вычисления test"
      :libraries "(rnrs base), (rnrs)")
      (p [Формы ,(var "test"), ,(var "consequent"), и ,(var "alternative") должны быть выражениями. Если ,(var "test") вычисляется в истину
         (что угодно, кроме #f), то вычисляется выражение ,(var "consequent") и возвращается его результат. Иначе, вычисляется
          ,(var "alternative") и результат этого вычисления возвращается как результат. Для второй, "однорукой", формы, не имеющей ,(var "alternative"),
          возвращаемый результат не определён, если тест вычислился в ложь.])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-1|#")

      (formdef
      :syntax "(not obj)"
      :returns "#t если obj это ложь, иначе #f"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "not") это эквивалент ,(code "(lambda (x) (if x #f #t))").])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-2|#")

      (formdef
      :syntax "(and expr ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Если подвыражения отсутствуют, то форма ,(var "and") вычисляется в ,(var "#t"). В ином случае, подвыражения вычисляются
          последовательно слева направо до тех пор, пока не останется только одно подвыражение или одно из подвыражений не вернёт ,(var "#f").
          Если осталось только одно подвыражение, оно вычисляется и результат его вычисления возвращается в качестве результата.
          Если подвыражение вернуло ,(var "#f"), то всё выражение ,(var "and") возвращает ,(var "#f"), не производя вычисления оставшихся
          подвыражений. Определение синтаксиса ,(var "and") приведено на ,(ref :text "стр." :ident "and-1" :page #t)])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-3|#")

      (formdef
      :syntax "(or expr ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Если подвыражения отсутствуют, то форма ,(var "or") вычисляется в ,(var "#f"). В ином случае, подвыражения вычисляются
          последовательно слева направо до тех пор, пока не останется только одно подвыражение или одно из подвыражений не вернёт
          нечто отличное от ,(var "#f"). Если осталось только одно подвыражение, оно вычисляется и результат его вычисления возвращается
          в качестве результата. Если подвыражение вернуло значение, отличное от ,(var "#f"), то всё выражение ,(var "or") возвращает это значение,
          не производя вычисления оставшихся подвыражений. Определение синтаксиса ,(var "or") приведено на ,(ref :text "стр." :ident "or-1" :page #t)])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-4|#")

      (formdef
      :syntax "(cond clause1 clause2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Каждая клауза, кроме последней, должна иметь одну из следующих форм:])
      (src "(test)
(test expr1 expr2 ...)
(test => expr)")
      (p [Последняя клауза может иметь одну из представленых выше форм, либо это может быть else-клауза следующей формы:])
      (src-lite "(else expr1 expr2 ...)")
      (p [Каждый ,(var "test") вычисляется по порядку, до тех пор пока один из них не вычислится в истину, либо пока не будут вычислены все.
          Если первая клаузка, тест которой вычислился в истину, имеет первую из представленных выше форм, то результат вычисления теста возвращается
          в качестве результата вычисления всего выражения.])
      (p [Если первая клаузка, тест которой вычислился в истину, имеет вторую из представленных выше форм, то выражения ,(var "expr1 expr2 ...")
          вычисляются по порядку и значение последнего выражения возвращается в качестве результата.])
      (p [Если первая клаузка, тест которой вычислился в истину, имеет третью из представленных выше форм, то выражение ,(var "expr") вычисляется.
          Выражение должно представлять из себя процедуру от одного аргумента, которая будет применена к результату вычисления выражения ,(var "test").
          Результат этого применения возвращается в качестве результата.])
      (p [Если не один из тестов не вычислился в истину и else-клауза присутствует, то выражения ,(var "expr1 expr2 ...")
          из else-клаузы вычисляются по порядку и значение последнего выражения возвращается в качестве результата.])
      (p [Если не один из тестов не вычислился в истину и else-клауза отсутствует, возвращаемое значение не определено.])
      (p [На ,(ref :text "стр." :section "syntax-case преобразователи" :page #t) вы найдёте определение синтаксиса ,(var "cond")]) ;;TODO: :ident "cond-1"
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-5|#")

      (formdef
      :syntax '("else"
                "=>")
      :returns ""
      :libraries "(rnrs base), (rnrs)")
      (p [Эти идентификаторы являются вспомогательными ключевыми словами для cond. Оба они также служат вспомогательными ключевыми словами
          для охранных выражений (guards), а также служат вспомогательными ключевыми словами для case. Упоминание этих идентификаторов является
          нарушением синтаксиса, за исключением случаев, когда они распознаются как вспомогательные ключевые слова.])

      (formdef
      :syntax '("(when test-expr expr1 expr2 ...)"
                "(unless test-expr expr1 expr2 ...)")
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Для ,(var "when"), если ,(var "test-expr") вычисляется в истину, выражения ,(var "expr1 expr2 ...") вычисляются последовательно
          и значение последнего выражения возвращается в качестве результата. Если ,(var "test-expr") вычисляется в ложь, то не одно другое
          выражение не вычисляется и возвращаемый результат всего выражения не определён.])
      (p [Для ,(var "unless"), если ,(var "test-expr") вычисляется в ложь, выражения ,(var "expr1 expr2 ...") вычисляются последовательно
          и значение последнего выражения возвращается в качестве результата. Если ,(var "test-expr") вычисляется в истину, то не одно другое
          выражение не вычисляется и возвращаемый результат всего выражения не определён.])
      (p [Выражения ,(var "when") и ,(var "unless") обычно используются как более понятные альтернативы 'одноруким' выражениям ,(var "if").])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-6|#")
      (p [,(var "when") может быть определён следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'when)
      (p [,(var "unless") может быть определён следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'unless)
      (p [либо в терминах ,(var "when"), как показано ниже:])
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-7|#")

      (formdef
      :syntax "(case expr0 clause1 clause2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Все клаузы, кроме последней, должны иметь следующий вид:])
      (src-lite "((key ...) expr1 expr2 ...)")
      (p [где каждый ключ является объектом данных (datum), отличным от других ключей. Последняя клауза может иметь такой-же вид,
          как описано выше, или это может else-клауза вида:])
      (src-lite "(else expr1 expr2 ...)")
      (p [,(var "expr0") вычисляется и сравнивается (с помощью ,(var "eqv?")) с ключами каждой клаузы по порядку. Если клауза, содержащая
          совпадающий ключ найдена, выражения ,(var "expr1 expr2 ...") вычисляются по порядку и значение последнего возвращается в качестве
          результата.])
      (p [Если не одна из клауз не содержит совпадающий ключ и else-клауза присутствует, то выражения ,(var "expr1 expr2 ...")
          из else-клаузы вычисляются по порядку и значение последнего выражения возвращается в качестве результата.])
      (p [Если не одна клауза не содержит совпадающий ключ и else-клауза отсутствует, возвращаемое значение не определено.])
      (p [На ,(ref :text "стр." :section "syntax-case преобразователи" :page #t) вы найдёте определение синтаксиса ,(var "case")]) ;;TODO: :ident "case-1"?
      (include-src "src/scheme/5.control_operations.scm" "#|+conditionals-8|#"))

   (section :title [Рекурсия и итерация]
      (formdef
      :syntax "(let name ((var expr) ...) body1 body2 ...)"
      :returns "значение(я) вычисления последнего выражения body"
      :libraries "(rnrs base), (rnrs)")
      (p [Эта форма let, называемая именованый-let, является конструкцией для итерации и рекурсии общего назначения. Она так же,
          как и обычная let (см. ,(ref :text "Глава 4.4 " :section "Локальные связывания")) связывает переменные ,(var "var ...") со значениями
          ,(var "expr ...") в пределах тела ,(var "body1 body2 ..."), которое обрабатывается и вычисляется как тело лямбда-выражения. В дополнение к этому,
          в теле выражения происходит связывание переменной ,(var "name") которая может быть вызвана для рекурсии или итерации; аргументами
          процедуры выступают новые значения переменных ,(var "var ...")])
      (p [Именованый let вида])
      (src-lite "(let name ((var expr) ...)
  body1 body2 ...)")
      (p [может быть выражен через ,(var "letrec") следующим образом:])
      (src-lite "((letrec ((name (lambda (var ...) body1 body2 ...)))
   name)
 expr ...)")
      (p [Синтаксическое определение let, реализующее данные преобразования и так-же поддерживающее неименованый вариант
          let  может быть найдено на ,(ref :text "стр. " :section "Примеры" :page #t)]) ;;TODO: :ident "let-4"?
      (p [Процедура divisors определённая ниже использует именованый let для вычисления нетривиальных делителей для
          неотрицательного целого числа.])
      (include-src "src/scheme/5.control_operations.scm" "#|+iterations-1|#")
      (p [Версия выше не имеет хвостовой рекурсии, когда делитель найден, и имеет хвостовую рекурсию, пока не
          найден. Версия ниже реализует хвостовую рекурсию полностью. Список строится в обратном порядке, но при желании
          это легко исправить, перевернув список при выходе.])
      (include-src "src/scheme/5.control_operations.scm" :definition 'divisors)

      (formdef
      :syntax "(do ((var init update) ...) (test result ...) expr ...)"
      :returns "значение(я) последнего вычисления result"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "do") позволяет лаконично выразить общую форму итерации. В начале переменные ,(var "var ...")
          связываются со значениями ,(var "init ...") и обновляются в каждой последующией итерации значениями ,(var
          "update ..."). Выражения ,(var "test"), ,(var "update ..."), ,(var "expr ..."), и ,(var "result ...") все
          находятся в области действия переменных, объявленных в ,(var "var ...")])

      (p [На каждом шаге вычисляется тестовое выражение ,(var "test"). Если тест вычислился в истину, итерация
          прекращается, выражения ,(var "result ...") последовательно вычисляются и значение последнего выражения
          возвращается в качестве результата. Если форма ,(var "result") не была задана, то возвращаемое всем
          выражением ,(var "do") значение не определено.])
      (p [Если результат теста ложен, то последовательно выполняются выражения ,(var "expr ..."), затем вычисляются выражения обновления
          ,(var "update ..."), результаты которых связываются с ,(var "var ...") и итерация продолжается.])
      (p [Выражения ,(var "expr ...") выполняются только с целью побочных эффектов и часто полностью опускаются. Любое выражение
          обновления (update) может быть опущено, и в этом случае эффект будет таким же, как если бы ,(var "update") было
          просто соответствующей переменной.])
      (p [Хотя конструкции цикла в большинстве языков требуют, чтобы итеранты цикла обновлялись посредством
          присваивания, ,(var "do") требует, чтобы итеранты цикла ,(var "var ...") обновлялись посредством повторной
          привязки. Фактически, при вычислении выражения ,(var "do") не задействуются побочные эффекты, если только они
          не выполняются явно его подвыражениями.])
      (p [Определение синтаксиса ,(var "do") смотри на ,(ref :text "стр. " :section "Примеры" :page #t)]) ;;TODO: :ident "do-1"?
      (p [Приведенные ниже определения ,(var "factorial") и ,(var "fibonacci") являются прямым переводом хвостовой
          рекурсивной версии именованой-let из ,(ref :text "Главы 3.2" :section "Больше о рекурсии")])
      (include-src "src/scheme/5.control_operations.scm" "#|+iterations-2|#")
      (p [Определение ,(var "divisors"), приведенное ниже, аналогично определению ,(var "divisors") с хвостовой
          рекурсией, приведенному выше с при описании именованого-let.])
      (include-src "src/scheme/5.control_operations.scm" "#|+iterations-3|#")
      (p [Определение ,(var "scale-vector!") ниже, где каждый элемент вектора ,(var "v") умножается на ,(var "k"),
          демонстрируется непустое тело ,(var "do").])
      (include-src "src/scheme/5.control_operations.scm" "#|+iterations-4|#"))

   (section :title "Отображения и свёртки"
      (p [Когда программа должна рекурсивно пройти или итерировать элементы списка, часто удобнее использовать оператор
          отображения или свёртки. Эти операторы абстрагируются от проверок конца списка и явной рекурсии, применяя
          процедуру к элементам списка один за одним. Также доступно несколько операторов отображения для векторов и
          строк.])

      (formdef
      :syntax "(map procedure list1 list2 ...)"
      :returns "список результатов"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "map") применяет процедуру ,(var "procedure") к соответствующим элементам из списков ,(var "list1 list2 ...") и
          возвращает список результатов. Списки ,(var "list1 list2 ...") должны быть одинаковой длины. Процедура должна
          принимать столько аргументов, сколько списков передано, возвращать единственное значение и не изменять аргументы.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-1|#")
      (p [Хотя порядок, в котором происходят применение само по себе, не указан, порядок значений в выходном списке
          такой же, как и у соответствующих значений во входных списках.])
      (p [,(var "map") может быть определена следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'map)
      (p [В этой версии map проверка ошибок не выполняется; Предполагается, что f является процедурой, а другие
          аргументы - правильными списками одинаковой длины. Интересной особенностью этого определения является то, что map
          использует себя для извлечения голов (car) и хвостов (cdr) из списка входных списков, это работает из-за
          особой обработки случая с одним списком.])

      (formdef
      :syntax "(for-each procedure list1 list2 ...)"
      :returns "не определено"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "for-each") похож на ,(var "map"), за исключением того, что ,(var "for-each") не создает и не возвращает
          список результирующих значений, и ,(var "for-each") гарантирует выполнение применений последовательно по элементам
          слева направо. ,(var "procedure") должна принимать столько аргументов, сколько передано списков, и не должна
          изменять аргументы списка. ,(var "for-each") можно определить без проверки ошибок следующим образом.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-2|#")

      (formdef
      :syntax "(exists procedure list1 list2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Списки ,(var "list1 list2 ...") должны быть одной длины, процедура должна принимать столько же аргументов,
          сколько списков передано, процедура не должна модифицировать свои аргументы. Если списки пусты, возвращается ,(var
          "#f"). Иначе, ,(var "exists") последовательно применяет процедуру (procedure) к соответствующим элементам списков ,(var
          "list1 list2 ...") до тех пор, пока либо в каждом из списков не останется только один элемент, либо процедура не
          вернет истинное значение ,(var "#t"). В первом случае, ,(var "exists") продолжит применение процедуры к оставшимся
          элементам путём хвостовой рекурсии, во втором же случае ,(var "exists") вернёт ,(var "#t")])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-3|#")
      (p [,(var "exists") может быть определена (несколько неэффективно и без обработки ошибок) следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'exists)

      (formdef
      :syntax "(for-all procedure list1 list2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Списки ,(var "list1 list2 ...") должны быть одной длины, процедура должна принимать столько же аргументов,
          сколько списков передано, процедура не должна модифицировать свои аргументы. Если списки пусты, возвращается ,(var
          "#t"). Иначе, ,(var "for-all") последовательно применяет процедуру (procedure) к соответствующим элементам списков ,(var
          "list1 list2 ...") до тех пор, пока либо в каждом из списков не останется только один элемент, либо процедура не
          вернет ,(var "#f"). В первом случае, ,(var "for-all") продолжит применение процедуры к оставшимся
          элементам путём хвостовой рекурсии, во втором же случае ,(var "for-all") вернёт ,(var "#f")])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-4|#")
      (p [,(var "for-all") может быть определена (несколько неэффективно и без обработки ошибок) следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'for-all)

      (formdef
      :syntax "(fold-left procedure obj list1 list2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Списки ,(var "list1 list2 ...") должны быть одной длины, процедура должна принимать аргументов на один больше, чем
          количество переданых списков и возвращать единственное значение, процедура не должна модифицировать элементы списков.])
      (p [,(var "fold-left") возвращает ,(var "obj"), если аргументы-списки пусты. Если не пусты, ,(var "fold-left")
          применяет процедуру к ,(var "obj") и головам (,(var "car")) списков ,(var "list1 list2 ..."), а затем рекурсивно повторяет
          вызов с результатом вычисления ,(var "procedure") вместо ,(var "obj") и с хвостами (,(var "cdr")) списков,
          вместо самих списков.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-5|#")

      (formdef
      :syntax "(fold-right procedure obj list1 list2 ...)"
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Списочные аргументы должны иметь одинаковую длину. procedure должна принимать на один аргумент больше, чем
          кол-во переданых списков и возвращать единственное значение, а так же не должна модифицировать переданые
          списки.])
      (p [,(var "fold-left") возвращает ,(var "obj"), если аргументы-списки пусты. Если не пусты, ,(var "fold-left")
          применяет процедуру к головам (,(var "car")) списков ,(var "list1 list2 ...") и ,(var "obj"), а затем рекурсивно повторяет
          вызов с результатом вычисления ,(var "procedure") вместо ,(var "obj") и с хвостами (,(var "cdr")) списков,
          вместо самих списков.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-6|#")

      (formdef
      :syntax "(vector-map procedure vector1 vector1 ...)"
      :returns "вектор результатов"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "vector-map") применяет ,(var "procedure") к соответствующим элементам из ,(var "vector1 vector2 ...") и возвращает вектор
          результатов. Векторы ,(var "vector1 vector2 ...") должны быть одной длины, процедура должна принимать столько
          аргументов, сколько векторов было передано в аргументах и возвращать единственное значение.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-7|#")
      (p [Хотя порядок, в котором происходят применение само по себе, не указан, порядок значений в выходном векторе
          такой же, как и у соответствующих значений во входных векторах.])

      (formdef
      :syntax "(vector-for-each procedure vector1 vector2 ...)"
      :returns "не определено"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "vector-for-each") похож на ,(var "vector-map"), за исключением того, что ,(var "vector-for-each") не создает и не возвращает
          вектор результирующих значений, и ,(var "vector-for-each") гарантирует выполнение применений последовательно по элементам
          слева направо.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-8|#")

      (formdef
      :syntax "(string-for-each procedure string1 string2 ...)"
      :returns "не определено"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "string-for-each") повторяет ,(var "for-each") и ,(var "vector-for-each") за исключением того, что на
          вход подаются строки, а не списки или векторы.])
      (include-src "src/scheme/5.control_operations.scm" "#|+mapping-9|#"))

   (section :title "Продолжения"
      (p [Продолжения в Scheme - это процедуры, которые представляют остаток вычисления от данной точки вычисления. Их
          можно получить с помощью ,(var "call-with-current-continue"), которая может быть сокращена до ,(var "call/cc").])

      (formdef
      :syntax '("(call/cc procedure)"
                "(call-with-current-continuation procedure)")
      :returns "смотри ниже"
      :libraries "(rnrs base), (rnrs)")
      (p [Эти две процедуры - одно и то же. Чаще используется короткое имя, по понятным причинам.])
      (p [,(var "call/cc") получает продолжение и передаёт его в процедуру, которая должна принимать один аргумент. Само
          продолжение представлено в виде процедуры. Каждый раз, когда эта процедура применяется к нулю или более
          аргументов, она возвращает значения в продолжение от применения ,(var "call/cc").]) ;;TODO: не уверен в переводе:
      (p [Если переданная процедура успешно выполняется и возвращает результат, этот результат возвращается в качестве
          результата всего выражения ,(var "call/cc").])
      (p [Продолжения позволяют реализовать нелокальный выход, поиск с возвратом ,(ref :bib '(b14 b29)), сопрограммы
          ,(ref :bib 'b16) и многопоточность ,(ref :bib '(b10 b32)).])
      (p [В приведенном ниже примере показано использование продолжения для нелокального выхода из цикла.])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-1|#")
      (p [Дополнительные примеры можно найти в ,(ref :text "Главе 3.3" :section "Продолжения") и ,(ref :text "Главе
          12.11" :section "Многопоточность на Engines")])
      (p [Текущее продолжение обычно представлено внутри как стек записей активации процедуры, и получение продолжения
          производит инкапсуляцию стека в процедурный объект. Поскольку инкапсулированный стек имеет неопределённый размер,
          необходимо использовать какой-то механизм для сохранения содержимого стека на неопределенный срок. Это можно
          сделать с удивительной легкостью и эффективностью, не влияя на программы, в которых не используются
          продолжения ,(ref :bib 'b17).])

      (formdef
      :syntax "(dynamic-wind in body out)"
      :returns "значения, возвращаемые от применения body"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "dynamic-wind") реализует "защиту" от выполнения продолжений. Это полезно для выполнения задач, которые должны
          выполняться в любом случае, когда управление передаётся в тело или выходит из него, как обычным способом, так и с помощью
          применения продолжения.])
      (p [Три аргумента ,(var "in"), ,(var "body") и ,(var "out") должны быть процедурами и должны принимать ноль
          аргументов, т.е. представлять из себя ,(it "санк") (thunk),(footnote "фрагмент кода для выполнения дополнительного
          вычисления, устоявшегося перевода нет."). Перед выполнением ,(var "body") и каждый раз, когда происходит вход
          в ,(var "body") путём применения продолжения, созданного внутри ,(var "body"), выполняется ,(var "in"). При
          нормальном выходе из тела и каждый раз, когда происходит выходит из ,(var "body") из-за применения
          продолжения, созданного вне ,(var "body"), выполняется ,(var "out").])
      (p [Таким образом гарантируется, что ,(var "in") будет выполнен ходятбы один раз. А так же, если ,(var "body")
          когда-либо вернёт результат, ,(var "out") будет выполнен хотя-бы один раз.])
      (p [В следующем примере демонстрируется использование ,(var "dynamic-wind"), чтобы убедиться, что входной порт закрыт после
          обработки, независимо от того, завершилась ли обработка нормально.])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-2|#")
      (p [Common Lisp предоставляет аналогичное средство (,(var "unwind-protect")) для защиты от нелокальных
          выходов. Часто этого бывает достаточно. Однако ,(var "unwind-protect") предоставляет только эквивалент ,(var "out"),
          поскольку Common Lisp не поддерживает полностью продолжения общего назначения. Вот как можно определить ,(var
          "unwind-protect") с помощью ,(var "dynamic-wind").])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-3|#")
      (p [Некоторые реализации Scheme поддерживают управляемую форму присваивания, известную как ,(it "подвижное
          связывание"),(footnote "устоявшегося перевода нет") (fluid binding), в которой переменная принимает временное
          значение на время вычисления и возвращается к старому значению после завершения вычисления. Синтаксическая форма
          ,(var "fluid-let"), определенная ниже в терминах ,(var "dynamic-wind"), совершает подвижное связывание
          единственной переменной ,(var "x") со значением выражения ,(var "e") в теле ,(var "b1 b2 ...").])
      (include-src "src/scheme/5.control_operations.scm" :definition 'fluid-let)
      (p [Реализации, которые поддерживают ,(var "fluid-let") обычно расширяют его для поддержки любого количества пар ,(var "(x
          e)") как в обычном ,(var "let").])
      (p [Если никакие продолжения не вызываются в теле fluid-let, поведение будет таким же, как если бы переменной было
          просто присвоено новое значение при входе и присвоено старое значение при возврате.])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-4|#")
      (p [Подвижно связанная переменная так же возвращает своё старое значение, если вызывается продолжение, созданное
          за пределами ,(var "fluid-let")])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-5|#")
      (p [Если управление покинуло тело fluid-let, либо обычным способом, либо в результате вызова продолжения, а затем
          управление повторно вернулось в тело с помощью вызова продолжения, временное значение подвижно связанной
          переменной восстанавливается. Кроме того, любые изменения временного значения сохраняются и отражаются при
          повторном входе.])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-6|#")
      (p [Ниже представлена библиотека, показывающая, как можно было бы реализовать ,(var "dynamic-wind"), если бы он
          еще не был встроен. Помимо определения ,(var "dynamic-wind"), код определяет версию ,(var "call/cc"), которая
          делает свою часть для поддержки ,(var "dynamic-wind").])
      (include-src "src/scheme/5.control_operations.scm" "#|+continuations-7|#")
      (p [Вместе ,(var "dynamic-wind") и ,(var "call/cc") управляют списком ,(it "намотчиков") (winder),(footnote "в оригинале игра слов, дело в том, что
          названия ф-й dynamic-wind и unwind-protect можно перевести примерно как \"управляемая накрутка\" и \"защита от
          раскрутки\" - это устоявшиеся термины, применяемые к стеку вызовов. Во многих ЯП, когда в коде выбрасывается
          исключение, управление передаётся вверх по стеку вызовов, настолько далеко вверх, насколько далеко находится
          обработчик данного типа исключения, данный процесс движения вверх по стеку вызовов и называется \"раскруткой
          стека\". Здесь автор использовал слово winder (моталка) для обозначения вообще механизма управления
          накруткой/раскруткой стека."). Намотчик - это пара входных и выходных санков, устанавливаемых при вызове
          ,(var "dynamic-wind"). Всякий раз, когда вызывается ,(var "dynamic-wind"), выполняется санк ,(var "in"), новый
          намотчик, содержащая ,(var "in") и ,(var "out") санки, помещается в список намотчиков, выполняется санк ,(var
          "body"), намотчик удаляется из списка намотчиков, и вызывается санк ,(var "out"). Такой порядок гарантирует,
          что намотчик будет в списке намотчиков только тогда, когда управление прошло ,(var "in"), но еще не дошло до
          ,(var "out"). При получении продолжения список намотчиков сохраняется, а при каждом вызове продолжения
          сохраненный намотчиков восстанавливается. Во время восстановления вызывается санк ,(var "out") каждого
          намотчика из текущего списка намотчиков, который не входит в список сохраненных намотчиков, а затем санк ,(var
          "in") каждого намотчика в списке сохраненных намотчиков, которого нет в текущем списке намотчиков. Список
          намотчиков обновляется инкрементально, опять же, чтобы гарантировать, что намотчик находится в текущем списке
          намотчиков, только если управление прошло через его санк ,(var "in") и не вошло в его санк ,(var "out").])
      (p [Проверка ,(code "(not (eq? save winders))"), выполняемая в ,(var "call/cc") не является строго обязательной, однако
          позволяет сделать выполнение продолжений менее накладным в случае, если сохраняемый и текущий списки
          намотчиков совпадают.]))

   (section :title "Отложенное вычисление"
      (p [Синтаксическая форма ,(var "delay") и процедура ,(var "force") могут использоваться в паре для
          реализации ленивых вычислений. Оленивленное выражение не вычисляется до тех пор, пока не потребуется его значение,
          и, однажды вычисленное, не вычисляется повторно.])

      (formdef
       :syntax "(delay expr)"
       :returns "обещание"
       :libraries "(rnrs base), (rnrs)")
      (formdef
       :syntax "(force promise)"
       :returns "результат форсирования обещания"
       :libraries "(rnrs r5rs)")
      (p [В первый раз, когда ,(it "обещание") (promise), созданное с помощью ,(var "delay"), форсируется (с помощью, ,(var "force")), это
          приводит к вычислению ,(var "expr") и запоминанию результата. Позже, каждый раз, когда данное обещание форсируется, это
          приводит к возврату запомненого значения, вместо его повторного вычисления. ])
      (p [,(var "delay") и ,(var "force") обычно используются только при отсутствии побочных эффектов, например присваивания, так что
          порядок вычисления не важен.])
      (p [Преимущество использования ,(var "delay") и ,(var "force") состоит в том, что некоторого объема вычислений можно вообще
          избежать, если они откладываются до тех пор, пока они не станут абсолютно необходимыми. Отложенное вычисление
          может использоваться для построения концептуально бесконечных списков или потоков. В приведенном ниже примере
          показано, как можно построить абстракцию потока с помощью ,(var "delay") и ,(var "force"). Поток (stream) - это обещание, которое
          при форсировании возвращает пару, ,(var "cdr") которой является потоком.])
      (include-src "src/scheme/5.control_operations.scm" "#|+delayed-evaluation-1|#")
      (p [,(var "delay") может быть определена следующим образом:])
      (include-src "src/scheme/5.control_operations.scm" :definition 'delay)
      (p [где ,(var "make-promise") может быть определена следующим образом:.])
      (include-src "src/scheme/5.control_operations.scm" :definition 'make-promise)
      (p [С подобным определением ,(var "delay"), ,(var "force") просто выполняет обещание для форсирования вычисления, или возвращает
          сохранённое значениие.])
      (include-src "src/scheme/5.control_operations.scm" :definition 'force)
      (p [Второй тест переменной ,(var "set?") в ,(var "make-promise") необходим в случае, если в результате применения ,(var "p") обещание
          рекурсивно форсируется. Поскольку обещание должно всегда возвращать одно и то же значение, результат первого
          применения ,(var "p") в итоге возвращается.])
      (p [Каким образом ,(var "delay") и force должны обрабатывать случай возврата нескольких значений не определено; приведённая выше
          реализация не обрабатывает этот случай, но следующая версия делает это с помощью ,(var "call-with-values") и
          ,(var "apply").])
      (include-src "src/scheme/5.control_operations.scm" "#|+delayed-evaluation-2|#")
      (p [Ни одна из реализаций не является правильной до конца, поскольку force должна вызывать исключение с типом
          ,(var "&assertion"), если его аргумент не является обещанием. Поскольку невозможно отличить процедуру, созданную с помощью
          ,(var "make-promise,") от других процедур, ,(var "force") не может удовлетворить этому требованию. Следующая повторная
          реализация ,(var "make-promise") и ,(var "force") представляет обещания как записи типа обещания (см. ,(ref
          :text "Главу 9" :chapter "Записи")), позволяющие ,(var "force") выполнить требуемую проверку.])
      (include-src "src/scheme/5.control_operations.scm" "#|+delayed-evaluation-3|#"))

   (section :title "Множественные значения"
      (p [В то время как все примитивы Scheme и большинство определённых пользователем процедур возвращают в точности
          одно значение, некоторые программные задачи имеют лучшее решение, если возвращают ноль, более одного или
          переменное количество результатов. Например, процедуре, которая разделяет список значений на два подсписка,
          необходимо возвращать два значения. Хотя и возможно для производителя результатов упаковать их в структуру
          данных, а получателю значений извлечь их оттуда, часто более понятным в использовании будет использовании
          встроенного интерфейса работы с множественными значениями. Этот интерфейс содержит две процедуры: ,(var "values") и
          ,(var "call-with-values"). Первая производит несколько значений, а вторая связывает процедуры, которые производят
          многозначные значения, с процедурами, которые их используют.])

      (formdef
       :syntax "(values obj ...)"
       :returns "obj ..."
       :libraries "(rnrs base), (rnrs)")
      (p [Процедура ,(var "values") принимает любое количество аргументов и просто передаёт (возвращает) аргументы
          своему продолжению.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-1|#")

      (formdef
       :syntax "(call-with-values producer consumer)"
       :returns "смотри ниже"
       :libraries "(rnrs base), (rnrs)")
      (p [,(var "producer") (производитель) и ,(var "consumer") (потребитель) должны быть процедурами. ,(var
      "call-with-values") применяет ,(var "consumer") к значениями, возвращаемым выполнением producer без аргументов.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-2|#")
      (p [Во втором примере, values сама по себе выступает в роли производителя. Она выполняется без аргументов, из-за
          чего не возвращает значений. Затем list применяется без аргументов и производит пустой список. ])
      (p [Процедура ,(var "dxdy,") определённая ниже, вычисляет изменение в координатах ,(var "x") и ,(var "y") для пары
      точек, чьи координаты представлены в виде пары ,(var "(x . y)")])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-3|#")
      (p [,(var "dxdy") можно использовать для вычисления длины и наклона сегмента, представленного двумя конечными точками.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-4|#")
      (p [Конечно, мы можем объединить их, чтобы сформировать одну процедуру, которая возвращает два значения.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-5|#")
      (p [В приведенном ниже примере используется несколько значений для неразрушающего разделения списка на два
          подсписка чередующихся элементов.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-6|#")
      (p [На каждом уровне рекурсии, процедура split возвращает два элемента: список элементов из чётных позиций из
          списка переданного в аргументе, и список элементов из нечётных позиций.])
      (p [Продолжение вызова ,(var "values") не обязательно должно быть сопровождаться вызовом ,(var "call-with-values,") и
          не только ,(var "values") может использоваться для возврата продолжения, устанавлеваемого ,(var
          "call-with-values.") В частности, ,(var "(values e)") и ,(var "e") являются эквивалентными
          выражениями. Например:])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-7|#")
      (p [Точно так же, values может быть использовано, чтобы передать любое кол-во значений в продолжение, которое
          игнорирует значения, как в примере ниже:])
      (src-lite "(begin (values 1 2 3) 4) → 4")
      (p [Благодаря тому, что продолжение может принимать ноль и более одного значений, продолжение, полученное с помощью
          ,(var "call/cc") может принимать ноль или более одного аргумента.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-8|#")
      (p [Для случаев, когда продолжение, ожидающее в точности одно значение, получает ноль или более значений,
          поведение не определено. Например, поведение каждого выражения ниже не определено. Некоторый реализации
          вызывают исключение, в то время как другие молча изымают дополнительные значения или поддерживают значение по
          умолчанию для недостающих значений.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-9|#")
      (p [Программы, которые хотят принудительно игнорировать дополнительные значения в определенных контекстах, могут
          легко сделать это, явно вызвав ,(var "call-with-values"). Синтаксическая форма, которую мы назовём ,(var "first"), может
          быть определена следующим образом, чтобы абстрагировать отбрасывание лишних значений, когда требуется только одно.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-10|#")
      (p [Если же требуется реализация, вызывающая исключение с типом &assertion в случае, если процедура принимает
          количество аргументов отличное от того, которое ей передали, подойдёт любая из следующий реализаций:])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-11|#")
      (p [Так как ,(var "producer") это чаще всего лямбда-выражение, часто удобно использовать синтаксическое расширение, которое
          скрывает лямбда-выражение в целях удобства чтения.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-12|#")
      (p [Если же consumer так же лямбда-выражение, то специальные варианты, с поддержкой множественных значений ,(var "let")
          и ,(var "let*"), описанных в ,(ref :text "Главе 4.5" :section "Множественные значения"), обычно более удобны.])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-13|#")
      (p [Многие стандартные синтаксические формы и процедуры пробрасывают множественные значения. Большинство из них
          делают это "автоматически" в том смысле, что в реализации не нужно делать ничего особенного, чтобы это
          произошло. Обычное раскрытие ,(var "let") в прямой лямбда-вызов автоматически пробрасывает множественные значения,
          созданные телом ,(var "let"). Другие операторы должны быть написаны специальным образом, чтобы пробрасывать
          множественные значения. Например, процедура ,(var "call-with-port") (,(ref :text "Глава 7.6" :section
          "Операции с портом")) вызывает свой аргумент-процедуру, затем закрывает аргумент-порт, перед возвратом
          значений процедуры, поэтому она должна временно сохранить значения. Это легко сделать с помощью ,(var
          "let-values,") ,(var "apply") и ,(var "values"):])
      (include-src "src/scheme/5.control_operations.scm" :definition 'call-with-port)
      (p [Если это покажется слишком большим объемом накладных расходов, для случая с одним возвращаемым значением, в
          коде можно использовать ,(var "call-with-values") и ,(var "case-lambda") для более эффективной обработки
          случая с одним значением:])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-14|#")
      (p [Определения для ,(var "values") и ,(var "call-with-values") (и сопутствующее переопределение ,(var "call/cc")) в библиотеке ниже,
          демонстрирует, как мог бы быть реализован интерфей работы со множественными значениями в Scheme, если бы он не
          был уже встроен. Проверка ошибок невозможна, тем не менее, выполняется для случая, когда более одного значения
          возвращается в контекст с одним значением, например в тестовую часть выражения ,(var "if").])
      (include-src "src/scheme/5.control_operations.scm" "#|+multiple values-15|#")
      (p [Множественные значения могут быть реализваны более эффективно ,(ref :bib 'b2), однако этот код служит целями
          демонстрации смысла операторов и может быть использован, чтобы предоставить поддежку множественных значений
          в старые, нестандартные реализации, которые не поддеживают их.]))

   (section :title "eval"
      (p [,(var "eval") в Scheme это процедура, позволяющая писать программы, которые конструируют и выполняют другие
          программы. Этой возможностью метапрограммирования в реальном времени не стоит злоупотреблять, но иметь её под
          рукой в некоторых случаях приятно.])

      (formdef
       :syntax "(eval obj environment)"
       :returns "результат Scheme-выражения, описанного в obj, выполненного в контексте environment"
       :libraries "(rnrs eval)")
      (p [Если ,(var "obj") не представляет синтаксически корректное выражение, ,(var "eval") вызывает исключение с типом
          ,(var "&syntax"). Окружения (environment) возвращаемые ,(var "environment"), ,(var "scheme-report-environment")
          и ,(var "null-environment") неизменяемые. Поэтому, ,(var "eval") обычно вызывает исключение с типом ,(var
          "&syntax"), если в выражении появляется присвоение какой-либо из переменных среды.])
      (include-src "src/scheme/5.control_operations.scm" "#|+eval-1|#")

      (formdef
       :syntax "(environment import-spec ...)"
       :returns "окружение"
       :libraries "(rnrs eval)")
      (p [environment возвращает окружение, сформированное из комбинации связываний, заданных в спецификации
          импорта. Каждая спецификация импорта должна быть s-выражением, представляющим корерктное определение импорта
          (см. ,(ref :text "Главу 10" :chapter "Библиотеки и программы верхнего уровня"))])
      (include-src "src/scheme/5.control_operations.scm" "#|+eval-2|#")

      (formdef
       :syntax "(null-environment version)"
       :syntax "(scheme-report-environment version)"
       :returns "R5RS-совместимов окружение"
       :libraries "(rnrs r5rs)")
      (p [,(var "version") должна быть целым числом 5.])
      (p [,(var "null-environment") возвращает окружение, состоящее из связываний ключевых слов, чьё значение определено Revised,(sup "5")
          отчётом стандарта Scheme, а так же связывания для вспомогательных ключевых слов ,(var "else"), ,(var "=>"),
          ,(var "..."), ,(var "_").])
      (p [,(var "scheme-report-environment") возвращает окружение, содержащее те же связывания с ключевыми словами, что и
          окружение возвращаемое ,(var "null-environment"), а так же связывания, чьё значение определено Revised,(sup "5") отчётом
          стандарта Scheme, за исключением тех, которые не определены Revised,(sup "6") версией стандарта: ,(var "load"),
          ,(var "interaction-environment"), ,(var "transcript-on"), ,(var "transcript-off"), ,(var "char-ready?").])
      (p [Связывания для каждого из идентификаторов в окружениях, возвращаемых этими процедурами, принадлежат
          соответствующей библиотеке Revised,(sup "6"), поэтому это не обеспечивает полной обратной совместимости, даже если
          связывания исключенных идентификаторов не используются.])))
