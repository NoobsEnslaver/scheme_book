;;; -*- coding: utf-8; tab-width: 4; c-basic-offset: 2; indent-tabs-mode: nil; fill-column: 120; -*-

(chapter :title "Двигаемся дальше"
   (chapter-image "images/ch3.png")
   (p [Предыдущая глава подготовила вас к написанию программ Scheme с использованием небольшого набора наиболее полезных
       примитивных синтаксических форм и процедур. В этой главе представлен ряд дополнительных функций и методов
       программирования, которые позволят вам писать более сложные и эффективные программы.])
   (section :title [Синтаксические выражения]
      (p [Как мы видели в Разделе 2.5, синтаксическая форма ,(var "let") - это просто синтаксическое расширение, определяемое в
          терминах лямбда-выражения и применения процедуры, которые являются основными синтаксическими формами. В этот момент
          вам может быть интересно, какие синтаксические формы являются основными, а какие - синтаксическими расширениями, и
          как могут быть определены новые синтаксические расширения. В этом разделе приведены некоторые ответы на эти
          вопросы.])
      (p [По правде говоря, нам не нужно проводить различие между основными формами и синтаксическими расширениями, поскольку
          после определения синтаксическое расширение имеет точно такой же статус, что и основная форма. Проведение различия,
          однако, облегчает понимание языка, поскольку позволяет нам сосредоточить внимание на основных формах и понять все
          остальные с точки зрения этих форм.])
      (p [Для реализации Scheme необходимо различать основные формы и синтаксические расширения. Реализация Scheme
          разворачивает синтаксические расширения в основные формы на первом этапе компиляции или интерпретации, позволяя
          остальной части компилятора или интерпретатора сосредоточиться только на основных формах. Однако набор основных
          форм, остающихся после раскрытия, которые будут обрабатываться непосредственно компилятором или интерпретатором,
          зависит от реализации и может отличаться от набора форм, описанных здесь как основные.])
      (p [Таким образом, точный набор синтаксических форм, составляющих ядро ​​языка, является предметом споров, хотя должна
          быть возможность вывести все другие формы из любого набора форм, объявленных основными. Описанный здесь набор
          является одним из самых простых, для которых это ограничение выполняется.])
      (p [Основные синтаксические формы включают в себя формы определения верхнего уровня (,(var "define")), константы, переменные,
          применение процедур, ,(var "quote"), ,(var "lambda"), ,(var "if") и ,(var "set!") выражения. Грамматика ниже описывает основной синтаксис Scheme
          в терминах этих определений и выражений. В грамматике вертикальные черты (,(var "|")) разделяют альтернативы, а форма, за
          которой следует звездочка (,(var "*")), представляет ноль или более вхождений формы. ,(var "<variable>") - это любой идентификатор
          Scheme. ,(var "<datum>") - это любой объект Scheme, например число, список, символ или вектор. ,(var "<boolean>") это либо ,(var "#t"),
          либо ,(var "#f"), ,(var "<number>") - это любое число, ,(var "<character>") - это любой символ, а ,(var "<string>") - это любая строка. Мы уже
          видели примеры чисел, строк, списков, символов и логических значений. См. главу 6 или описание формального
          синтаксиса, для получения дополнительной информации о синтаксисе этих и других объектов.])

      (src-lite "
<program>             → <form>*
<form>                → <definition> | <expression>
<definition>          → <variable definition> | (begin <definition>*)
<variable definition> → (define <variable> <expression>)
<expression>          → <constant>
                      | <variable>
                      | (quote <datum>)
                      | (lambda <formals> <expression> <expression>*)
                      | (if <expression> <expression> <expression>)
                      | (set! <variable> <expression>)
                      | <application>
<constant>            → <boolean> | <number> | <character> | <string>
<formals>             → <variable>
                      | (<variable>*)
                      | (<variable> <variable>* . <variable>)
<application>         → (<expression> <expression>*)")

      (p [Грамматика неоднозначна в том смысле, что синтаксис применения процедур конфликтует с синтаксисами ,(var "quote"),
          ,(var "lambda"), ,(var "if") и ,(var "set!") выражения. Чтобы трактоваться как применение процедуры, первое ,(var "<expression>") не должно быть
          одним из этих ключевых слов, если только ключевое слово не было переопределено или связано локально.])
      (p [Синтаксис ,(var "\"defun\"") для определения, приведенный в разделе 2.6, не включен в ядро, так как определения в этой форме
          прямо переводятся в более простой синтаксис определения. Точно так же основной синтаксис для ,(var "if") не позволяет
          опустить альтернативу, как это было сделано в примере в Разделе 2.9. Выражение ,(var "if"), в котором отсутствует
          альтернатива, может быть переведено в основной синтаксис ,(var "if"), просто заменив отсутствующее подвыражение
          произвольной константой, такой как ,(var "#f").])
      (p [Форма ,(var "begin"), содержащая только определения, считается определением в грамматике; это разрешено, чтобы позволить
          синтаксическим расширениям разворачиваться в более чем одно определение. Выражение ,(var "begin") т.е. форма ,(var "beging"),
          содержащая выражения, не считается основной формой. Выражение ,(var "begin") в виде])

      (src-lite [(begin e1 e2 ...)])

      (p [это эквивалент применения ,(var "lambda")-выражения])

      (src-lite [((lambda () e1 e2 ...))])

      (p [следовательно, нет нужды содержать его в ядре.])
      (p [Теперь, когда мы создали набор основных синтаксических форм, давайте обратимся к обсуждению синтаксических
          расширений. Синтаксические расширения называются так потому, что они расширяют ядро синтаксиса Scheme. Все
          синтаксические расширения в программе на Scheme должны быть в конечном итоге сводимы к основным формам. Однако одно
          синтаксическое расширение может быть определено в терминах другого синтаксического расширения, если последнее в
          некотором смысле «ближе» к основному синтаксису. Синтаксические формы могут применяться везде, где ожидается
          выражение или определение, при условии, что расширенная форма раскрывается в определение или выражение по мере
          необходимости.])
      (p [Синтаксические расширения определяются с помощью ,(var "define-syntax"). ,(var "define-syntax") аналогично ,(var "define"), за
          исключением того, что ,(var "define-syntax") связывает процедуру синтаксического преобразования или преобразователь с
          ключевым словом (например, ,(var "let")), а не связывает значение с переменной. Вот как мы можем определить ,(var "let") с помощью
          ,(var "define-syntax").])

      (include-src "src/scheme/going_further.scm" :definition 'let)

      (p [Идентификатор, появляющийся после ,(var "define-syntax"), является именем или ключевым словом определяемого синтаксического
          расширения, в данном случае ,(var "let"). Форма ,(var "syntax-rule") - это выражение, которое выполняет преобразователь. Элемент,
          следующий за ,(var "syntax-rule") - это списком вспомогательных ключевых слов и это почти всегда ,(var "()"). Примером
          вспомогательного ключевого слова является ,(var "else") в ,(var "cond") (другие примеры, требующие использования вспомогательных
          ключевых слов, приведены в главе 8). После списка вспомогательных ключевых слов приведена последовательность из
          одного или нескольких правил или пар образец/шаблон. Только одно правило появляется в нашем определении
          ,(var "let"). Часть правила "образец" определяет форму, которую должен принимать вход, а "шаблон" указывает, во что вход
          должен быть преобразован.])
      (p [Образец всегда должен быть структурированным выражением, первым элементом которого является подчеркивание (,(var "_")). (Как
          мы увидим в главе 8, использование ,(var "_") - это всего лишь соглашение, но оно хорошо подходит в нашем случае). Если
          присутствует более одного правила, подходящее выбирается путем сопоставления образцов по порядку с формой, поданой
          на вход, во время раскрытия. Если ни один из образцов не соответствует входным данным, это синтаксическое
          нарушение.])
      (p [Идентификаторы, отличные от подчеркивания или многоточия, встречающиеся в образце, являются переменными образца,
          если только они не указаны в качестве вспомогательных ключевых слов. Переменные образца соответствуют любой
          подструктуре и привязываются к этой подструктуре в соответствующем образце. Нотация ,(var "pat ...") в образце
          позволяет сопоставить ноль или более выражений в многоточии с прототипом ,(var "pat") во входных данных. Точно так же
          запись ,(var "expr ...") в шаблоне выдает ноль или более выражений, сопоставленных многоточием в прототипе ,(var "expr") в
          вывод. Количество ,(var "pat") на входе определяет количество ,(var "expr") на выходе; чтобы это работало, любой прототип
          многоточия в шаблоне должен содержать хотя бы одну переменную шаблона из прототипа многоточия в шиблоне.])
      (p [Единственное правило в нашем определении ,(var "let") должно быть достаточно самоочевидным, но стоит упомянуть несколько
          моментов. Во-первых, синтаксис ,(var "let") требует, чтобы тело содержало хотя бы одну форму; следовательно, мы указали ,(var "b1
          b2 ...") вместо ,(var "b ..."), что может показаться более естественным. С другой стороны, ,(var "let") не требует, чтобы была хотя
          бы одна пара переменная/значение, поэтому мы могли просто использовать ,(var "(x e) ..."). Во-вторых, переменные-образцы
          ,(var "x") и ,(var "e"), хотя и вместе в одном прототипе в образце, разделены в шаблоне; возможна любая перестановка или
          рекомбинация. Наконец, три переменные образца ,(var "x"), ,(var "e") и ,(var "b2"), которые появляются в прототипах многоточия в образце,
          также появляются в прототипах многоточия в шаблоне. Это не совпадение; это требование. В общем случае, если
          переменная-образец появляется в прототипе многоточия в образце, она не может появляться вне прототипа многоточия в
          шаблоне.])
      (p [Определение ,(var "and") ниже несколько сложнее, чем определение для ,(var "let").])

      (include-src "src/scheme/going_further.scm" :definition 'and)

      (p [Это определение является рекурсивным и включает более одного правила. Напомним, что ,(var "(and)") возвращает ,(var "#t"); первое
          правило заботится об этом случае. Второе и третье правила определяют базовый случай и шаг рекурсии и вместе
          переводят ,(var "and") выражение с двумя или более подвыражениями во вложенные выражения ,(var "if"). Например, ,(var "(and a b c)")
          разворачивается сначала в])

      (include-src "src/scheme/going_further.scm" 29)

      (p [а потом в])

      (include-src "src/scheme/going_further.scm" 31)

      (p [и наконец в])

      (include-src "src/scheme/going_further.scm" 33)

      (p [При таком раскрытии, если ,(var "a") и ,(var "b") возвращают истинну, тогда результатом является значение ,(var "c"), в противном случае
          ,(var "#f"), что и требовалось.])
      (p [Версия ,(var "and") ниже проще, но, к сожалению, неверна.])

      (include-src "src/scheme/going_further.scm" "#|+bad-and|#")

      (p [Выражение])

      (include-src "src/scheme/going_further.scm" 35)

      (p [должно вернуть значение ,(var "(/ 1 х)"), когда ,(var "х") не ноль. При неверной версии ,(var "and") выражение раскрывается следующим
          образом.])

      (include-src "src/scheme/going_further.scm" 37 39)

      (p [Окончательный ответ, если ,(var "x") не ноль, это ,(var "#t"), а не значение ,(var "(/ 1 х)").])
      (p [Определение ,(var "or") ниже аналогично определению ,(var "and"), за исключением того, что для каждого промежуточного значения
          должна быть введена временная переменная, чтобы мы могли одновременно проверить значение и вернуть его, если оно
          является истинной. (Временная переменная не нужна для ,(var "and"), поскольку существует только одно ложное значение,
          ,(var "#f")).])

      (include-src "src/scheme/going_further.scm" :definition 'or)

      (p [Как и переменные, связанные лямбда-выражением или ,(var "let"), идентификаторы, введенные шаблоном, имеют лексическую
          область видимости, то есть видимы только в выражениях, введенных шаблоном. Таким образом, даже если одно из
          выражений ,(var "e2 e3 ...") содержит ссылку на ,(var "t"), введенная привязка для ,(var "t") не "захватывает" эти ссылки. Обычно это
          достигается путем автоматического переименования введенных идентификаторов.])
      (p [Как и в случае с более простой версией ,(var "and") приведенной выше, более простая версия ,(var "or") ниже является
          неправильной.])

      (include-src "src/scheme/going_further.scm" "#|+bad-or|#")

      (p [Однако причина более тонкая и является предметом упражнения 3.2.6.])

      (subsection :title "Упражнение"
         (p [Запишите шаги, необходимые для раскрытия расширения])

         (src-lite "
(let ([x (memv 'a ls)])
  (and x (memv 'b x)))")

         (p [в базовые формы.]))
      (subsection :title "Упражнение"
         (p [Запишите шаги, необходимые для раскрытия расширения])

         (src-lite "(or (memv x '(a b c)) (list x))")

         (p [в базовые формы.]))
      (subsection :title "Упражнение"
         (p [,(var "let*") аналогичен ,(var "let"), но выполняет связывания по порядку. Каждое из выражений в правой части находится в рамках
             области действия предыдущих привязок.])

         (src-lite "
(let* ([a 5] [b (+ a a)] [c (+ a b)])
  (list a b c)) → (5 10 15)")

         (p [,(var "let*") может быть реализован как вложенные выражения ,(var "let"). Например, вышеприведенное выражение ,(var "let*") эквивалентно
             вложенным выражениям ,(var "let") ниже.])

         (src-lite "
(let ([a 5])
  (let ([b (+ a a)])
    (let ([c (+ a b)])
      (list a b c)))) → (5 10 15)")

         (p [Определите ,(var "let*") с помощью ,(var "define-syntax").]))
      (subsection :title "Упражнение"
         (p [Как мы видели в разделе 2.9, допустимо опускать третье или альтернативное подвыражение выражения ,(var "if"). Однако это
             часто приводит к путанице. Scheme предоставляет две синтаксические формы, ,(var "when") и ,(var "unless"), которые могут
             использоваться вместо таких «одноруких» ,(var "if").])

         (src-lite "
(when test expr1 expr2 ...)
(unless test expr1 expr2 ...)")

         (p [В обеих формах тест вычисляется первым. Для ,(var "when"), если ,(var "test") возвращает истину, остальные формы выполняются
             последовательно, как если бы они были заключены в неявное выражение ,(var "begin"). Если ,(var "test") возвращает ложь, остальные
             формы не выполняются, а результат неопределён. ,(var "unless") ведёт себя аналогично, за исключением того, что остальные
             формы выполняются только если тест оценивается как ложный.])

         (src-lite "
(let ([x 3])
  (unless (= x 0) (set! x (+ x 1)))
  (when (= x 4) (set! x (* x 2)))
  x) → 8")

         (p [Определите ,(var "when") как синтаксическое расширение в терминах ,(var "if") и ,(var "begin"), и определите ,(var "unless"), только в терминах
             ,(var "when").])))
   (section :title [Больше о рекурсии]
      (p [В разделе 2.8 мы увидели, как определять рекурсивные процедуры, используя определения верхнего уровня. До этого мы
          видели, как создавать локальные связывания для процедур с использованием ,(var "let"). Естественно задаться вопросом, может
          ли ,(var "let")-процедура быть рекурсивной. Ответ - нет, по крайней мере, не прямым способом. Если вы попытаетесь выполнить
          выражение])

      (src "
(let ([sum (lambda (ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))")

      (p [это, вероятно, вызовет исключение с сообщением о том, что ,(var "sum") не определена. Это связано с тем, что переменная
          ,(var "sum") видна только в теле выражения ,(var "let"), а не в лямбда-выражении, значение которого связано с ,(var "sum"). Мы можем
          обойти эту проблему, передав процедуру ,(var "sum") себе самой следующим образом.])

      (include-src "src/scheme/going_further.scm" 50 54)

      (p [Это работает и является разумным решением, но есть более простой способ, используя ,(var "letrec"). Как и ,(var "let"),
          синтаксическая форма ,(var "letrec") включает в себя набор пар переменная-значение и последовательность выражений,
          называемых телом ,(var "letrec").])

      (src "(letrec ((var expr) ...) body1 body2 ...)")

      (p [В отличие от ,(var "let"), переменные ,(var "var ...") видны не только внутри тела ,(var "letrec"), но и внутри выражения ,(var "expr
          ..."). Таким образом, мы можем переписать приведенное выше выражение следующим образом.])

      (include-src "src/scheme/going_further.scm" 56 60)

      (p [Используя ,(var "letrec"), мы также можем определить взаимно рекурсивные процедуры, такие как процедуры ,(var "even?") и ,(var "odd?"),
          которые были предметом упражнения 2.8.6.])

      (include-src "src/scheme/going_further.scm" 62 70)

      (p [В выражении ,(var "letrec") ,(var "expr ...") чаще всего является лямбда-выражением, хотя это не обязательно. Однако необходимо
          соблюдать одно ограничение для выражений. Должна быть возможность вычислять каждое выражение без вычисления
          какой-либо из переменных ,(var "var ..."). Это ограничение всегда выполняется, если все выражения являются
          лямбда-выражениями, поскольку, хотя переменные могут появляться в лямбда-выражениях, они не могут быть вычислены до
          тех пор, пока результирующие процедуры не будут вызваны в теле ,(var "letrec"). Следующее выражение ,(var "letrec") подчиняется
          этому ограничению.])

      (include-src "src/scheme/going_further.scm" 68 70)

      (p [А это нет.])

      (src "
(letrec ([y (+ x 2)]
         [x 1])
   y)")

      (p [В этом случае возникает исключение, указывающее, что ,(var "x") не определено там, где на него ссылаются.])
      (p [Мы можем использовать ,(var "letrec"), чтобы скрыть определения «вспомогательных» процедур, чтобы они не загромождали
          пространство имен верхнего уровня. Это демонстрирует определение ,(var "list?") ниже, который следует алгоритму «заяц и
          черепаха», описанному в упражнении 2.9.8.])

      (include-src "src/scheme/going_further.scm" :definition 'list?)

      (p [Когда рекурсивная процедура вызывается только в одном месте вне процедуры, как в примере выше, часто проще
          использовать именованное выражение ,(var "let"). Именованные ,(var "let") выражения принимают следующую форму.])

      (src-lite "
(let name ((var expr) ...)
  body1 body2 ...)")

      (p [Именованный ,(var "let") похож на безымянный ,(var "let") в том, что он связывает переменные ,(var "var ...") со значениями ,(var "expr ...") в
          теле ,(var "body1 body2 ..."). Как и в случае безымянного ,(var "let"), переменные видны только внутри тела, а не внутри ,(var "expr
          ..."). В дополнение, переменная ,(var "name") внутри тела связана с процедурой, которая может быть вызвана для рекурсии;
          аргументы процедуры становятся новыми значениями переменных ,(var "var ...").])
      (p [Определение ,(var "list?") было переписано ниже для использования именнованного ,(var "let").])

      (include-src "src/scheme/going_further.scm" "#|+list2-def|#")

      (p [Так же, как обычный ,(var "let") может быть представлен в виде простого применения лямбда-выражения к аргументам, так и
          именованный ,(var "let") может быть представлен как применение рекурсивной процедуры к аргументам. Форма именованного ,(var "let")])

      (src-lite "
(let name ((var expr) ...)
  body1 body2 ...)")


      (p [может быть переписана в терминах ,(var "letrec") следующим образом.])

      (src-lite "
((letrec ((name (lambda (var ...) body1 body2 ...)))
   name)
 expr ...)")

      (p [Или иначе это может быть переписано как])

      (src-lite "
(letrec ((name (lambda (var ...) body1 body2 ...)))
  (name expr ...))")

      (p [при условии, что переменная ,(var "name") не появляется свободно в ,(var "expr ...").])
      (p [Как мы обсуждали в разделе 2.8, некоторая рекурсия по сути является итерацией и выполняется как таковая. Когда вызов
          процедуры находится в хвостовой позиции (см. ниже) по отношению к лямбда-выражению, он считается хвостовым вызовом,
          и системы Scheme должны правильно обрабатывать его как ,(var "\"goto\"") или прыжок. Когда процедура вызывает себя хвостовым
          вызовом или вызывает себя косвенно через серию хвостовых вызовов, результатом является хвостовая рекурсия. Поскольку
          хвостовые вызовы обрабатываются как переходы, хвостовая рекурсия может использоваться для неограниченной итерации
          вместо более ограниченных итерационных конструкций, предоставляемых другими языками программирования, не опасаясь
          переполнения любого вида стека рекурсии.])
      (p [Вызов находится в хвостовой позиции по отношению к лямбда-выражению, если его результат возвращается непосредственно
          из лямбда-выражения, т.е. если после вызова ничего не остается делать, кроме как возвращаться из
          лямбда-выражения. Например, вызов находится в хвостовой позиции, если это последнее выражение в теле
          лямбда-выражения, последующая или альтернативная часть выражения ,(var "if") в хвостовой позиции, последнее подвыражение
          ,(var "and") или ,(var "or") в хвостовой позиции, последнее выражение в теле ,(var "let") или ,(var "letrec") в хвостовой позиции и т. д. Каждый
          из вызовов ,(var "f") в приведенных ниже выражениях является хвостовым вызовом, а вызовы ,(var "g") - нет.])

      (src-lite "
(lambda () (f (g)))
(lambda () (if (g) (f) (f)))
(lambda () (let ([x 4]) (f)))
(lambda () (or (g) (f)))")

      (p [В каждом случае результат вызовов ,(var "f") возвращаются напрямую, тогда как вызовы ,(var "g") - нет.])
      (p [Рекурсия в общем и именованный ,(var "let") позволяет, в частности, обеспечить естественный способ реализации многих
          алгоритмов, будь то итеративный, рекурсивный или частично итеративный, или частично рекурсивный; программист не
          принуждён выбирать между двумя различными механизмами.])
      (p [Следующие два определения факториала используют именованные выражения ,(var "let") для вычисления факториала ,(var "n!") целого
          неотрицательного числа ,(var "n"). Первый использует рекурсивное определение ,(var "n! = n × (n - 1)!"), где ,(var "0!") определяется
          как 1.])

      (include-src "src/scheme/going_further.scm" "#|+factorial|#")

      (p [Вторая - это итерационная версия, в которой используется итеративное определение ,(var "n! = n × (n - 1) × (n - 2) × ... ×
          1"), использующая аккумулятор ,(var "a") для хранения промежуточных результатов.])

      (include-src "src/scheme/going_further.scm" "#|+factorial-iter|#")

      (p [Аналогичная проблема заключается в вычислении n-го числа Фибоначчи для данного ,(var "n"). Числа Фибоначчи представляют
          собой бесконечную последовательность целых чисел 0, 1, 1, 2, 3, 5, 8 и т. д., в которой каждое число является суммой
          двух предыдущих чисел в последовательности. Процедура вычисления n-го числа Фибоначчи наиболее естественно
          определяется рекурсивно следующим образом.])

      (include-src "src/scheme/going_further.scm" "#|+fibonacci|#")

      (p [Это решение требует вычисления двух предыдущих чисел Фибоначчи на каждом шаге и, следовательно, является дважды
          рекурсивным. Например, для вычисления ,(var "(fibonacci 4)") требуется вычисление обоих ,(var "(fib 3)") и ,(var "(fib 2)"), для
          вычисления ,(var "(fib 3)") требуется вычисление как ,(var "(fib 2)") и ,(var "(fib 1)"), так и для вычисления ,(var "(fib 2)") требуется
          вычисление как ,(var "(fib 1)"), так и ,(var "(fib 0)"). Это очень неэффективно и становится все более неэффективным с ростом
          ,(var "n"). Более эффективное решение состоит в том, чтобы адаптировать решение с аккумулятором из приведенного выше
          примера факториала, чтобы использовать два аккумулятора, ,(var "a1") для текущего числа Фибоначчи и ,(var "a2") для предыдущего.])

      (include-src "src/scheme/going_further.scm" "#|+fibonacci-acc|#")

      (p [Здесь ноль рассматривается как особый случай, так как предшествующего значения нет. Это позволяет нам использовать
          один базовый случай ,(var "(= i 1)"). Время, необходимое для вычисления n-го числа Фибоначчи с использованием этого
          итеративного решения, растет линейно с ростом ,(var "n"), что существенно лучше по сравнению с дважды рекурсивной
          версией. Чтобы почувствовать разницу, попробуйте вычислить ,(var "(fibonacci 35)") и ,(var "(fibonacci 40)"), используя оба
          определения, чтобы увидеть, сколько времени занимает каждое из них.])
      (p [Мы также можем почувствовать разницу, взглянув на трассировку для каждого на небольших входных данных. Первая
          трассировка ниже показывает вызовы ,(var "fib") в версии ,(var "fibonacci") без хвостовой рекурсии, со входом 5.])

      (src "
|(fib 5)
| (fib 4)
| |(fib 3)
| | (fib 2)
| | |(fib 1)
| | |1
| | |(fib 0)
| | |0
| | 1
| | (fib 1)
| | 1
| |2
| |(fib 2)
| | (fib 1)
| | 1
| | (fib 0)
| | 0
| |1
| 3
| (fib 3)
| |(fib 2)
| | (fib 1)
| | 1
| | (fib 0)
| | 0
| |1
| |(fib 1)
| |1
| 2
|5")

      (p [Обратите внимание, что есть несколько вызовов ,(var "fib") с аргументами 2, 1 и 0. Вторая трассировка показывает вызовы
          ,(var "fib") в хвостовой рекурсивной версии, опять же с 5 на входе.])

      (src "
|(fib 5 1 0)
|(fib 4 1 1)
|(fib 3 2 1)
|(fib 2 3 2)
|(fib 1 5 3)
|5")

      (p [Очевидно, что есть большая разница.])
      (p [Примеры с именованным ,(var "let"), показанные до сих пор, были либо хвост-рекурсивными, либо не хвост-рекурсивными. Часто
          случается, что один рекурсивный вызов в одном и том же выражении является хвостово-рекурсивным, а другом -
          нет. Определение ,(var "factor") ниже вычисляет простые множители его неотрицательного целочисленного аргумента. Первый
          вызов ,(var "f") не хвост-рекурсивный, но второй - да.])

      (include-src "src/scheme/going_further.scm" "#|+factor|#")

      (p [Трассировка вызовов ,(var "f"), произведенная в Chez Scheme путем замены ,(var "let") на ,(var "trace-let"), при выполнении ,(var "(factor
          120)") ниже подчеркивает разницу между нехвостыми и хвостовыми вызовами.])

      (src "
|(f 120 2)
| (f 60 2)
| |(f 30 2)
| | (f 15 2)
| | (f 15 3)
| | |(f 5 3)
| | |(f 5 4)
| | |(f 5 5)
| | |(5)
| | (3 5)
| |(2 3 5)
| (2 2 3 5)
|(2 2 2 3 5)")

      (p [Нехвостовой вызов ,(var "f") отображается с отступом относительно уровня, на котором его вызвали, поскольку вызывающий все
          еще активен, тогда как хвостовые вызовы отображаются на том же уровне отступа.])

      (subsection :title "Упражнение"
         (p [Какие из рекурсивных процедур, определенных в разделе 3.2, являются хвостово-рекурсивными, а какие нет?]))
      (subsection :title "Упражнение"
         (p [Перепишите ,(var "factor"), используя ,(var "letrec"), чтобы связать ,(var "f") вместо именованного ,(var "let"). Какую версию вы предпочитаете?]))
      (subsection :title "Упражнение"
         (p [Можно ли переписать приведенное ниже выражение ,(var "letrec"), используя именованный ,(var "let")? Если нет, то почему? Если да,
     то сделайте это.]))

      (src-lite "
(letrec ([even?
          (lambda (x)
            (or (= x 0)
                (odd? (- x 1))))]
         [odd?
          (lambda (x)
            (and (not (= x 0))
                 (even? (- x 1))))])
  (even? 20))")

      (subsection :title "Упражнение"
         (p [Перепишите оба определения ,(var "fibonacci"), приведенные в этом разделе, чтобы подсчитать количество рекурсивных вызовов
           ,(var "fib"), используя счетчик, аналогичный тому, который использовался в примере с ,(var "cons-count") в разделе
           2.9. Подсчитайте количество рекурсивных вызовов, сделанных в каждом случае для различных входных значений. Что вы
           заметили?]))
      (subsection :title "Упражнение"
         (p [Дополните определение ,(var "let"), данное в Разделе 3.1, для обработки именованных ,(var "let") и ,(var "let") без имен, используя два
           правила.]))
      (subsection :title "Упражнение"
         (p [Следующее определение ,(var "or") проще, чем приведенное в разделе 3.1.])

         (src-lite "
(define-syntax or ; incorrect!
  (syntax-rules ()
    [(_) #f]
    [(_ e1 e2 ...)
     (let ([t e1])
       (if t t (or e2 ...)))]))")

         (p [Поясните, почему это не правильно. \[Подсказка: подумайте, что бы произошло, если бы эта версия или использовалась в
             ,(var "even?") и ,(var "odd?") для особенно больших значений на входе?\]]))
      (subsection :title "Упражнение"
         (p [Определение ,(var "factor") не является наиболее эффективным из возможных. Во-первых, никакие множители ,(var "n"), кроме самого
             ,(var "n"), невозможно найти за пределами значения корня из ,(var "n"). Во-вторых, деление ,(var "(/ n i)") выполняется дважды, когда
             множитель найден. В-третьих, после 2, никаких чётных множителей найдено быть не может. Перепишите ,(var "factor"), чтобы
             исправить все три проблемы. Какая из этих проблем самая важная? Есть ли дополнительные улучшения, которые вы можете
             сделать?])))

   (section :title [Продолжения]
      (p [Во время выполнения выражения Scheme, реализация должна отслеживать две вещи: (1) что выполнять и (2) что делать со
          значением. Рассмотрим выполнение ,(var "(null? x)") в выражении ниже.])

      (src "(if (null? x) (quote ()) (cdr x))")

      (p [Реализация должна сначала выполнить ,(var "(null? x)") и, основываясь на его значении, выполнить либо ,(var "(quote ())"), либо
          ,(var "(cdr x)"). "Что выполнять" - это ,(var "(null? x)"), а "что делать со значением" - это принимать решение, какое из
          выражений, ,(var "(quote ())") или ,(var "(cdr x)") выполнить. Мы называем "что делать со значением" ,(it "продолжением") вычисления.])
      (p [Таким образом, в любой точке во время вычисления любого выражения есть продолжение, готовое завершить или, по
          крайней мере, продолжить вычисление с этой точки. Предположим, что ,(var "x") имеет значение ,(var "(a b c)"). Мы можем выделить
          шесть продолжений во время выполнения ,(var "(если (null? X) (quote ()) (cdr x))"), продолжения ожидают])

      (enumerate
         (item [значение ,(var "(if (null? x) (quote ()) (cdr x))"), ])
         (item [значение ,(var "(null? х)"), ])
         (item [значение ,(var "null?"), ])
         (item [значение ,(var "х"), ])
         (item [значение ,(var "cdr"), и])
         (item [значение ,(var "х") (снова).]))

      (p [Продолжение ,(var "(cdr x)") не указано в списке, поскольку оно совпадает с продолжением ,(var "(if (null? X) (quote ()) (cdr x))").])
      (p [Scheme позволяет фиксировать продолжение любого выражения с помощью процедуры ,(var "call/cc"). ,(var "call/cc") должна быть
          передана процедура ,(var "p") с одним аргументом. ,(var "call/cc") создает конкретное представление текущего продолжения и
          передает его в ,(var "p"). Само продолжение представлено процедурой ,(var "k"). Каждый раз, когда ,(var "k") применяется к значению, оно
          возвращает значение в продолжение от вызова ,(var "call/cc"). Это значение становится, по сути, значением вызова ,(var "call/cc")
          (результатом).])
      (p [Если ,(var "p") возвращается без вызова ,(var "k"), значение, возвращаемое процедурой, становится значением приложения ,(var "call/cc").])
      (p [Рассмотрим простые примеры ниже.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-example-1|#")

      (p [В первом примере продолжение захватывается и связывается с ,(var "k"), но ,(var "k") никогда не используется, поэтому результатом
          является просто произведением 5 и 4. Во втором, продолжение вызывается перед умножением, поэтому результатом
          является значение, переданное в продолжение, 4. В третьем продолжение дополнено сложением с 2; таким образом,
          результат - это значение, переданное продолжению 4 плюс 2.])
      (p [Вот менее тривиальный пример, показывающий использование ,(var "call/cc") для обеспечения нелокального выхода из рекурсии.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-product|#")

      (p [Нелокальный выход позволяет ,(var "product") возвращать результат немедленно, без выполнения остальных умножений, при
          обнаружении нулевого значения.])
      (p [Каждый из приведенных выше вызовов продолжения возвращается к продолжению, в то время как управление остается в
          пределах процедуры, переданной в ,(var "call/cc"). В следующем примере используется продолжение после того, как эта
          процедура уже вернула значение.])

      (src "
(let ([x (call/cc (lambda (k) k))])
  (x (lambda (ignore) \"hi\"))) → \"hi\"")

      (p [Продолжение, захваченное этим вызовом ,(var "call/cc"), может быть описано как \"возьмите значение, свяжите его с ,(var "x") и
          примени значение ,(var "x") к значению ,(var (lambda (ignore) "hi"))\". Поскольку ,(var "(lambda (k) k)") возвращает свой аргумент, ,(var "x")
          связан с самим продолжением; это продолжение применяется к процедуре, полученной в результате выполнения ,(var "(lambda
          (ignore) \"hi\")") . Это имеет эффект привязки ,(var "x") (снова!) к этой процедуре и применения процедуры к себе. Процедура
          игнорирует свой аргумент и возвращает "hi".])
      (p [Следующий вариант приведенного выше примера, вероятно, является самой запутанной программой Scheme своего размера;
          может быть легко догадаться, что он возвращает, но нужно подумать, почему.])

      (src "(((call/cc (lambda (k) k)) (lambda (x) x)) \"HEY!\") → \"HEY!\"")

      (p [Значение ,(var "call/cc") является его собственным продолжением, как в предыдущем примере. Это применяется к процедуре
          возвращающей свой аргумент ,(var "(lambda (x) x)"), поэтому ,(var "call/cc") возвращается второй раз с этим значением. Затем
          процедура, возвращающая свой аргумент, применяется к себе, возвращая процедуру, возвращающую свой аргумент. Наконец,
          это применяется к ,(var "HEY!"), В результате получается ,(var "HEY!").])
      (p [Продолжения, используемые таким образом, не всегда так озадачивают. Рассмотрим следующее определение факториала,
          которое сохраняет продолжение в основе рекурсии перед возвратом 1, присваивая его переменной верхнего уровня
          ,(var "retry").])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-factorial|#")

      (p [С этим определением ,(var "factorial") работает так, как мы ожидаем от факториала, за исключением того, что он имеет
          побочный эффект назначения повторных попыток.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-example-2|#")

      (p [Продолжение, связанное с ,(var "retry"), может быть описано как «Умножьте значение на 1, затем умножьте этот результат на
          2, затем умножьте этот результат на 3, а затем умножьте этот результат на 4». Если мы передадим продолжению другое
          значение, т. е. не 1, мы заставим базовое значение отличаться от 1 и, следовательно, изменим конечный результат.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-example-3|#")

      (p [Этот механизм может быть основой для пакета точек останова, реализованного с помощью ,(var "call/cc"); каждый раз, когда
          встречается точка останова, продолжение точки останова сохраняется, так что вычисление может быть перезапущено с
          точки останова (более одного раза, если это необходимо).])
      (p [Продолжения могут быть использованы для реализации различных форм многозадачности. Простой механизм «облегченного
          процесса», определенный ниже, позволяет чередовать несколько вычислений. Поскольку он не является вытесняющим, он
          требует, чтобы каждый процесс время от времени добровольно «приостанавливался», чтобы другие могли работать.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-example-4|#")

      (p [Следующие легкие процессы взаимодействуют, чтобы напечатать бесконечную последовательность строк, содержащих "hey!".])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-example-5|#")

      (p [См. Раздел 12.11 для реализации механизмов, которые поддерживают вытесняющую многозадачность, с ,(var "call/cc").])

      (subsection :title "Упражнение"
         (p [Используйте ,(var "call/cc"), чтобы написать программу, которая зацикливается бесконечно, печатая последовательность
             чисел, начинающуюся с нуля. Не используйте никаких рекурсивных процедур и не используйте никаких присвоений.]))
      (subsection :title "Упражнение"
         (p [Перепишите ,(var "product") без ,(var "call/cc"), сохранив функцию, при которой лишнее умножения не выполняются, если любой из
             элементов списка равен нулю.]))
      (subsection :title "Упражнение"
         (p [Что произойдет, если процесс, созданный ,(var "lwp"), как определено выше, завершится, то есть просто вернет значение без
             вызова ,(var "pause")? Определите процедуру выхода, которая позволяет завершать процесс, не влияя иначе на систему ,(var "lwp").
             Обязательно разберитесь со случаем, когда единственный оставшийся процесс завершается.]))
      (subsection :title "Упражнение"
         (p [Каждый раз, когда вызывается ,(var "lwp"), список процессов копируется, потому что ,(var "lwp") использует ,(var "append") для
             добавления своего аргумента в конец списка процессов. Измените исходный код ,(var "lwp"), чтобы использовать тип данных
             очереди, разработанный в разделе 2.9, чтобы избежать этой проблемы.]))
      (subsection :title "Упражнение"
         (p [Механизм облегченных процессов позволяет создавать новые процессы динамически, хотя пример, приведенный в этом
             разделе, этого не делает. Придумайте приложение, которое требует динамического создания новых процессов, и
             реализцйте его, используя механизм облегченных процессов.])))

   (section :title [Стиль передачи продолжений]
      (p [Как мы уже говорили в предыдущем разделе, продолжение ожидает значения каждого выражения. В частности, продолжения
          связанные с каждым вызовом процедуры. Когда одна процедура вызывает другую посредством нехвостого вызова, вызываемая
          процедура получает неявное продолжение, которое отвечает за завершение того, что осталось от тела вызывающей
          процедуры, плюс возврат к продолжению вызывающей процедуры. Если вызов является хвостовым, вызываемая процедура
          просто получает продолжение вызывающей процедуры.])
      (p [Мы можем сделать продолжения явными, заключив "что делать" в явный процедурный аргумент, передаваемый при каждом
          вызове. Например, продолжение вызова ,(var "f") в])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-style-1|#")

      (p [помещает символ ,(var "b") в возвращаемое ему значение, а затем возвращает результат этих объединений в продолжение вызова
          ,(var "g"). Это продолжение аналогично продолжению вызова ,(var "h"), который помещает символ ,(var "d") в возвращаемое ему значение. Мы
          можем переписать это в стиле передачи продолжения, или ,(it "CPS") (англ. continuation-passing style, стиль передачи
          продолжений), заменив эти неявные продолжения явными процедурами.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-style-2|#")

      (p [Как и неявное продолжение ,(var "h") и ,(var "g") в предыдущем примере, явное продолжение передается в ,(var "h") и ,(var "g"), ])

      (src "(lambda (v) (cons 'd v))")

      (p [добавляет символ ,(var "d") в значение, переданное ему. Аналогично, продолжение переданное ,(var "f"), ])

      (src "(lambda (v) (k (cons 'b v)))")

      (p [добавляет ,(var "b") в переданное ему значение, а затем передает это в продолжение ,(var "g").])
      (p [Выражения, написанные на CPS, конечно, сложнее, но у этого стиля программирования есть несколько полезных
          приложений. CPS позволяет процедуре передать более одного результата своему продолжению, поскольку процедура,
          реализующая продолжение, может принимать любое количество аргументов.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-style-3|#")

      (p [(Это также может быть сделано с несколькими значениями; см. Раздел 5.8.) CPS также позволяет процедуре принимать
          отдельные продолжения "успех" и "неудача", которые могут принимать различное количество аргументов. Примером
          является целочисленное деление ниже, которое передает частное и остаток первых двух аргументов своему третьему, если
          только второй аргумент (делитель) не равен нулю, и в этом случае он передает сообщение об ошибке своему четвертому
          аргументу.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-style-4|#")

      (p [Процедура ,(var "quotient"), используемая в ,(var "integer-divide"), возвращает частное от двух его аргументов, усеченных до нуля.])
      (p [Явные продолжения для успеха и неудачи иногда могут помочь избежать дополнительной коммуникации, необходимой для
          отделения успешного выполнения процедуры от неудачного выполнения. Кроме того, возможно иметь несколько успешных или
          неудачных продолжений для разных разновидностей успеха или неудачи, каждый из которых может принимать разное число и
          тип аргументов. См. разделы 12.10 и 12.11 для расширенных примеров, которые используют стиль передачи продолжения.])
      (p [В этот момент вы можете задаться вопросом о связи между CPS и продолжениями, записанными через
          ,(var "call/cc"). Оказывается, что любая программа, использующая ,(var "call/cc"), может быть переписана в CPS без ,(var "call/cc"), но
          может потребоваться полное переписывание программы (иногда даже с учетом системных примитивов). Попробуйте
          преобразовать пример ,(var "product") из главы 3.3 в CPS, прежде чем смотреть на версию ниже.])

      (include-src "src/scheme/going_further.scm" "#|+call/cc-style-5|#")

      (subsection :title "Упражнение"
         (p [Перепишите пример ,(var "reciprocal"), впервые приведенный в Разделе 2.1, чтобы принимать как успешные, так и неудачные
             продолжения, как это сделано в ,(var "integer-divide") выше.]))
      (subsection :title "Упражнение"
         (p [Перепишите пример с ,(var "retry") используя CPS.]))
      (subsection :title "Упражнение"
         (p [Перепишите следующее выражение в CPS, чтобы избежать использования ,(var "call/cc").])
         (include-src "src/scheme/going_further.scm" "#|+call/cc-style-6|#")))

   (section :title [Внутренние объявления]
      (p [В разделе 2.6 мы обсудили определения верхнего уровня. Определения могут также появляться в начале тела
          лямбда-выражения, ,(var "let") или ,(var "letrec"), и в этом случае создаваемые ими привязки являются локальными для тела.])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-1|#")

      (p [Процедуры, связанные внутренними определениями, могут быть взаимно рекурсивными, как с ,(var "letrec"). Например, мы можем
          переписать ,(var "even?") и ,(var "odd?") из примера из раздела 3.2 с использованием внутренних определений следующим образом.])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-2|#")

      (p [Точно так же мы можем заменить использование ,(var "letrec") для связывания ,(var "race") внутренним определением ,(var "race") в нашем
          первом определении ,(var "list?").])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-3|#")

      (p [Фактически, внутреннее определение переменных и ,(var "letrec") практически взаимозаменяемы. Единственная разница, кроме
          очевидной разницы в синтаксисе, состоит в том, что определения переменных гарантированно будут выполняться слева
          направо, а связывания ,(var "letrec") могут выполняться в любом порядке. Поэтому мы не можем полностью заменить тело
          лямбда-выражения, ,(var "let") или ,(var "letrec"), содержащие внутренние определения, выражением ,(var "letrec"). Однако мы можем
          использовать ,(var "letrec*"), который, как и ,(var "let*"), гарантирует порядок выполнения слева направо. Тело следующего вида])

      (src-lite "
(define var expr0)
...
expr1
expr2
...")

      (p [эквивалентно выражению ,(var "letrec*"), связывающему определенные переменные со ассоциативными значениями в теле,
          содержащем выражения.])

      (src-lite "(letrec* ((var expr0) ...) expr1 expr2 ...)")

      (p [И наоборот, ,(var "letrec*") вида])

      (src-lite "(letrec* ((var expr0) ...) expr1 expr2 ...)")

      (p [может быть заменено выражением ,(var "let"), содержащим внутренние определения и выражения из тела следующим образом.])

      (src-lite "
(let ()
  (define var expr0)
  ...
  expr1
  expr2
  ...
)")

      (p [Кажущееся отсутствие симметрии между этими преобразованиями связано с тем, что выражения ,(var "letrec*") могут появляться
          везде, где выражение допустимо, тогда как внутренние определения могут появляться только в начале тела. Таким
          образом, заменяя ,(var "letrec*") внутренними определениями, мы обычно должны вводить выражение ,(var "let") для хранения
          определений.])
      (p [Другое различие между внутренними определениями и ,(var "letrec") или ,(var "letrec*") заключается в том, что синтаксические
          определения могут появляться среди внутренних определений, тогда как ,(var "letrec") и ,(var "letrec*") связывают только
          переменные.])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-4|#")

      (p [Область действия синтаксического расширения, созданного внутренним определением синтаксиса, так же как и область
          определения внутренней переменной, ограничены телом, в котором появляется определение.])
      (p [Внутренние определения могут использоваться вместе с определениями и назначениями верхнего уровня, что помогает
          разбивать программаму на модули. Каждый модуль программы должен делать видимыми только те привязки, которые нужны
          другим модулям, в то же время скрывая другие привязки, которые в противном случае загромождают пространство имен
          верхнего уровня и, возможно, приводят к непреднамеренному использованию или переопределению этих привязок. Общий
          способ структурирования модуля показан ниже.])

      (src-lite "
(define export-var #f)
 ...
(let ()
  (define var expr)
  ...
  init-expr
  ...
  (set! export-var export-val)
  ...
)")

      (p [Первый набор определений устанавливает привязки верхнего уровня для переменных, которые мы хотим экспортировать
          (сделать видимыми глобально). Второй набор определений устанавливает локальные привязки, видимые только внутри
          модуля. Выражения ,(var "init-expr ...") выполняют любую инициализацию, которая должна произойти после установления
          локальных связываний. Наконец ,(var "set!") выражения присваивают экспортируемым переменным соответствующие значения.])
      (p [Преимущество этой формы модульности заключается в том, что охватывающее выражение ,(var "let") может быть удалено или
          закомментировано во время разработки программы, что делает внутренние определения определениями верхнего уровня, для
          облегчения интерактивного тестирования. Эта форма модульности также имеет несколько недостатков, как мы обсудим в
          следующем разделе.])
      (p [Следующий модуль экспортирует одну переменную ,(var "calc"), которая связана с процедурой, реализующей простой
          четырехфункциональный калькулятор.])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-5|#")

      (p [В этом примере используется выражение ,(var "case"), чтобы определить, какой оператор применить. ,(var "case") аналогичен ,(var "cond"),
          за исключением того, что тест всегда одинаков: ,(var "(memv val (key ...))"), где ,(var "val") - значение первой подформы ,(var "case"),
          а ,(var "(key ...)") - список элементов в начале каждого случая ,(var "case"). Выражение ,(var "case") в приведенном выше примере можно
          переписать с помощью ,(var "cond") следующим образом.])

      (include-src "src/scheme/going_further.scm" "#|+internal-definitions-6|#")

      (subsection :title "Упражнение"
         (p [Переопределите ,(var "complain") в примере ,(var "calc") как эквивалентное синтаксическое расширение.]))
      (subsection :title "Упражнение"
         (p [В примере ,(var "calc") продолжение ошибки ,(var "ek") передается при каждом вызове ,(var "apply-op"), ,(var "complain") и
             ,(var "do-calc"). Переместите определения ,(var "apply-op"), ,(var "complain") и ,(var "do-calc") внутрь, насколько это необходимо, чтобы
             исключить аргумент ,(var "ek") из определений и применений этих процедур.]))
      (subsection :title "Упражнение"
         (p [Исключите ,(var "call/cc") из ,(var "calc") и перепишите ,(var "complain"), чтобы вызвать исключение с использованием
             ,(var "assertion-violation").]))
      (subsection :title "Упражнение"
         (p [Расширьте ,(var "calc") для обработки унарных выражений ,(var "minus"), например, ])

         (src-lite "(calc '(minus (add 2 3))) → -5")

         (p [и другие операторы на ваш выбор.])))

   (section :title [Библиотеки]
      (p [В конце предыдущего раздела мы обсудили форму модульности, которая включает в себя присвоение набора переменных
          верхнего уровня из ,(var "let"), сохраняя неопубликованные помощники локальными для ,(var "let"). Эта форма модульности имеет
          несколько недостатков:])
      (itemize
         (item [Это непереносимо, потому что поведение и даже существование интерактивного верхнего уровня не гарантируется
                Revised6 Report.])
         (item [Это требует назначений, которые делают код несколько неуклюжим и могут препятствовать анализу и оптимизации
                компилятора.])
         (item [Он не поддерживает публикацию привязки ключевых слов, так как нет аналога ,(var "set!") для ключевых слов.]))
      (p [Альтернативой, которая не разделяет эти недостатки, является создание библиотеки. Библиотека экспортирует набор
          идентификаторов, каждый из которых определен в библиотеке или импортирован из какой-либо другой
          библиотеки. Экспортированный идентификатор не обязательно должен быть связан как переменная; вместо этого он может
          быть связан как ключевое слово.])
      (p [Следующая библиотека экспортирует два идентификатора: переменная ,(var "gpa->grade") и ключевое слово ,(var "gpa"). Переменная
          ,(var "gpa->grade") связана с процедурой, которая принимает средний балл (GPA), представленный в виде числа, и возвращает
          соответствующую буквенную оценку по четырехбалльной шкале. Ключевое слово ,(var "gpa") называет синтаксическое расширение,
          чьи подчиненные формы должны быть буквенными оценками, а значение - это GPA, вычисленный из этих буквенных оценок.])

      (include-src "src/scheme/going_further.scm" "#|+libraries-1|#")

      (p [Название библиотеки ,(var "(grades)"). Это может показаться странным названием, но все имена библиотек заключены в
          скобки. Библиотека импортирует из стандартной библиотеки (rnrs), которая содержит большинство примитивов и привязок
          ключевых слов, которые мы использовали в этой и последней главе, и все, что нам нужно для реализации ,(var "gpa->grade") и
          ,(var "gpa").])
      (p [Наряду с ,(var "gpa->grade") и ,(var "gpa"), в библиотеке определены несколько других синтаксических расширений и процедур, но ни
          одна из них не экспортируется. Те, которые не экспортируются, являются просто помощниками для тех, которые
          экспортируются. Все, что используется в библиотеке, должно быть знакомо, за исключением процедуры ,(var "apply"), которая
          описана в главе 5.1.])
      (p [Если ваша реализация Scheme поддерживает импорт на интерактивном верхнем уровне, вы можете протестировать два
          экспорта, как показано ниже.])

      (include-src "src/scheme/going_further.scm" "#|+libraries-2|#")

      (p [Глава 10 описывает библиотеки более подробно и предоставляет дополнительные примеры их использования.])

      (subsection :title "Упражнение"
         (p [Измените ,(var "gpa") для обработки оценок "х", которые не учитываются в среднем балле. Будьте осторожны, чтобы изящно
            справиться с ситуацией, когда все оценки равны "x".])

         (include-src "src/scheme/going_further.scm" "#|+libraries-3|#"))

      (subsection :title "Упражнение"
         (p [Экспортируйте из ,(var "(grades)") новую синтаксическую форму, ,(var "distribution"), которая принимает набор оценок, например,
             ,(var "gpa"), но возвращает список вида ,(var "((ng) ...)"), где ,(var "n") - количество раз, когда ,(var "g") появляется в наборе для каждой
             записи ,(var "g"). Пусть ,(var "distribution") вызывает неэкспортированную процедуру для выполнения реальной работы.])

         (src "
(import (grades))
(distribution a b a c c c a f b a) → ((4 a) (2 b) (3 c) (0 d) (1 f))"))

      (subsection :title "Упражнение"
         (p [Теперь прочитайте об операциях вывода в Разделе 7.8 и определите новый экспорт, ,(var "histogram"), как процедуру, которая
             принимает текстовый порт вывода и распределение, которое может быть произведено ,(var "distribution"), и печатает
             гистограмму в стиле, проиллюстрированном примером ниже.])

         (src "
(import (grades))
(histogram
  (current-output-port)
  (distribution a b a c c a c a f b a))")

         (p [напечатает:])

         (src-lite "
a: *****
b: **
c: ***
d:
f: *"))))