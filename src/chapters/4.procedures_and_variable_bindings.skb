;;; -*- coding: utf-8; tab-width: 4; c-basic-offset: 2; indent-tabs-mode: nil; fill-column: 120; -*-

(chapter :title "Связывания процедур и переменных"
   (chapter-image "images/ch4.png")
   (p [Процедуры и привязки переменных являются основными строительными блоками Scheme программ. В этой главе описывается
       небольшой набор синтаксических форм, основной целью которых является создание процедур и управление привязками
       переменных. Он начинается с двух самых фундаментальных строительных блоков программ Scheme: ссылок на переменные и
       лямбда-выражений и продолжается описанием форм привязки и назначения переменных, таких как ,(var "define"), ,(var "letrec"),
       ,(var "let-values") и ,(var "set!").])
   (p [Различные другие формы, которые связывают или присваивают переменные, для которых привязка или присваивание не
       является основной целью (например, именованный ,(var "let")), описаны в главе 5.])
   (section :title "Ссылки на переменные"
      (formdef
      :syntax "variable"
      :returns "значение переменной")
      (p [Любой идентификатор, появляющийся как выражение в программе, является переменной, если существует видимая привязка
          переменной для идентификатора, например, идентификатор появляется в пределах области привязки, созданной при помощи
          ,(var "define"), ,(var "lambda"), ,(var "let") или другой конструкции привязки переменной.])

      (src "list → #<procedure>
(define x 'a)
(list x x) → (a a)
(let ([x 'b])
  (list x x)) → (b b)
(let ([let 'let]) let) → let")

      (p [Это синтаксическое нарушение, когда ссылка на идентификатор появляется внутри формы ,(var "library") или программы
          верхнего уровня, если она не связана как переменная, ключевое слово, имя записи или другая сущность. В случае, если
          область определения это все тело, будь то библиотеки, программы верхнего уровня, лямбды или другого локального тела,
          нет необходимости, чтобы определение переменной появлялось до того, как появится первая ссылка на неё, если только
          не пытаться получить значение по ссылке, пока определение не будет завершено. Так, например, ссылка на ,(var "g") в
          определении ,(var "f") ниже]))

   (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+variables-bindings-2|#")

   (p [это нормально, но ссылка на ,(var "g") в определении ,(var "q") ниже нет.])

   (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+variables-bindings-3|#")

   (section :title "lambda"
      (formdef
      :syntax "(lambda formals body1 body2 ...)"
      :returns "процедуру"
      :libraries "(rnrs base), (rnrs)")
      (p [Синтаксическая форма ,(var "lambda") используется для создания процедур. Любая операция, которая создает процедуру или
          устанавливает привязки локальных переменных, в конечном итоге определяется в терминах ,(var "lambda") или ,(var "case-lambda").])
      (p [Переменные ,(var "formals") являются формальными параметрами процедуры, а последовательность подвыражений ,(var "body1 body2 ...")
          является ее телом.])
      (p [Тело может начинаться с последовательности определений, и в этом случае привязки, созданные определениями, являются
          локальными для тела. Если определения присутствуют, привязки ключевых слов используются и отбрасываются при
          раскрытии тела, а тело ракрывается в выражение ,(var "letrec*"), сформированного из определений переменных и оставшихся
          выражений. Остальная часть описания лямбда-выражения предполагает, что это преобразование имело место, если
          необходимо, так что тело является последовательностью выражений без определений.])
      (p [Когда процедура создана, привязки всех переменных, свободно встречающихся в теле, за исключением формальных
          параметров, сохраняются вместе с процедурой. Впоследствии всякий раз, когда процедура применяется к
          последовательности фактических параметров, формальные параметры привязываются к фактическим параметрам, сохраненные
          привязки восстанавливаются, и тело выполняется.])
      (p [При применении формальные параметры, ,(var "formals"), привязываются к фактическим параметрам следующим образом.])
      (itemize
         (item [Если ,(var "formals") - это правильный список переменных, например, ,(var "(x y z)"), каждая переменная связывается с
                соответствующим фактическим параметром. Выбрасывается исключение с типом ,(var "?&assertation"), если задано
                слишком мало или слишком много фактических параметров.])
         (item [Если ,(var "formals") - это одна переменная (не из списка), например, ,(var "z"), она привязывается к списку фактических
                параметров.])
         (item [Если ,(var "formals") - это неправильный список переменных, оканчивающихся переменной, например, ,(var "(x y. z)"), каждая
                переменная, кроме последней, связывается с соответствующим фактическим параметром. Последняя переменная
                связывается со списком оставшихся фактических параметров. Выбрасывается исключение с типом ,(var "&assertation"), если
                предоставлено слишком мало фактических параметров.]))
      (p [Когда тело выполняется, выражения в теле вычисляются последовательно, и процедура возвращает значения последнего
          выражения.])
      (p [Процедуры не имеют печатного представления в обычном смысле. Системы Scheme отображают процедуры по-разному; эта
          книга использует обозначение ,(var "#<procedure>").])

      (src "(lambda (x) (+ x 3)) → #<procedure>
((lambda (x) (+ x 3)) 7) → 10
((lambda (x y) (* x (+ x y))) 7 13) → 140
((lambda (f x) (f x x)) + 11) → 22
((lambda () (+ 3 4))) → 7

((lambda (x . y) (list x y))
 28 37) → (28 (37))
((lambda (x . y) (list x y))
 28 37 47 28) → (28 (37 47 28))
((lambda (x y . z) (list x y z))
 1 2 3 4) → (1 2 (3 4))
((lambda x x) 7 13) → (7 13)"))

   (section :title "case-lambda"
      (p [Лямбда-выражение Scheme всегда создает процедуру с фиксированным числом аргументов или с неопределенным числом
          аргументов, большим или равным определенному числу. В частности, ])

      (src-lite "(lambda (var1 ... varn) body1 body2 ...)")

      (p [принимает ровно ,(var "n") аргументов, ])

      (src-lite "(lambda r body1 body2 ...)")

      (p [принимает ноль или более аргументов, и])

      (src-lite "(lambda (var1 ... varn . r) body1 body2 ...)")

      (p [принимает ,(var "n") или более аргументов.])
      (p [Однако лямбда не может напрямую произвести процедуру, которая принимает, скажем, два или три аргумента. В частности,
          процедуры, которые принимают необязательные аргументы, напрямую не поддерживаются лямбда-выражением. Последняя форма
          лямбды, показанная выше, может использоваться в сочетании с проверками длины и комбинациями ,(var "car") и ,(var "cdr") для
          реализации процедур с необязательными аргументами, хотя и за счет ясности и эффективности.])
      (p [Синтаксическая форма ,(var "case-lambda") напрямую поддерживает процедуры с необязательными аргументами, а также процедуры
          с фиксированным или неопределенным числом аргументов. ,(var "case-lambda") основана на синтаксической форме ,(var "lambda*"),
          представленной в статье «Новый подход к процедурам с переменной арностью» ,(ref :bib 'b11).])
      (formdef
      :syntax "(case-lambda clause ...)"
      :returns "процедуру"
      :libraries "(rnrs control), (rnrs)")
      (p [,(var "case-lambda") выражение состоит из набора клауз, каждая из которых напоминает лямбда-выражение. Каждая клауза имеет
          форму, представленную ниже.])
      (src-lite "[formals body1 body2 ...]")

      (p [Формальные параметры клаузы определяются ,(var "formals") так же, как для лямбда-выражения. Количество аргументов,
          принимаемых ,(var "case-clause"), определяется количеством аргументов, принимаемых отдельными клаузами.])
      (p [Когда вызывается процедура, созданная с помощью ,(var "case-lambda"), клаузы проверяются на соответствие по
          порядку. Выбирается первая клаузы, которая принимает заданное количество фактических параметров, формальные
          параметры, определенные его формальными значениями, привязываются к соответствующим фактическим параметрам, и тело
          выполняется, как описано выше для лямбды. Если ,(var "formals") в клаузе - это правильный список идентификаторов, то клауза
          принимает ровно столько фактических параметров, сколько формальных параметров (идентификаторов) в ,(var "formals"). Как и в
          случае ,(var "formals") для ,(var "lambda"), в ,(var "formals") ,(var "case-lambda") выражений может быть один идентификатор, в этом случае
          клауза принимает любое количество аргументов, или неправильный список идентификаторов, оканчивающийся
          идентификатором, и в этом случае клауза принимает любое количество аргументов, большее или равное количеству
          формальных параметров, исключая последний идентификатор. Если ни одна из клауз не принимает количество
          предоставленных фактических параметров, возникает исключение с типом ,(var "&assertation").])
      (p [Следующее определение для ,(var "make-list") использует ,(var "case-lambda") для поддержки необязательного параметра заполнителя.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'make-list)

      (p [Процедура ,(var "substring") может быть расширена с помощью ,(var "case-lambda"), чтобы принимать либо отсутствие конечного
          индекса, в этом случае по умолчанию используется конец строки, либо отсутствие начального и конечного индексов, в
          этом случае ,(var "substring") эквивалентна ,(var "string-copy"):])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'substring1)

      (p [Также возможно по умолчанию использовать начальный индекс, а не конечный, если указан только один индекс:])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'substring2)

      (p [Можно даже потребовать, чтобы оба или ни один из начального и конечного индексов были предоставлены, просто
          опустив среднюю клаузу:])
      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'substring3))

   (section :title "Локальные связывания"
      (formdef
      :syntax "(let ((var expr) ...) body1 body2 ...)"
      :returns "значение последнего выражения в теле"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "let") устанавливает привязки локальных переменных. Каждая переменная ,(var "var") связана со значением соответствующего
          выражения ,(var "expr"). Тело ,(var "let"), в котором связаны переменные, является последовательностью сабформ ,(var "body1 body2 ...") и
          обрабатывается и выполняется как тело лямбда-выражения.])
      (p [Формы ,(var "let"), ,(var "let*"), ,(var "letrec") и ,(var "letrec*") (остальные описаны после ,(var "let")) похожи, но служат несколько разным
          целям. С ,(var "let"), в отличие от ,(var "let*"), ,(var "letrec") и ,(var "letrec*"), выражения ,(var "expr ...") находятся вне области видимости
          переменных ,(var "var ..."). Кроме того, в отличие от ,(var "let*") и ,(var "letrec*"), упорядочение не подразумевается при выполнении
          выражений ,(var "expr ..."). Они могут выполняться слева направо, справа налево или в любом другом порядке по усмотрению
          реализации. Используйте ,(var "let") всякий раз, когда значения не зависят от переменных, а порядок вычисления не важен.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+local-bindings-1|#")

      (p [Следующее определение ,(var "let") показывает типичное происхождение ,(var "let") из ,(var "lambda").])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'let)

      (p [Другая форма ,(var "let"), именованный ,(var "let"), описана в разделе 5.4, а полное определение ,(var "let") можно найти в разделе 8.4.])

      (formdef
      :syntax "(let* ((var expr) ...) body1 body2 ...)"
      :returns "значение последнего выражения в теле"
      :libraries "(rnrs base), (rnrs)")

      (p [,(var "let*") аналогичен ,(var "let"), за исключением того, что выражения ,(var "expr ...") вычисляются в последовательности слева
          направо, и каждое из этих выражений находится в области видимости переменных слева. Используйте ,(var "let*"), когда
          существует линейная зависимость между значениями или когда важен порядок выполнения.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+local-bindings-2|#")

      (p [Любое выражение ,(var "let*") может быть преобразовано во множество вложенных выражений ,(var "let"). Следующее определение ,(var "let*")
          демонстрирует типичное преобразование.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'let*)

      (formdef
      :syntax "(letrec ((var expr) ...) body1 body2 ...)"
      :returns "значение последнего выражения в теле"
      :libraries "(rnrs base), (rnrs)")

      (p [,(var "letrec") аналогичен ,(var "let") и ,(var "let*"), за исключением того, что все выражения ,(var "expr ...") находятся в области видимости
          всех переменных ,(var "var ..."). ,(var "letrec") позволяет определять взаимно рекурсивные процедуры.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+local-bindings-3|#")

      (p [Порядок вычисления выражений ,(var "expr ...") не определен, поэтому программа не должна использовать ссылки на любую из
          переменных, связанных выражением ,(var "letrec"), до того, как будут вычислены все значения. (Вхождение переменной в
          лямбда-выражение не считается ссылкой, если только результирующая процедура не будет применена до того, как будут
          вычислены все значения.) Если это ограничение нарушается, возникает исключение с типом ,(var "&assertation").])
      (p [,(var "expr") не должен возвращать более одного раза. То есть оно не должен возвращать как обычно, так и через вызов
          продолжения, полученного во время его выполнения, и оно не должено возвращать дважды через два вызова такого
          продолжения. Реализации не обязаны обнаруживать нарушение этого ограничения, но если они это делают, возникает
          исключение с типом ,(var "&assertation").])
      (p [Выберайте ,(var "letrec") вместо ,(var "let") или ,(var "let*"), когда существует круговая зависимость между переменными и их значениями
          и когда порядок выполнения не важен. Выберайте ,(var "letrec*") вместо ,(var "letrec"), когда существует циклическая зависимость,
          и привязки должны выполняться слева направо.])
      (p [Выражение формы ,(var "letrec")])

      (src-lite [(letrec ((var expr) ...) body1 body2 ...)])

      (p [может быть выражено в терминах ,(var "let") и ,(var "set!")])

      (src "(let ((var #f) ...)
  (let ((temp expr) ...)
    (set! var temp) ...
    (let () body1 body2 ...)))")

      (p [где ,(var "temp ...") - свежие переменные, то есть переменные, которые еще не присутствуют в выражении ,(var "letrec"), по одной
          для каждой пары ,(var "(var expr)"). Внешнее выражение ,(var "let") устанавливает привязки переменных. Начальное значение,
          заданное для каждой переменной неважно, поэтому вместо ,(var "#f") может быть любое значение. Привязки устанавливаются
          первыми, чтобы ,(var "expr ...") мог содержать вхождения переменных, то есть, чтобы выражения вычислялись в области
          видимости переменных. Среднее значение ,(var "let") вычисляет значения и связывает их с временными переменными и ,(var "set!")
          выражение присваивают каждой переменной соответствующее значение. Внутренний ,(var "let") присутствует для случая, если
          тело содержит внутренние определения.])
      (p [Определение ,(var "letrec"), которое использует это преобразование, показано в разделе 8.3.])
      (p [Это преобразование не налагает ограничения на то, что выражения ,(var "expr") не должны выполнять какие-либо ссылки на
          переменные или их присваивания. Возможны более сложные преобразования, которые усиливают это ограничение и
          фактически производят более эффективный код ,(ref :bib 'b31).])


      (formdef
      :syntax "(letrec* ((var expr) ...) body1 body2 ...)"
      :returns "значение последнего выражения в теле"
      :libraries "(rnrs base), (rnrs)")

      (p [,(var "letrec*") аналогичен ,(var "letrec"), за исключением того, что ,(var "letrec*") вычисляет ,(var "expr ...") в последовательности слева
          направо. Хотя программы по-прежнему не должны использовать ссылку на какой-либо ,(var "var") до того, как соответствующий
          ,(var "expr") будет выполнен, ссылки на ,(var "var") могут быть выполнены в любое время после этого, в том числе во время
          выполнения ,(var "expr") любого последующего связывания.])
      (p [Форма выражения ,(var "letrec*")])

      (src-lite "(letrec* ((var expr) ...) body1 body2 ...)")

      (p [может быть выражена в терминах ,(var "let") и ,(var "set!")])

      (src "(let ((var #f) ...)
  (set! var expr) ...
  (let () body1 body2 ...))")

      (p [Внешнее выражение ,(var "let") создает связывания, каждое присваивание выполняет выражение и сразу устанавливает
          соответствующей переменной его значение по порядку, а внутренний ,(var "let") выполняет тело. ,(var "let") используется в
          последнем случае, поскольку, как и выражения, тело может содержать и внутренние определения.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+local-bindings-4|#"))

   (section :title "Множественные значения"
      (formdef
      :syntax '("(let-values ((formals expr) ...) body1 body2 ...)"
                "(let*-values ((formals expr) ...) body1 body2 ...)")
      :returns "значение последнего выражения"
      :libraries "(rnrs base), (rnrs)")
      (p [,(var "let-values") - это удобный способ получить несколько значений и связать их с переменными. Он структурирован как
          ,(var "let"), но в произвольной структурой левой части формальных параметров (например, ,(var "lambda")). ,(var "let*-values")
          аналогична, но выполняет привязки в порядке слева направо, как и в случае ,(var "let*"). Исключение с типом ,(var "&assertation")
          возникает, если число значений, возвращаемых выражением, не соответствует списку формальных параметров, как для
          ,(var "lambda") выше. Определение допустимых значений приведено в разделе 8.3.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+multiple-values-1|#"))
   (section :title "Объявление переменных"
      (formdef
      :syntax '("(define var expr)"
                "(define var)"
                "(define (var0 var1 ...) body1 body2 ...)"
                "(define (var0 . varr) body1 body2 ...)"
                "(define (var0 var1 var2 ... . varr) body1 body2 ...)")
      :libraries "(rnrs base), (rnrs)")
      (p [В первой форме ,(var "define") создает новое связывание ,(var "var") со значением ,(var "expr"). ,(var "expr") не должен возвращать более одного раза. То есть оно не должен возвращать как обычно, так и через вызов
          продолжения, полученного во время его выполнения, и оно не должено возвращать дважды через два вызова такого
          продолжения. Реализации не обязаны обнаруживать нарушение этого ограничения, но если они это делают, возникает
          исключение с типом ,(var "&assertation").])
      (p [Вторая форма эквивалентна ,(var "(define var unspecified)"), где ,(var "unspecified") - это некоторое неопределённое
          значение. Остальные - это сокращенные формы для привязки переменных к процедурам; они идентичны следующему
          определению с точки зрения ,(var "lambda").])
      (src-lite "(define var
  (lambda formals
    body1 body2 ...))")
      (p [где ,(var "formals") - это ,(var "(var1 ...)"), ,(var "varr") или ,(var "(var1 var2 .... varr)") для третьего, четвертого и пятого форматов.])
      (p [Определения могут появляться в начале тела библиотеки, в любом месте среди форм тела программы верхнего уровня, и в
          начале тела ,(var "lambda") или ,(var "case-lambda") или тела любой формы, полученной из ,(var "lambda"), например, ,(var "let"), или ,(var "letrec*").
          Любое тело, начинающееся с последовательности определений, преобразуется во время раскрытия макроса в выражение
          ,(var "letrec*"), как описано в главе 8.1.])
      (p [Определения синтаксиса могут появляться вместе с определениями переменных везде, где могут появляться определения
          переменных; см. главу 8.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+variable-definitions-1|#")

      (p [Набор определений можно сгруппировать, заключив их в форму ,(var "begin"). Определения, сгруппированные таким образом,
          могут появляться везде, где могут появляться определения обычных переменных и синтаксиса. Они интерпретируются так,
          как будто они написаны отдельно, то есть без заключения в форму ,(var "begin"). Эта функция позволяет синтаксическим
          расширениям раскрываться в группу определений.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+variable-definitions-2|#")

      (p [Многие реализации поддерживают интерактивный «верхний уровень», в котором переменные и другие определения могут
          вводиться интерактивно или загружаться из файлов. Поведение этих определений верхнего уровня выходит за рамки отчета
          ,(var "Revised6"), но касаемо того, что переменные верхнего уровня должны быть определены до того, как будут испольоваться
          или присваиваться, поведение является согласованным в большинстве реализаций. Так, например, ссылка на ,(var "g") в
          определении верхнего уровня для ,(var "f") ниже допустима, и это нормально, если ,(var "g") еще не определено, и предполагается,
          что ,(var "g") это имя переменной, которая должна быть определена в какой-то более поздний момент.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" :definition 'f)

      (p [Если за этим следует определение ,(var "g"), до выполнения ,(var "f"), то предположение о том, что ,(var "g") будет определена как
          переменная, подтверждается, и вызов ,(var "f") работает, как и ожидалось.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+variable-definitions-3|#")

      (p [Если вместо этого g было определено как ключевое слово для синтаксического расширения, предположение о том, что ,(var "g")
          будет связана как переменная, окажется ложным, и если ,(var "f") не переопределено до его вызова, реализация, вероятно,
          вызовет исключение.]))

   (section :title "Присваивания"
      (formdef
      :syntax "(set! var expr)"
      :returns "unspecified"
      :libraries "(rnrs base), (rnrs)")

      (p [,(var "set!") не устанавливает новую привязку для ,(var "var"), а изменяет значение существующей привязки. Сначала он вычисляет
          ,(var "expr"), а затем присваивает ,(var "var") значение ,(var "expr"). Любая последующая ссылка на ,(var "var") в рамках измененной привязки
          возвращает новое значение.])
      (p [Назначения не используются так часто в Scheme, как в большинстве других языков, но они полезны для реализации
          изменений состояния.])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+assignment-1|#")

      (p [Назначения также полезны для кэширования значений. В приведенном ниже примере используется метод, называемый
          мемоизацией, в котором процедура записывает значения, связанные со старыми входными значениями, поэтому нет
          необходимости пересчитывать их, чтобы реализовать быструю версию экспоненциального двукратно рекурсивного
          определения функции Фибоначчи (см. Раздел 3.2).])

      (include-src "src/scheme/procedures_and_variable_bindings.scm" "#|+assignment-2|#")))