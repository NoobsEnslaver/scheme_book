# -*- org-image-actual-width: 'true; -*-
# -*- fill-column: 120; -*-

#+STARTUP: nofninline
#+STARTUP: showall

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [11pt,fleqn, oneside]
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER: \usepackage[T1,T2A]{fontenc}
#+LATEX_HEADER: \usepackage[unicode]{hyperref}
#+LATEX_HEADER: \usepackage[english,russian]{babel}
#+LANGUAGE: RU
#+OPTIONS: toc:nil title:nil
#+TITLE: Язык программирования Scheme, 4-е издание
#+AUTHOR: R. Kent Dybvig

#+NAME: cover
#+ATTR_ORG: :width 300
[[./images/cover.png]]

#+LATEX: \newpage
#+LATEX: \tableofcontents

#+LATEX: \newpage

* Предисловие

  Язык Scheme увидел свет в 1975 году, благодаря стараниям Джеральда Дж.Суссмана и Гая Л.Стили младшего [fn:28],[fn:29], и
  был первым диалектом лиспа, полностью поддерживающим лексические области видимости, процедуры первого класса, и
  продолжения. В первоначальном виде это был очень простой язык, предназначенный, главным образом, для исследований и
  обучения, поддерживающий только небольшой набор предопределённых синтаксических форм и процедур. Сейчас Scheme -
  полноправный язык общего назначения, хотя он до сих пор черпает свою силу из небольшого набора ключевых идей. Ранние
  реализации языка были основаны на интерпретации и не отличались производительностью, однако сейчас существуют реализации
  Scheme, которые могут похвастаться сложными компиляторами, генерирующими код на ровне с кодом, генерируемым лучшими
  оптимизирующими компиляторами низкоуровневых языков, таких как C и Fortran.

  Данная книга нацелена на то, чтобы предоставить введение в язык программирования Scheme, но не в программирование в
  целом. Ожидается, что читатель уже имеет некоторый опыт в программировании и владеет терминами, обычно применяемыми в
  программировании. Читателю, не имеющему представления о Scheme и Lisp, следует сначала обратиться к ~The Little
  Schemer~ [fn:13], чтобы познакомиться с обработкой списков и рекурсией. Новичкам в программировании следует обратиться к
  литературе для новичков.

  Scheme был стандартизован как формально, так и неформально. IEEE стандарт ~Scheme Programming Language~ [fn:18]
  описывает формальный ANSI/IEEE стандарт для Scheme, однако он датирован 1991 годом. Связанная серия докладов 'Отчёты по
  пересмотру алгоритмического языка Scheme' ('Revised Reports on the Algorithmic Language Scheme') документируют
  развивающийся неофициальный стандарт, поддерживаемый большинством реализаций языка. Текущая версия отчёта из этой
  серии - 'Revised6 Report on the Algorithmic Language Scheme' [fn:24] была опубликована в 2007 году.

  Данная книга рассматривает версию языка, описываемую шестой версией (Revised6) отчёта. Она не нацелена на то, чтобы
  заменить данный отчёт, а скорее, предоставить более понятное введение и предметный указатель для языка, с более
  подробными разъяснениями и примерами, большего нацеленного на пользователей языка, а не разработчиков компиляторов для
  него. Описание возможностей, присущих конкретной реализации, отсутствует.

  В частности, возможности, специфичные для авторских реализаций ~Chez Scheme~ и ~Petite Chez Scheme~ описаны отдельно в
  Chez Scheme User's Guide [fn:9]. С другой стороны, не одна книга по Scheme не будет полной без описания интерактивной
  оболочки, поскольку почти каждая реализация Scheme поддерживает интерактивное использование системы в той или иной
  форме, не смотря на то, что данное поведение не стандартизировано Revised6 отчётом. Таким образом, в главах 2 и 3
  предполагается, что у читателя имеется реализация Scheme, которая поддерживает интерактивную оболочку, причем поведение
  соответствует описанию среды верхнего уровня в предыдущих отчетах и стандарту IEEE/ANSI.

  В тексте книги вы найдёте большое количество примеров маленького и среднего размера, а также отдельную главу,
  посвященную рассмотрению нескольких больших примеров. Большинство из них показывают, как могут быть реализованы
  стандартные синтаксические формы и процедуры Scheme, остальные - реализацию полезных расширений. Все эти примеры могут
  быть набраны непосредственно с клавиатуры в рамках сессии интерактивной оболочке.

  Книга разбита на 12 основных глав, плюс приложения. Глава 1 рассматривает те свойства и возможности языка Scheme,
  которые делают его полезным и приятным в использовании. В этой главе так же описаны типографические и нотационные
  соглашения, применяемые в этой книге.

  Глава 2 это введение в программирование на Scheme для начинающих Scheme-программистов, которая проведёт читателя через
  серию примеров, начиная с простейших выражений Scheme и продолжая всё более сложными примерами. Каждая секция второй
  главы представляет читателю маленький набор связанных функций языка, а в конце каждой секции содержится набор упражнений
  для дальнейшей практики. Читатель извлечёт значительно больше пользы из главы, если параллельно с чтением, будет сидеть
  за клавиатурой и набирать примеры и упражнения.

  Глава 3 так же содержит введение, но покрывает более сложные функции и принципы языка. Упражнения из этой главы могут
  быть интересны даже тем читателям, которые уже имеют некоторый опыт в Scheme.

  Главаы с 4 по 11 представляют из себя справочную часть книги. Здесь представлена каждая примитивная процедура и
  синтаксическая форма Scheme, которые, в свою очередь, сгруппированы в короткие секции связанных процедур и форм. Глава 4
  описывает операции объявления и присвоения процедур и переменных. Глава 5 - операции управления ходом выполнения
  программы. Глава 6 - операции над объектами различных типов (в т.ч. списки, числа, строки). Глава 7 - операции
  ввода-вывода. Глава 8 - расширение синтаксиса. Глава 9 - объявление типа данных 'запись'(record). Глава 10 - библиотеки
  и высокоуровневые (top-level) программы. Глава 11 - выражения и продолжения.

  Глава 12 содержит коллекцию примеров процедур, библиотек и программ, каждая с коротким обзором, примеры их
  использования, их реализация с краткими пояснениями и ряд упражнений для дальнейшей самостоятельной работы. Каждая из
  этих программ демонстрирует определённый функционал, а вместе они описывают стиль программирования, принятый в Scheme.

  Вслед за главой 12 идут библиографические ссылки, ответы на некоторые упражнения, полное описание формального синтаксиса
  программ и данных Scheme, включающее полный перечень синтаксических форм и процедур, а так же предметный
  указатель. Полный перечень форм и процедур полезен прежде всего как первое место, куда может заглянуть программист,
  неуверенный в структуре синтаксической формы или ожидаемых примитивной процедурой аргументах. Номера страниц,
  представленные в перечне форм и процедур, а так же номера страниц, выделенные курсивом, в предметном указателе,
  указывают местоположение в тексте, где было приведено описание данной процедуры или формы.

  В виду того, что справочная часть книги содержит такие аспекты языка, которые небыли представлены во введении, а так же
  ряд интересных, коротких примеров, для большинства читателей будет полезнее прочесть большую часть материала, чтобы
  познакомиться поближе с каждой возможностью языка и как это реализуется на других языках. Глава 6 является довольно
  длинной, так что она может быть пропущена при первом прочтении - обращайтесь к ней по мере необходимости, когда увидите
  ссылки на неё в тексте.

  Онлайн версия книги доступна по адресу http://www.scheme.com/tspl/ (русский перевод доступен по адресу
  http://github.com/noobsenslaver/scheme_book/releases). В полном перечне форм и в предметном указателе так же указаны
  номера страниц для печатной версии книги, так что ими можно пользоваться для облегчения поиска обладателям печатных
  версий книги.

  Касаемо иллюстраций: обложка и иллюстрация в начале каждой главы это алгоритмические композиции фонов линий, созданные
  художником Жаном-Пьером Эбертом, основанные на идее, вдохновленной трудами Джона Кейджа. Фон каждой линии вычисляется
  путём сопоставления некоего количества сеток параллельных линий. Каждая сетка регулярна, но линии нет. Например, линии
  имеют разную длину, что образует неровные края. Их тон и толщина немного отличаются. Они могут быть похожи, но не
  равны. Они пересекают друг друга под неким углом. Когда это угол мал, возникает интерференция. Линии сначала погружаются
  в различные скалярные поля, которые возмущают их исходную прямую форму, а потом проецируются на плоскость бумаги. Маски
  вводят отверстия в некоторых слоях. Для иллюстрации обложки сетки окрашены в разные оттенки.

  Все эти изображения созданы одной программой на Scheme, которая принимает большинство решений на вероятностной
  основе. Художник контролирует только размер холста, соотношение сторон, общую палитру цветов и уровни вероятности и
  нечеткости. Задача художника состоит в том, чтобы ввести достаточно шансов в нужном месте, чтобы результаты были
  одновременно удивительными, интересными и удовлетворяли эстетическому чувству художника. Это игра неопределенности,
  хаоса и гармонии.

  Благодарности: Многие люди так или иначе способствовали подготовке одного или нескольких изданий этой книги, в том числе
  Брюс Смит, Евгений Кольбекер, Маттиас Феллесинен, Дэн Фридман, Брюс Дуба, Фил Дыбвиг, Гай Стил, Боб Хиб, Крис Хейнс,
  Дэйв Плайед, Джоан Карри, Фрэнк Сильберманн, Павел Кертис, Джон Уайт, Карл Бруггман, Сэм Даниэль, Оскар Уодделл , Майк
  Эшли, Джон Лалонд, Джон Цукерман, Джон Симмонс, Боб Приор, Боб Бургер и Азиз Гулум. Многие другие предложили небольшие
  исправления и предложения. Оскар Уодделл помог создать систему набора, используемую для форматирования печатных и
  онлайн-версий этой книги. Небольшое количество текста и примеров было заимствовано из ~Revised6 отчёта~ и адаптировано
  для данной книги, за что благодарю авторов этого отчёта и многих других, кто способствовал его написанию. И наконец,
  самую большую благодарность я выражаю моей жене Сьюзан Дыбвиг, в первую очередь за то, что она предложила написать эту
  книгу, а так же за её неоценимую помощь в создании и публикации этого и предыдущих изданий.

#+LATEX: \newpage
[[./images/ch1.png]]

** Введение.

   Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
   типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
   данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
   имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
   языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
   графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
   реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
   изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
   природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
   полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.

   Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
   Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
   между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
   'Revised Reports' для Scheme. Последний, 'Revised6 Report' [fn:24], акцентирует внимание на переносимости, вводя ряд
   стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.

   Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
   реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
   языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
   проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
   информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.

   Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
   и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.

   Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
   пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
   от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
   списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
   освобождения памяти.

   Независимо от представления, /все/ данные являются объектами первого класса. Все они хранятся независимо и могут
   свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
   образования новых объектов.

   Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
   выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
   остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.

   Scheme относится к языкам с /вызовом-по-значению/ , но для, по меньшей мере,  мутабельных объектов (объекты, которые
   могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
   сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
   что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
   процедуры.

   В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
   ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
   составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
   надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
   реализацию и увеличивая надёжность.

   Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
   любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
   переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
   формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
   предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
   процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
   Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.

   В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
   Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
   кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
   т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
   пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
   блоке могут /затенять/ связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
   котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
   лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
   поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
   компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
   с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
   определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
   пока программа не выполнится.

   В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
   локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена в
   пределах другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет
   конца блока. В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может
   быть произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже
   когда внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо
   самого кода, хранит в себе лексический контекст (окружение).

   Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
   такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
   другим объектом.

   Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
   процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
   становятся элегантнее или эффективнее. Особый вид рекурсии, называемый /хвостовая рекурсия/, используется для
   выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
   другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
   самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
   (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
   Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
   обычным набором итерационных конструкций.

   Scheme поддерживает определение произвольных управляющих структур с помощью /продолжений/ . /Продолжение/ , это
   процедура, которая заключает в себе остальную часть программы в заданной точке. /Продолжение/ может быть получено в
   любой момент во время выполнения программы. Так же, как и с другими процедурами, /продолжение/ является объектом
   первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
   продолжает выполнение с той точки, где это /продолжение/ было создано. /Продолжения/ позволяют реализовать сложные
   механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.

   Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
   написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
   существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
   высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
   реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
   процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
   выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
   языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
   выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
   синтаксических выражений и объявлений процедур.

   Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
   объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
   многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
   60 [fn:21]. Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
   структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
   лексической областью действия.

   Common Lisp [fn:27] и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
   другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
   процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
   с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
   объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
   объектов первого класса. И хотя Common Lisp не поддерживает /продолжения/ или требует правильного обращения с
   хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
   похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
   универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).

   Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
   используемых в этой книге.

*** Синтаксис

    Программы на Scheme состоят из ключевых слов, переменных, структурирующих форм, константных данных (числа, буквы,
    строки, цитируемые векторы, цитируемые списки, цитируемые символы и т.д.), пробелов и комментариев.

    Ключевые слова, переменные и символы собирательно именуются идентификаторами. Идентификаторы могут быть образованы из
    букв, чисел и некоторых специальных символов, включающих ~?~, ~!~, ~.~, ~+~, ~-~, ~*~, ~/~, ~<~, ~=~, ~>~, ~:~, ~$~,
    ~%~, ~^~, ~&~, ~_~, ~~~, и ~@~, так же ряда дополнительных символов из Unicode. Идентификаторы не могут начинаться со
    знака @, а так же со знаков, с которых может начинаться число, таких как ~+~, ~-~, ~.~, исключение ~-~ знаки ~+~, ~-~
    и некоторые другие, которые могут быть идентификаторами сами по себе, а так же идентификаторы, начинающиеся с
    ~->~. Например, ~hi~, ~Hello~, ~n~, ~x~, ~x3~, ~x+2~, и ~?$&*!!!~ - корректные идентификаторы. Идентификаторы
    отделяются пробелами, комментарием, скобками, фигурными скобками, двойными кавычками и знаком решётки. Разделитель,
    или любая другая буква Unicode, могут быть включены в любое место в имени идентификатора путём экранирования в виде
    ~\xsv~, где sv - скалярное значение символа в шестнадцатеричном представлении.

    На длину идентификаторов не накладывается никаких ограничений, программист использовать столько символов в имени,
    сколько посчитает нужным. Однако, длинные идентификаторы не заменят комментариев, в то же время, их частое
    использование может сделать код трудным для форматирования и чтения. Хорошее правило, это использовать короткие имена
    идентификаторов в тех случаях, когда область видимости идентификатора мала, и длинные тогда, когда область видимости
    велика.

    Идентификаторы могут содержать любую комбинацию символов верхнего или нижнего регистров, регистр учитывается т.е. два
    идентификатора считаются различными, даже если они отличаются только регистром. Например, ~abcde~, ~Abcde~, ~AbCdE~ и
    ~ABCDE~ - все различные идентификаторы. Это нововведение, по сравнению с предыдущими отчётами по стандарту языка.

    Структурированные формы и списки констант заключаются в скобки, например ~(a b c)~ или ~(* (- x 2) y)~. Пустой список
    записывается как ~()~. Другие парные наборы скобок, такие как ~[~ ~]~, могут быть использованы вместо круглых скобок
    и часто используются для выделения подвыражений определенных стандартных синтаксических форм для удобочитаемости, как
    в примерах в этой книге. Векторы записываются таким же образом, как и списки, за исключением того, что они начинаются
    с ~#(~ и заканчиваются ~)~, например ~#(это вектор содержащий символы)~. Байт-векторы записываются как
    последовательность беззнаковых байтов (обычные целочисленные значения в диапазоне от 0 до 255), заключенных в ~#vu8(~
    и ~)~, например ~#vu8(3 250 45 73)~.

    Строки заключаются в двойные кавычки, например "Это строка" . Буквы предваряются ~#\~, например ~#\a~. Когда речь
    идёт о строках или буквах - регистр имеет значение, так же как и в случае с идентификаторами. Числа могут быть
    записаны в виде целочисленного значения (integer), например ~-123~, рационального числа, например ~1/2~, числа с
    плавающей точкой или в научной форме, например ~1.3~ или ~1e23~, как комплексное число, в прямоугольной или полярной
    системах координат например ~1.3-2.7i~ или ~-1.2@73~. В случае чисел регистр не имеет значения. Булевы значения,
    представляющие ложь и истину, обозначаются ~#f~ и ~#t~ соответственно. В Scheme, условные выражения обычно считают
    ~#f~ ложью, а любой другой объект истиной, так что ~3~, ~0~, ~()~, "false" или ~nil~ - всё это считается истиной.

    Детальное описание синтаксиса каждого константного типа данных дано в отдельной секции в главе 6 и в формальном
    описании синтаксиса, приведённом в конце книги.

    Выражения в Scheme могут занимать несколько строк, для этого не требуются специальные терминирующие
    символы. Учитывая, что количество пробельных символов и переводов строки между выражениями не имеет синтаксического
    значения, эту возможность следует использовать, чтобы программы на Scheme были выровнены таким образом, чтобы
    правильно отображать структуру кода и делать его настолько читаемым, насколько это возможно. Комментарии могут быть
    размещены в каждой строке программы, между символом ~;~ и концом строки. Комментарий, поясняющий конкретное выражение
    Scheme, обычно размещается в предыдущей строке, с тем же уровнем отступа. Комментарии, поясняющие процедуру или
    группу процедур, обычно размещаются перед процедурой, без отступа.

    Так же поддерживаются следующие два вида комментариев: блочные и комментарии по данным (datum). Блочные комментарии
    обосабливаются парой ~#|~ и ~|~, и могут быть вложенными. Комментарии данных начинаются с префикса ~#;~ , за которым
    следует печатная версия объекта данных. Комментарии по данным обычно используются, чтобы закомментировать конкретное
    объявление или выражение. Например, ~(список из трёх #;(а не четырёх) элементов)~. Комментарии по данным могут так же
    быть вложенными, например ~#;#;(a)(b)~, но это не имеет какого то особого значения, в сравнении, если бы
    комментировался каждый элемент по отдельности.

    Некоторые значения в Scheme, такие как процедуры или порты, не имеют стандартизированного печатного представления и
    по этому не могут быть представлены константой при печати. В этой книге используется обозначение ~#<пояснение>~,
    когда мы хотим оказать возвращаемый результат какой либо операции, возвращающей одно из таких значений, например
    ~#<procedure>~ или ~#<port>~.

*** Соглашения в именовании

    Соглашения по именованию, принятые в Scheme, разработаны так, чтобы обеспечивать высокий уровень системности и
    регулярности. Ниже приведён список таких соглашений:

    + Имена предикатов заканчиваются символом вопроса (?). Предикаты, это процедуры, возвращающие истину или ложь, такие
      как ~eq?~, ~zero?~ и ~string=?~. Обычные для чисел операции сравнения, такие как ~=~, ~<~, ~>~, ~<=~, и ~>=~
      являются исключением из правил.
    + Предикаты типов, например ~pair?~, составляются из имени типа, в данном случае /pair/ и знака вопроса.
    + Имена большинства процедур предикатов для букв, строк и векторов начинаются с префикса ~char-~, ~string-~,
      ~vector-~, например ~string-append~. (Имена некоторых процедур для списков начинаются с ~list-~, но большинство
      нет)
    + Имена процедур, которые преобразуют объект одного типа в объект другого типа, записываются как ~type1->type2~,
      например ~vector->list~.
    + Имена процедур и синтаксических форм, производящих побочные эффекты, оканчиваются знаком восклицательного знака
      (~!~). Например ~set!~ и ~vector-set!~. Процедуры, производящие операции ввода-вывода, формально так же считаются
      процедурами с побочными эффектами, однако они попадают под исключение из правил.
    + Программистам следует следовать этим соглашениям по именованию там, где это возможно.

*** Типографические и нотационные соглашения

    Про стандартные процедуры или синтаксические формы, единственная цель которых выполнение побочных эффектов, сказано,
    что возвращаемый ими результат не определён. Это значит, что конкретная реализация свободна возвращать любое
    количество значений, каждое из которых может быть любым объектом Scheme. Не рассчитывайте на то, что эти возвращаемые
    значения одинаковы для всех реализаций, одинаковые для версий одной и той же реализации, или даже одинаковы между
    двумя вызовами одной и той же процедуры или синтаксической формы. Некоторые реализации Scheme используют специальные
    объекты для обозначения неопределённого значения. Печать этого объекта часто подавляется интерактивными системами
    Scheme, поэтому значения выражений, возвращающих неопределённые значения, не печатаются.

    В то время, как большинство стандартных процедур возвращает одно значение, язык поддерживает процедуры, которые
    возвращают ноль, одно, более одного, или переменное количество значений, используя механизм, описанный в главе
    5.8. Некоторые стандартные выражения могут вычисляться в множество значений, если одно из подвыражений вычисляется в
    множество значений т.е. когда вызывается процедура, возвращающая несколько значений. Когда такое случается, выражению
    предписано возвращать /значения/, а не /значение/ его подвыражения. То же касается стандартных процедур, принимающих
    аргументом функцию - им предписывается возвращать множественное значение в том случае, если процедура-аргумент,
    влияющая на результат, возвращает множественное значение.

    В этой книге используются слова 'должен' и 'следует', чтобы описать программные требования, такие как требование,
    чтобы передаваемый индекс был меньше, чем длина вектора, при вызове ~vector-ref~. Если использовано слово 'должен', это
    значит, что реализация будет отслеживать выполнение этих требований т.е. будет выброшено исключение, обычно с типом
    условия ~&assertion~. Если используется слово 'следует', исключение может быть выброшено, а может не быть, если нет -
    поведение программы не определено. Фраза 'нарушение синтаксиса' используется, чтобы описать ситуацию, когда программа
    сформирована неправильно. Нарушения синтаксиса обнаруживаются в основном при выполнении программы. Когда нарушение
    синтаксиса обнаружено, выбрасывается исключение типа ~&syntax~ и программа прекращает работу.

    Типографические соглашения, используемые в этой книге весьма просты. Все объекты напечатаны таким же образом, как они
    выглядели бы, если бы их набрали на клавиатуре. Это касается ключевых слов синтаксиса, переменных, константных
    объектов, выражений Scheme, и примеров программ. Выделение /курсивом/ используется для обозначения синтаксических
    переменных в пояснениях синтаксических форм, аргументов и процедур. Так же курсивом выделены технических термины,
    используемые впервые. Обычно, имена и синтаксические формы находятся в нижнем регистре, даже если они начинают новое
    предложение.  То же касается и синтаксических переменных, выделенных курсивом.

    В описании синтаксических форм и процедур, один или несколько прототипов шаблонов показывают синтаксическую форму или
    формы или корректное количество аргументов для применения процедуры. Ключевое слово или имя процедуры выделяются
    машинописным шрифтом, так же как и круглые скобки. Остальные части синтаксиса или аргументы выделяются курсивом,
    используя имя, обозначающее тип выражения или аргумента, ожидаемого синтаксической формой или процедурой. Окружности
    используются для обозначения нуля или более вхождений подвыражения или аргумента. Например, ~(or expr ...)~
    описывает синтаксическую форму ~or~, которая имеет ноль или более подвыражений, и ~(member obj list)~ описывает
    процедуру ~member~, которая ожидает два аргумента - объект и список.

    Нарушением синтаксиса считается случай, когда структура синтаксической формы не совпадает с её прототипом. Обычно,
    выбрасывается исключение типа ~&assertion~, если количество аргументов, переданных в стандартную процедуру не
    совпадает с тем, которое ожидается к получению. Исключение с типом условия ~&assertion~ также выбрасывается, если
    стандартная процедура получает аргумент, который не подразумевается в его названии, или не удовлетворяет другим
    критериям, указанным в описании процедуры. Например, прототип для ~vector-set!~ таков:

#+begin_src scheme
    (vector-set! vector n obj)
#+end_src

    и описание говорится, что ~n~ должен быть неотрицательным целым числом, строго меньшим, чем длина вектора. Таким
    образом, ~vector-set!~ должен получить три аргумента, первый из которых должен быть вектором, второй должен быть
    неотрицательным целым числом, меньше длины вектора, и третьим может быть любой объект Scheme. В противном случае,
    будет выброшено исключение с типом условий ~&assertion~.

    В большинстве случаев тип ожидаемого аргумента очевиден, как в случае в ~vector~, ~obj~ или ~binary-input-port~. В
    остальных же случаях, по большей части использующихся в описании числовых операций, используются сокращения, такие
    как /int/ для целочисленных, /exint/ (от exact integer) для строгого указания целочисленного типа и /fx/ для типа
    /fixnum/. Эти сокращения поясняются в начале разделов, где мы их впервые коснёмся.

#+LATEX: \newpage
[[./images/ch2.png]]

** Начало

   Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
   параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

   После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
   Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
   данных и управляющие конструкции.

*** Взаимодействие с интерактивной оболочкой Scheme

    Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
    разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
    "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
    или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
    выполнения на экран.

    Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
    выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
    работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
    и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
    в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
    реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
    качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
    программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
    для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
    образом, как если бы они были набраны на клавиатуре интерактивно.

    Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
    значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
    позволяет сконцентрироваться на написании программы.

    Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
    можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После → следует значение
    выражения, что следует читать как "имеет следующее значение". Знак → применим для определений и в тех случаях, когда
    значение выражения неопределено.

    Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
    потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
    строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
    выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
    она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

    Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
    будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
    набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
    значение вычисления любой константы - сама константа.

#+begin_src scheme
    "Hi Mom!" → "Hi Mom!"
#+end_src

    Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
    однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+begin_src scheme
    "hello" → "hello"
    42 → 42
    22/7 → 22/7
    3.141592653 → 3.141592653
    + → #<procedure>
    (+ 76 31) → 107
    (* -12 10) → -120
    '(a b c d) → (a b c d)
#+end_src

    Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
    одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
    попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
    ожидать её даже после окончания ввода.

    Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
    дождаться пояснений, найдя их далее в главе.

#+begin_src scheme
    (car '(a b c)) → a
    (cdr '(a b c)) → (b c)
    (cons 'a '(b c)) → (a b c)
    (cons (car '(a b c))
          (cdr '(d e f))) → (a e f)
#+end_src

    Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
    выражение по парным двойным кавычкам и скобкам.

    Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
    (define square
      (lambda (n)
        (* n n)))
#+end_src

    Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
    процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
    связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
    выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
    предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
    операций, вроде ~*~.

    Опробуем наш ~square~ в деле:

#+begin_src scheme
    (square 5) → 25
    (square -200) → 40000
    (square 0.5) → 0.25
    (square -1/2) → 1/4
#+end_src

    Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
    "reciprocal.ss."

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
    вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
    (load "reciprocal.ss")
#+end_src

    Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+begin_src scheme
    (reciprocal 10) → 1/10
    (reciprocal 1/10) → 10
    (reciprocal 0) → "oops!"
    (reciprocal (reciprocal 1/10)) → 1/10
#+end_src

*** Простейшие выражения

    Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
    списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
    примеров со строками и числами.

    Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
    ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+begin_src scheme
    123456789987654321 → 123456789987654321
    3/4 → 3/4
    2.718281828 → 2.718281828
    2.2+1.1i → 2.2+1.1i
#+end_src

    Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
    целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
    используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

    Scheme предоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
    поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
    обозначают применение процедуры к набору аргументов.

#+begin_src scheme
    (+ 1/2 1/2) → 1
    (- 1.5 1/2) → 1.0

    (* 3 1/2) → 3/2
    (/ 1.5 3/4) → 2.0
#+end_src

    Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
    процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
    постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
    относительно приоритета или ассоциативности операторов.

    Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
    образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
    формул.

#+begin_src scheme
    (+ (+ 2 2) (+ 2 2)) → 8
    (- 2 (* 4 1/3)) → 2/3
    (* 2 (* 2 (* 2 (* 2 2)))) → 32
    (/ (* 6/7 7/2) (- 4.5 1.5)) → 1.0
#+end_src

    Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
    мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
    лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

    Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
    содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
    является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
    обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
    не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
    строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
    элементов, каждый из которых это список из двух элементов.

    Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
    Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
    ~(procedure arg ...)~?

    В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
    применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
    Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
    потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
    список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
    применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+begin_src scheme
    (quote (1 2 3 4 5)) → (1 2 3 4 5)
    (quote ("да" "это" "всё" "ещё" "список")) → ("да" "это" "всё" "ещё" "список")
    (quote (+ 3 4)) → (+ 3 4)
#+end_src

    С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
    ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
    третьего.

    Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
    обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
    аббривеатурой для ~quote~.

#+begin_src scheme
    '(1 2 3 4) → (1 2 3 4)
    '((1 2) (3 4)) → ((1 2) (3 4))
    '(/ (* 2 -1) 3) → (/ (* 2 -1) 3)
#+end_src

    Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
    будет заключён в выражение ~quote~.

    Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
    принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
    процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
    принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

    Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+begin_src scheme
    (quote hello) → hello
#+end_src

    Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hello~ как
    переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
    выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
    об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
    думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
    списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
    идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
    используются для представления переменных в описании символьных уравнений или программ, символы могут также
    использоваться, например, как слова в описании предложений естественного языка.

    Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
    символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
    написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
    в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
    самых значительных особенностей Scheme.

    Числа и строки также могут цитироваться:

#+begin_src scheme
    '2 → 2
    '2/3 → 2/3
    (quote "Hi Mom!") → "Hi Mom!"
#+end_src

    Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

    Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
    значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
    оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
    на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+begin_src scheme
    (car '(a b c)) → a
    (cdr '(a b c)) → (b c)
    (cdr '(a)) → ()

    (car (cdr '(a b c))) → b
    (cdr (cdr '(a b c))) → (c)

    (car '((a b) (c d))) → (a b)
    (cdr '((a b) (c d))) → ((c d))
#+end_src

    Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
    /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

    Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
    ~cons~ вернёт список.

#+begin_src scheme
    (cons 'a '()) → (a)
    (cons 'a '(b c)) → (a b c)
    (cons 'a (cons 'b (cons 'c '()))) → (a b c)
    (cons '(a b) '(c d)) → ((a b) c d)

    (car (cons 'a '(b c))) → a
    (cdr (cons 'a '(b c))) → (b c)
    (cons (car '(a b c))
          (cdr '(d e f))) → (a e f)
    (cons (car '(a b c))
          (cdr '(a b c))) → (a b c)
#+end_src

    "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
    путём добавления элемента в начало списка называется /consing/ (устоявшегося перевода на русский язык нет, но
    примерный - /кортежирование/, или возможно /спаривание/, ведь здесь речь идёт о кортежах именно длины 2, у которых
    есть устоявшееся название - пары).

    Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
    пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
    следующая пара в последовательности.

#+ATTR_LATEX: :width 200px
[[./images/1.png]]

    /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
    /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
    /правильным/ становится любой список, /cdr/ которого /правильный/ список.

    Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
    списка.

#+begin_src scheme
    (cons 'a 'b) → (a . b)
    (cdr '(a . b)) → b
    (cons 'a '(b . c)) → (a b . c)
#+end_src

    Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
    чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
    /правильные/ списки без точек.

#+begin_src scheme
    '(a . (b . (c . ()))) → (a b c)
#+end_src

    Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
    строит /правильные/ списки.

#+begin_src scheme
    (list 'a 'b 'c) → (a b c)
    (list 'a) → (a)
    (list) → ()
#+end_src

    Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
    чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

**** Упражнение 2.2.1

     Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
     1. ~1.2 × (2 - 1/3) + -8.7~
     2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
     3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
     4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~

**** Упражнение 2.2.2

     Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
     возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.

**** Упражнение 2.2.3

     Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
     ответы:
     1. ~(cons 'car 'cdr)~
     2. ~(list 'this '(is silly))~
     3. ~(cons 'is '(this silly?))~
     4. ~(quote (+ 2 3))~
     5. ~(cons '+ '(2 3))~
     6. ~(car '(+ 2 3))~
     7. ~(cdr '(+ 2 3))~
     8. ~cons~
     9. ~(quote cons)~
     10. ~(quote (quote cons))~
     11. ~(car (quote (quote cons)))~
     12. ~(+ 2 3)~
     13. ~(+ '2 '3)~
     14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
     15. ~((car (list + - * /)) 2 3)~

**** Упражнение 2.2.4

     ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
     которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.

**** Упражнение 2.2.5

     Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:

#+ATTR_LATEX: :width 200px
[[./images/2.png]]

**** Упражнение 2.2.6

     Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
     ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~

**** Упражнение 2.2.7

     Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
     b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
     выражения ~((a b) (c d))~.

**** Упражнение 2.2.8

     Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
     объяснение?

*** Выполнение Scheme выражений

    Давайте вернёмся к обсуждению, как всётаки Scheme выполняет набранные Вами выражения. Мы уже установили правила для
    константных  объектов, таких как строки и числа: эти объекты являются значениями сами по себе. Вы возможно уже
    выработали у себя в голове некоторые правила для вычисления применения процедур вида ~(procedure arg1
    ... argN)~. Здесь, ~procedure~ это выражение, представляющее Scheme процедуру, а ~arg1 ... argN~ выражения,
    представляющие её аргументы. Один из возможных вариантов её применения следующий:

    + Определить значение ~procedure~.
    + Определить значение ~arg1~.
    + ...
    + Определить значение ~argN~.
    + Применить значение ~procedure~ к значениям ~arg1 ... argN~.

    Для примера, рассмотрим применение простой процедуры ~(+ 3 4)~. Значение ~+~ это процедура сложения, значение ~3~
    это число ~3~, значение ~4~ это число ~4~. Применение процедуры сложения к ~3~ и ~4~ даёт ~7~, так что мы получаем
    значение ~7~.

    Применяя данный алгоритм на каждом уровне, мы можем найти значения вложенного выражения ~(* (+ 3 4) 2)~. Значение
    ~*~ это процедура умножения, значение ~(+ 3 4)~, как мы выяснили выше, это ~7~, а значение ~2~ это ~2~. Перемножив
    ~7~ и ~2~ мы получаем ~14~, так что наш ответ ~14~.

    Это правило работает для применения процедуры, но не работает для /цитированного/ выражения, потому что подвыражения
    примененияя процедуры вычисляются, в то время как подвыражения /цитированного/ выражения нет. Вычисление
    /цитированного/ выражения более похоже на вычисление константного объекта. Значение /цитированного/ выражения ~(quote
    object)~ это просто ~object~.

    Константные объекты, применения процедур и /цитированные/ выражения это только три из множества синтаксических форм,
    предоставляемых Scheme. К счастью, лишь немногие из оставшихся синтаксических форм неприменно должны быть понимаемы
    Scheme программистом. Они называются /основными синтаксическими формами/. Остальные синтаксические формы это
    синтаксические выражения, преимущественное, выраженные в терминах основных синтаксических форм. Мы обсудим
    оставшиеся синтаксические формы и некоторые синтаксические выражение ниже в этой главе. Секция 3.1 подытоживает
    обзор основных синтаксических форм и даёт введение в механизм расширения синтаксиса.

    Прежде чем мы перейдём к новым синтаксическим формам и процедурам, будет не лишним сказать пару слов о вычислении
    применения процедур. Во-первых, описанный выше процесс слишком строг, поскольку он требует вычисления подвыражений
    слева направо, это значит, что значение ~procedure~ будет вычислено до вычисления ~arg1~, ~arg1~ до ~arg2~ и
    т.д. Это вовсе не обязательно. /Вычислитель/ Scheme свободен вычислять выражения в любом порядке - слева направо,
    справо налево, или в любой другой последовательности. На деле, подвыражения могут вычисляться в различном порядке в
    различных случаях, даже в рамках одной и той же реализации.

    Во-вторых ~procedure~ вычисляется таким же образом, как и ~arg1 ... argN~. Хотя процедура часто является переменной,
    которая указывает на конкретную процедуру, это не обязательно. Упражнение 2.2.3 предложит Вам определить значение
    выражения ~((car (list + - * /)) 2 3)~. Здесь процедура это ~(car (list + - * /))~. Значение ~(car (list + - * /))~
    это процедура сложения, как если бы была просто записана переменная +.

**** Exercise 2.3.1

     Опишите шаги, необходимые для вычисления выражения ниже:

#+begin_src scheme
     ((car (cdr (list + - * /))) 17 5)
#+end_src

*** Переменые и ~let~ выражения

    Пусть ~expr~ это Scheme выражение, содержащее переменную ~var~. Допустим также, что нам хотелось бы, чтобы
    переменная ~var~ содержала бы значение ~val~, когда мы вычисляем значение ~expr~. Например, мы хотим, чтобы ~x~ имел
    значение ~2~, когда вычисляется выражение ~(+ x 3)~. Или, мы хотим, чтобы ~y~ имел значение ~3~, при вычислении
    выражения ~(+ 2 y)~. Примеры ниже показывают, как добиться такого поведения при помощи синтаксической формы ~let~:

#+begin_src scheme
    (let ((x 2))
      (+ x 3)) → 5

    (let ((y 3))
      (+ 2 y)) → 5

    (let ((x 2) (y 3))
      (+ x y)) → 5
#+end_src

    Синтаксическая форма ~let~ включает в себя список пар /переменная->выражение/, а так же список выражений,
    использующих эти переменные, называемый телом (/body/) ~let~. В общем виде выражение ~let~ имеет следующую форму:

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    Таким образом, с помощью ~let~, мы говорим, что переменные связываются со своими значениями, и далее мы можем
    ссылаться на них в теле выражения.

    ~let~ выражения применяются очень часто и служат средством упрощения выражений, которые содержат несколько
    идентичных подвыражений. Вынесение этого подвыражения в секцию связывания переменных гарантирует, что выражение
    будет вычислено лишь единожды.

#+begin_src scheme
    (+ (* 4 4) (* 4 4)) → 32

    (let ((a (* 4 4))) (+ a a)) → 32
#+end_src

    В секции связывания переменных часто вместо круглых скобок применяют квадратные, чтобы визуально отделить эту
    область от остального тела:

#+begin_src scheme
    (let ([list1 '(a b c)] [list2 '(d e f)])
      (cons (cons (car list1)
                  (car list2))
            (cons (car (cdr list1))
                  (car (cdr list2))))) → ((a . d) b . e)
#+end_src

    Scheme интерпретирует формы, заключённые в квадратные скобки так, как будто они заключены в круглые скобки, но
    нельзя их смешивать - открывающей круглой скобке должна соответствовать закрывающая круглая скобка, а открывающей
    квадратной - квадратная. Мы используем квадратные скобки для ~let~ (и как вы скоро увидите, так же ещё для некоторых
    стандартных синтаксических форм), чтобы улучшить читаемость кода, особенно когда мы могли бы иметь две или более
    последовательные открывающие круглые скобки.

    Поскольку, при применении процедуры, вычисление выражения, стоящего в первой позиции, происходит таким же образом,
    как и любого другого выражения, здесь так же может быть использована /let-связанная/ переменная:

#+begin_src scheme
    (let ([f +])
      (f 2 3)) → 5

    (let ([f +] [x 2])
      (f x 3)) → 5

    (let ([f +] [x 2] [y 3])
      (f x y)) → 5
#+end_src

    Переменные, связанные с помощью ~let~ видны только в пределах /тела/:

#+begin_src scheme
    (let ([+ *])
      (+ 2 3)) → 6

    (+ 2 3) → 5
#+end_src

    И это очень хорошо, что оно работает именно так, потому что мы не хотели бы, чтобы значение + было методом умножения
    всюду.

    Так же выражения ~let~ могут быть вложенными:

#+begin_src scheme
    (let ([a 4] [b -3])
      (let ([a-squared (* a a)]
            [b-squared (* b b)])
        (+ a-squared b-squared))) → 25
#+end_src

    Когда во вложенном ~let~ выражении производят связывание той же переменной, что и во внешнем, только связывание,
    выполненное последним, на более глубоком уровне, считается действующим в пределах тела внутреннего ~let~-выражения:

#+begin_src scheme
    (let ([x 1])
      (let ([x (+ x 1)])
        (+ x x))) → 4
#+end_src

    Здесь внешнее ~let~ выражение связывает ~x~ и 1 в пределах своего тела, место которого занимает второе ~let~
    выражение. Внутреннее ~let~ выражение связывает ~x~ со значением ~(+ x 1)~ в рамках своего тела, которое
    представлено выражением ~(+ x x)~. Каково значение выражения ~(+ x 1)~? Поскольку ~(+ x 1)~ появляется в теле
    внешнего ~let~, но не в теле внутреннего ~let~, значение ~x~ должно быть 1, и, следовательно, значение ~(+ x 1)~
    равно 2. А что насчёт ~(+ x x)~? Оно появляется в теле обоих выражений ~let~. Видно только внутреннее связывание для
    ~x~, поэтому ~x~ равно 2, а ~(+ x x)~ равно 4.

    Про внутреннее связывание для ~x~ говорят, что оно /затеняет/ внешнее связывание. let-связанная переменная видна
    везде внутри тела ее выражения ~let~, кроме случаев, когда она затенена. Область, в которой действует связывание
    переменной, называется /областью видимости/ (scope). Область видимости первого ~x~ в приведенном выше примере - это
    тело внешнего выражения ~let~ минус тело внутреннего выражения ~let~, где он затеняется вторым ~x~. Эта форма
    определения области видимости называется /лексической областью видимости/, поскольку область видимости каждого
    связывания может быть определена путем простого текстового анализа программы.

    Затенения можно избежать, дав различные имена переменным. Выражение выше может быть переписано так, что во
    внутреннем ~let~ выражении будет производиться связывание значения с именем ~new-x~:

#+begin_src scheme
    (let ([x 1])
      (let ([new-x (+ x 1)])
        (+ new-x new-x))) → 4
#+end_src

    Хотя выбор разных имен иногда может предотвратить путаницу, затенение может помочь предотвратить случайное
    использование "старого" значения. Например, в исходной версии предыдущего примера мы не могли бы ошибочно сослаться
    на внешний ~x~ в теле внутреннего ~let~.

**** Упражнение 2.4.1

     Перепишите выражения ниже, используя ~let~, чтобы вынести общие подвыражения и улучшить структуру кода. Не
     используйте математических упрощений.

     + ~(+ (- (* 3 a) b) (+ (* 3 a) b))~
     + ~(cons (car (list a b c)) (cdr (list a b c)))~

**** Упражнение 2.4.2

     Определите значение вычисления следующего выражение. Поясните, как вы получили это значение.

#+begin_src scheme
     (let ([x 9])
       (* x
          (let ([x (/ x 3)])
            (+ x x))))
#+end_src

**** Упражнение 2.4.3

     Перепишите следующие выражения, чтобы дать уникальные имена каждой отдельной let-связанной переменной, чтобы ни
     одна из переменных не была затенена. Убедитесь, что значение вашего выражения совпадает со значением исходного
     выражения.

     +
#+begin_src scheme
     (let ([x 'a] [y 'b])
       (list (let ([x 'c]) (cons x y))
             (let ([y 'd]) (cons x y))))
#+end_src

     +
#+begin_src scheme
     (let ([x '((a b) c)])
       (cons (let ([x (cdr x)])
               (car x))
             (let ([x (car x)])
               (cons (let ([x (cdr x)])
                       (car x))
                     (cons (let ([x (car x)])
                             x)
                           (cdr x))))))
#+end_src

*** Лямбда выражения

    В выражении ~(let ([x (* 3 4)]) (+ x x))~ переменная ~x~ связана со значением ~(* 3 4)~. Что будет, если мы захотим
    получить значение выражения ~(+ x x)~ где  ~x~ связана со значением ~(/ 99 11)~? А где ~x~ связана со значением
    ~(- 2 7)~? В каждом случае нам потребуется новое ~let~-выражение. И чем сложнее становится тело ~let~, тем менее
    удобно становится повторять его.

    Вместо этого мы можем использовать синтаксическую форму ~lambda~ для создания новой процедуры, которая имеет ~x~ в
    качестве входного параметра и имеет такое же тело, как у ~let~-выражения.

#+begin_src scheme
    (lambda (x) (+ x x)) → #<procedure>
#+end_src

    Общая форма лямбда-выражения:

#+begin_src scheme
    (lambda (var ...) body1 body2 ...)
#+end_src

    Переменные ~var ...~ это формальные параметры процедуры, а последовательность выражений ~body1 body2 ...~ это её
    тело. (В действительности, по-настоящему общая форма это нечто более обобщённое, чем это, как вы увидите позже).

    Процедура - это такой же объект, как число, строка, символ или пара. У неё нет какого-либо вменяемого печатного
    представления, по крайней мере в Scheme, тем не менее, в этой книге мы будем использовать обозначение ~#<procedure>~
    чтобы показать, что значение выражения это процедура.

    Простейшая операция, которую можно совершить над процедурой - это применить её к одному или более значений:

#+begin_src scheme
    ((lambda (x) (+ x x)) (* 3 4)) → 24
#+end_src

    Здесь нет никакого отличия от какого-то другого способа применения процедуры. Процедура это результат вычисления
    выражения ~(lambda (x) (+ x x))~ и единственный агрумент это значение выражения ~(* 3 4)~, или 12. Значения
    аргументов, или параметры, связываются с формальными параметрами в пределах тела лямбда-выражения таким же образом,
    как и let-связывание связывает переменные с их значениями. В этом случае, ~x~ связывается с 12, а значение ~(+ x x)~
    равно 24. Таким образом, результат применения процедуры к значению 12 равен 24.

    Посколько процедуры это объекты, мы можем установить процедуру как значение переменной и использовать эту процедуру
    в дальнейшем не раз.

#+begin_src scheme
    (let ([double (lambda (x) (+ x x))])
      (list (double (* 3 4))
            (double (/ 99 11))
            (double (- 2 7)))) → (24 18 -10)
#+end_src

    Здесь мы установили связывание между ~double~ и процедурой, а затем использовали эту процедуру, чтобы удвоить три
    различных значения.

    Наша процедура ожидает, что её фактическим параметром будет число, поскольку он передаётся фактическим параметром в
    ~+~. В общем же случае, фактическим параметром может быть объект любого сорта. Рассмотрим, для примера, простейшую
    процедуру, которая использует ~cons~ вместо ~+~:

#+begin_src scheme
    (let ([double-cons (lambda (x) (cons x x))])
      (double-cons 'a)) → (a . a)
#+end_src

    Отмечая сходство между ~double~ и ~double-cons~, вы не должны удивляться, узнав, что они могут быть объединены в
    одну процедуру путем добавления дополнительного аргумента.

#+begin_src scheme
    (let ([double-any (lambda (f x) (f x x))])
      (list (double-any + 13)
            (double-any cons 'a))) → (26 (a . a))
#+end_src

    Здесь демонстрируется, что процедуры могут принимать более одного аргумента и эти аргументы, передаваемые в
    процедуру, сами могу быть процедурами.

    Как и с ~let~-выражениями, лямбда-выражения становятся несколько интереснее, когда они вложены в другие
    лямбда- или let-выражения.

#+begin_src scheme
    (let ([x 'a])
      (let ([f (lambda (y) (list x y))])
        (f 'b))) → (a b)
#+end_src

    Вхождение ~x~ в лямбда-выражение ссылается на ~x~ за пределами лямбды, который был связан внешним
    let-выражением. Говорят, что переменная ~x~ в лямбда-выражении свободна или является свободной переменной
    лямбда-выражения. Переменная ~y~ не является свободной переменной в лямбда-выражении, поскольку она была связана в
    лямбда-выражении. Переменная, которая становится свободной в лямбда-выражении должна уже быть связана, например,
    окружающим лямбда- или let-выражением, кроме случая, когда переменная связывается вне выражения, который мы обсудим
    в следующем разделе.

    Что происходит, когда процедура применяется где-то вне области привязок для переменных, которые встречаются в
    процедуре свободно, как в следующем выражении?

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (f 'i 'am)) → (sam i am)
#+end_src

    Ответ заключается в том, что те же привязки, которые действовали при создании процедуры, снова применяются при
    применении процедуры. Это верно, даже если другая привязка для ~x~ видна там, где применяется процедура.

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (let ([x 'not-sam])
        (f 'i 'am))) → (sam i am)
#+end_src

    В обоих случаях, значение ~x~ за пределами процедуры названой ~f~ это ~sam~.

    Примечательно, что let-выражение это ни что иное, как прямое применение лямбда-выражения с целью задать аргументы
    выражения. Например, два выражения ниже эквивалентны:

#+begin_src scheme
    (let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)
#+end_src

    В действительности, let-выражение это синтаксическое выражение, определённое в терминах лямбда-выражения и
    применения процедуры, которые оба являются базовыми синтаксическими формами. В общем случае, любое выражение вида

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    эквивалентно следующему

#+begin_src scheme
    ((lambda (var ...) body1 body2 ...)
     expr ...)
#+end_src

    В секции 3.1 будут более подробно обсуждаться базовые формы и расширения синтаксиса.

    Как упоминалось выше, общая форма лямбда-выражения несколько сложнее, чем форма, рассмотренная нами ранее, в том,
    что формальное объявление параметра, ~(var ...)~, не обязано быть правильным списом, или даже списком
    вообще. Формальное объявление параметра может быть любой из трёх форм ниже:

    + правильный список переменных ~(var1 ... varN)~, как мы видели только что
    + одна переменная ~varR~
    + неправильный список переменных, ~(var1 ... varN . varR)~.

    В первом случае должно быть передано ровно ~N~ параметров, и каждая переменная связана с соответствующим
    переданным параметром. Во втором, любое количество переданных параметров валидно, все переданные параметры
    собираются в один список и единственная переменная связывается с этим списком. Третий случай это гибрид первых
    двух. По меньшей мере ~N~ параметров должно быть передано. Переменные ~var1 ... varN~ связываются с соответствующими
    переданными параметрами, а переменная ~varR~ связывается со списком, содержащим остальные переданные параметры. Во
    втором и третьем случаях, параметр ~varR~ иногда обозначают как "rest" (англ. остальные), потому что он содержит
    оставшиеся переданные параметры, помимо тех, которые индивидуально названы.

    Давайте рассмотрим несколько примеров, чтобы прояснить более общий синтаксис лямбда-выражений:

#+begin_src scheme
    (let ([f (lambda x x)])
      (f 1 2 3 4)) → (1 2 3 4)

    (let ([f (lambda x x)])
      (f)) → ()

    (let ([g (lambda (x . y) (list x y))])
      (g 1 2 3 4)) → (1 (2 3 4))

    (let ([h (lambda (x y . z) (list x y z))])
      (h 'a 'b 'c 'd)) → (a b (c d))
#+end_src

    В первых двух примерах, процедура, названная ~f~ принимает любое количество аргументов. Эти аргументы автоматически
    групируются в список, с которым связывается переменная ~x~, значение ~f~ это этот список. В первом примере,
    аргументы 1, 2, 3, 4, так что ответ ~(1 2 3 4)~. Во втором примере нет аргументов, так что ответ это пустой список
    ~()~. Значение процедуры названой ~g~, в третьем примере, это список, чей первый элемент это первый аргумент, а
    второй элемент это список, содержащий остальные аргументы. Процедура под именем ~h~ похожа, но здесь второй аргумент
    отделён. Если процедура ~f~ принимает любое количество агрументов, ~g~ должен иметь по меньшей мере один, то ~h~
    должен получать не меньше двух аргументов.

**** Упражнение 2.5.1

     Определите значения выражений ниже.

     +
#+begin_src scheme
     (let ([f (lambda (x) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda x x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) y)])
       (f 'a))
#+end_src

**** Упраженение 2.5.2

     Как может выглядеть определение примитивной процедуры ~list~?

**** Упражнение 2.5.3

     Найдите все свободные переменные в лямбда-выражениях ниже. Переменные, указывающие на примитивные процедуры, такие
     как ~+~ и ~cons~ не в счёт.

     +
#+begin_src scheme
     (lambda (f x) (f x))
#+end_src

     +
#+begin_src scheme
     (lambda (x) (+ x x))
#+end_src

     +
#+begin_src scheme
     (lambda (x y) (f x y))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (cons x (f x y)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([z (cons x y)])
         (x y z)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([y (cons x y)])
         (x y z)))
#+end_src

*** Определения верхнего уровня

    Переменные, связанные с помощью ~let~ и ~lambda~ не видны за пределами тел этих выражений. Допустим, у вас есть
    некий объект или процедура, который должен быть доступи отовсюду, например, как ~+~ или ~cons~. Вам нужно
    определение верхнего уровня, которое может быть установлено с помощью ~define~. Определения верхнего уровня,
    поддерживаемые большенством интерактивных систем Scheme, доступны в любом введённом вами выражении, за исключением
    случаев, когда оно затенено другим локальным связыванием.

    Давайте установим определение верхнего уровня для процедуры ~double-any~ из последней секции:

#+begin_src scheme
    (define double-any
      (lambda (f x)
        (f x x)))
#+end_src

    Теперь переменная ~double-any~ имеет тот же статус, что и ~cons~ или любая другая примитивная процедура. Мы можем
    использовать ~double-any~ так, как если бы это была примитивная процедура.

#+begin_src scheme
    (double-any + 10) → 20
    (double-any cons 'a) → (a . a)
#+end_src

    Определение верхнего уровня может быть установлено для любого объекта, не только процедур.

#+begin_src scheme
    (define sandwich "peanut-butter-and-jelly")

    sandwich → "peanut-butter-and-jelly"
#+end_src

    Однако чаще всего определения верхнего уровня используются для процедур.

    Как было отмечено выше, определения верхнего уровня могут быть затенены связываниями в ~let~ или ~lambda~.

#+begin_src scheme
    (define xyz '(x y z))
    (let ([xyz '(z y x)])
      xyz) → (z y x)
#+end_src

    Переменные, объявленные на верхнем уровне действуют почти так-же, как если бы они были связаны при помощи
    let-выражения, охватывающего весь ваш код.

    Учитывая только простые инструменты, о которых вы читали до этого момента, уже можно определить некоторые
    примитивные процедуры, предоставляемые Scheme и описанные далее в этой книге. Если вы прошли упражнения из прошлой
    главы, вы должны уже знать, как определить функцию ~list~.

#+begin_src scheme
    (define list (lambda x x))
#+end_src

    Также, Scheme предоставляет сокращения ~cadr~ и ~cddr~ для сочетаний ~car~ и ~cdr~ с ~cdr~. Так, ~(cadr list)~
    равнозначно ~(car (cdr list))~, а ~(cddr list)~ это ~(cdr (cdr list))~. Эти функции легко определяются, как описано
    ниже.

#+begin_src scheme
    (define cadr
      (lambda (x)
        (car (cdr x))))

    (define cddr
      (lambda (x)
        (cdr (cdr x))))

    (cadr '(a b c)) → b
    (cddr '(a b c)) → (c)
#+end_src

    Любое определение ~(define var expr)~, где ~expr~ это лямбда, может быть записано в сокращённой форме, которая
    скрывает ~lambda~. Явный синтаксис зависит от формата спецификатора формального параметра лямбда-выражения,
    т.е. будь то правильный список переменных, единственная переменная или неправильный список переменных. Определение
    формы

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN)
      e1 e2 ...)
#+end_src

    в то время как

#+begin_src scheme
    (define var0
      (lambda varR
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 . varR)
      e1 e2 ...)
#+end_src

    и

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN . varR)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN . varR)
      e1 e2 ...)
#+end_src

    Например, определения ~cadr~ и ~list~ могут быть записаны следующим образом

#+begin_src scheme
    (define (cadr x)
      (car (cdr x)))

    (define (list . x) x)

#+end_src

    В этой книге данный альтернативный синтаксис используется редко. Несмотря на короткую запись, это приводит к
    сокрытию того факта, что процедура не имеет такой тесной связи с переменными или именами, как во многих других
    языках. Этот синтаксис часто называют несколько уничижительно, как «defun» для define, после формы defun,
    введённой языками Lisp, в которой процедуры более тесно связаны с их именами.

    Определения верхнего уровня облегчают нам эксперименты с процедурой в интерактивном режиме, поскольку нам не нужно
    повторно вводить процедуру каждый раз, когда она используется.

    Давайте попробуем определить несколько более сложный вариант ~double-any~, который превращает «обычную» процедуру с
    двумя аргументами в «дублирующую» процедуру с одним аргументом.

#+begin_src scheme
    (define doubler
      (lambda (f)
        (lambda (x) (f x x))))
#+end_src

    ~doubler~ принимает один аргумент, ~f~, который должен быть процедурой, принимающей два аргумента. Процедура,
    возвращаемая ~doubler~ принимает один аргумент, который используется как оба аргумента при применении ~f~. Мы можем
    определить с помощью ~doubler~ процедуры ~double~ и ~double-cons~ из прошлой главы:

#+begin_src scheme
    (define double (doubler +))
    (double 13/2) → 13

    (define double-cons (doubler cons))
    (double-cons 'a) → (a . a)
#+end_src

    Также мы можем определить ~double-any~ с помощью ~doubler~.

#+begin_src scheme
    (define double-any
      (lambda (f x)
        ((doubler f) x)))
#+end_src

    В ~double~ и ~double-cons~, ~f~ преобретает собственное значение т.е. ~+~ или ~cons~, даже если процедуры явно
    применяются вне области действия ~f~.

    Что произойдёт, если вы попробуете использовать пременную, не связанную ~let~ или ~lambda~, а так же не имеющую
    определения на верхнем уровне? Попробуйт использовать переменную ~i-am-not-defined~ чтобы увидеть, что произойдёт.

#+begin_src scheme
    (i-am-not-defined 3)
#+end_src

    Большенство реализаций Scheme выведет сообщение, уведомляющее о том, что произошло исключение из за использования
    несвязанной или неопределённой переменной.

    Однако система не должна жаловаться на появление неопределенной переменной в лямбда-выражении до тех пор, пока не
    будет применена результирующая процедура. Следующее не должно вызывать исключения, хотя мы еще не установили
    определение верхнего уровня для ~proc2~.

#+begin_src scheme
    (define proc1
      (lambda (x y)
        (proc2 y x)))
#+end_src

    Если вы попробуете применить ~proc1~ до определения ~proc2~, вы должны получить сообщение об исключении из за
    неопределённости переменной. Давайте дадим ~proc2~ определение верхнего уровня и опробуем ~proc1~.

#+begin_src scheme
    (define proc2 cons)
    (proc1 'a 'b) → (b . a)
#+end_src

    Когда вы определяете ~proc1~ система принимает ваше обещание определить ~proc2~ и не жалуется до тех пор, пока вы не
    используете ~proc1~, так и не определив ~proc2~. Это позволяет вам определять процедуры в любом удобном для вас
    порядке. Это особенно удобно, когда ты пытаешься организовать файл, полный определений процедур, таким образом,
    чтобы сделать его более читаемым. Это так же нужно, когда две процедуры, определённых на верхнем уровне, зависят
    друг от друга, вы увидите такие примеры далее.

**** Упражнение 2.6.1

     Что произойдёт, если вы наберёте

#+begin_src scheme
     (double-any double-any double-any)
#+end_src

     давая определение ~double-any~ в начале этого раздела?

**** Упражнение 2.6.2

     Более элегантный (а также возможно менее эффективный) способ определения ~cadr~ и ~cddr~, чем данный в этой главе,
     это определить процедуру, которая объединяет две процедуры, чтобы создать третью. Создайте процедуру ~compose~,
     вида ~(compose p1 p2)~, которая будет создавать композицию процедур ~p1~ и ~p2~ (предполагается, что они ожидают по
     одному аргументу). Применение этой процедуры, ~(compose p1 p2)~, должно возвращать новую процедуру от одного
     аргумента, которая применяет ~p1~ к результату применения ~p2~ к аргументу. Используйте эту процедуру, чтобы
     определить ~cadr~ и ~cddr~.

**** Упражнение 2.6.3

     Scheme также предоставляет процедуры ~caar~, ~cdar~, ~caaar~, ~caadr~ и т.д., все компинации до четырёх /a/
     (обозначающих ~car~) или /d/ (обозначающих ~cdr~) между /c/ и /r/ (см. Главу 6.3). Определите каждую из них с
     помощью процедуры ~compose~ из предыдущего упражнения.

*** Условные выражения

    До сих пор мы рассматривали выражения, которые выполняют свою задачу безоговорочно. Предположим, что мы хотим
    написать процедуру ~abs~. Если аргумент ~x~ отрицательный, ~abs~ возвращает ~-x~; в противном случае возвращает
    ~х~. Самый простой способ написать ~abs~ - это определить, является ли аргумент отрицательным и, если это так,
    инвертировать его, используя синтаксическую форму ~if~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (< n 0)
            (- 0 n)
            n)))

    (abs 77) → 77
    (abs -77) → 77
#+end_src

    Выражение ~if~ имеет форму ~(if тест следствие альтернатива)~, где ~следствие~ это выражение, которое будет
    вычислено, если ~тест~ будет истиной (true), а ~альтернатива~, соответственно, выражение, которое будет выполнено в
    обратном случае т.е. если ~тест~ будет ложью (false). В выражении выше, тест это ~(< n 0)~, следствие ~(- 0 n)~, а
    альтернатива это ~n~.

    Процедура ~abs~ может быть написана множеством других способов. Любое из следующего является корректным определением
    ~abs~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (>= n 0)
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (not (< n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (or (> n 0) (= n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (= n 0)
            0
            (if (< n 0)
                (- 0 n)
                n))))

    (define abs
      (lambda (n)
        ((if (>= n 0) + -)
         0
         n)))
#+end_src

    Первое из этих определений спрашивает, является ли ~n~ больше или равно нулю, инвертируя тест. Второе спрашивает, если
    ~n~ не меньше нуля, используя процедуру ~not~ с ~<~. Третье спрашивает, является ли ~n~ больше нуля или ~n~ равно нулю,
    используя синтаксическую форму ~or~. Четвертое рассматривает ноль отдельно, хотя в этом нет никакой пользы. Пятое
    несколько хитрее; ~n~ либо прибавляется, либо вычитается из нуля, в зависимости от того, больше или равно ~n~ чем
    ноль.

    Почему ~if~ это синтаксическая форма, а не процедура? Чтобы ответить на этот вопрос, давайте вернемся к определению
    обратной величины из первого раздела этой главы.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Второй аргумент процедуры деления не должен быть нулевым, поскольку результат математически не определен. Наше
    определение обратной величины позволяет избежать этой проблемы путем проверки на ноль перед делением. Если бы ~if~
    была процедурой, её аргументы (включая ~(/ 1 n)~) были бы вычислены прежде, чем у нее была возможность выбора между
    следствием и альтернативой. Как и цитирование (~quote~), которое не вычисляет своё единственное подвыражение, ~if~
    не вычисляет все его подвыражения и поэтому не может быть процедурой.

    Синтаксическая форма ~or~ действует аналогично ~if~. Общая форма выражения ~or~ является ~(or expr ...)~. Если нет
    подвыражений, то есть выражение просто ~(or)~, значение ложно. В противном случае каждое выражение вычисляется по
    очереди, пока либо (а) одно из выражений не станет истинным, либо (б) больше не останется выражений. В случае (а)
    значение истинно; в случае (б) значение ложно.

    Чтобы быть более точным, в случае (a) значение выражения ~or~ является значением последнего вычисленного
    подвыражения. Это уточнение необходимо, потому что существует много возможных истинных значений. Обычно результатом
    тестового выражения является один из двух объектов ~#t~ для обозначения истины или ~#f~ для лжи.

#+begin_src scheme
    (< -1 0) → #t
    (> -1 0) → #f
#+end_src

    Каждый объект Scheme, любой, является либо истиной либо ложью, для условных выражений, но не для процедур. Только
    ~#f~ считается ложью, любой другой объект считается истиной.

#+begin_src scheme
    (if #t 'true 'false) → true
    (if #f 'true 'false) → false
    (if '() 'true 'false) → true
    (if 1 'true 'false) → true
    (if '(a b c) 'true 'false) → true

    (not #t) → #f
    (not "false") → #f
    (not #f) → #t

    (or) → #f
    (or #f) → #f
    (or #f #t) → #t
    (or #f 'a #f) → a
#+end_src

    Синтаксическая форма ~and~ похожа на ~or~ или, но выражение ~and~ является истинным, если все его подвыражения
    истинны, и ложным в противном случае. В случае, когда нет никаких подвыражений, то есть выражение просто ~(and)~,
    значение равно ~true~. В противном случае подвыражения вычисляются по очереди до тех пор, пока либо не останется
    подвыражений, либо значение подвыражения будет ложным. Результатом выполнения ~and~ является значение последнего
    вычисленного подвыражения.

    Используя ~and~ мы можем определить ~reciprocal~ несколько иначе:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (and (not (= n 0))
             (/ 1 n))))

    (reciprocal 3) → 1/3
    (reciprocal 0.5) → 2.0
    (reciprocal 0) → #f
#+end_src

    В этой версии значение равно ~#f~, если ~n~ равно нулю, и ~1/n~ в противном случае.

    Процедуры ~=~, ~<~, ~>~, ~<=~, и ~>=~ называются предикатами. Предикаты это процедуры, которые отвечают на
    специальный вопрос о своём аргументе и возвращают одно из двух значений, ~#t~ или ~#f~. Имена большинства предикатов
    заканчиваются знаком вопроса (?). Простейшие численные процедуры, перечисленные выше, исключение из правил. Конечно
    же не все предикаты требуют в качестве аргументов числа. Предикат ~null?~ возвращает истину, если его аргумент
    пустой список ~()~, иначе ложь.

#+begin_src scheme
    (null? '()) → #t
    (null? 'abc) → #f
    (null? '(x y z)) → #f
    (null? (cdddr '(x y z))) → #t
#+end_src

    Процедуре ~cdr~ нельзя передавать ничего, кроме пары, иначе это приведёт к исключению. В Common Lisp, однако,
    результат ~(cdr '())~ определен как ~()~. Следующая процедура, ~lisp-cdr~, определена с использованием ~null?~,
    чтобы вернуть ~()~, если её аргумент был ~()~.

#+begin_src scheme
    (define lisp-cdr
      (lambda (x)
        (if (null? x)
            '()
            (cdr x))))

    (lisp-cdr '(a b c)) → (b c)
    (lisp-cdr '(c)) → ()
    (lisp-cdr '()) → ()
#+end_src

    Еще один полезный предикат - ~eqv?~, который ожидает два аргумента. Если два аргумента эквивалентны, ~eqv?~
    возвращает истину. Иначе ~eqv?~ возвращает ложь.

#+begin_src scheme
    (eqv? 'a 'a) → #t
    (eqv? 'a 'b) → #f
    (eqv? #f #f) → #t
    (eqv? #t #t) → #t
    (eqv? #f #t) → #f
    (eqv? 3 3) → #t
    (eqv? 3 2) → #f
    (let ([x "Hi Mom!"])
      (eqv? x x)) → #t
    (let ([x (cons 'a 'b)])
      (eqv? x x)) → #t
    (eqv? (cons 'a 'b) (cons 'a 'b)) → #f
#+end_src

    Как видите, ~eqv?~ возвращает истину, если аргументы - это один и тот же символ, логическое значение, число, пара
    или строка. Две пары не считаются эквивалентными с точки зрения ~eqv?~, если они были созданы различными вызовами
    ~cons~, даже если их содержимое одинаково. Подробные правила эквивалентности для ~eqv?~ приведены в разделе 6.2.

    Scheme также предоставляет набор предикатов типа, которые возвращают истину или ложь в зависимости от типа объекта,
    например, ~pair?~, ~symbol?~, ~number?~, и ~string?~. Предикат ~pair?~, например, возвращает истину только в случае,
    если его аргумент - пара.

#+begin_src scheme
    (pair? '(a . c)) → #t
    (pair? '(a b c)) → #t
    (pair? '()) → #f
    (pair? 'abc) → #f
    (pair? "Hi Mom!") → #f
    (pair? 1234567890) → #f
#+end_src

    Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
    example, the following version of reciprocal checks first to see that its argument is a number before testing against
    zero or performing the division.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            "oops!")))

    (reciprocal 2/3) → 3/2
    (reciprocal 'a) → "oops!"
#+end_src

    Между прочим, код, использующий ~reciprocal~ должен проверять, что было возвращено процедурой - число или
    строка. Чтобы освободить пользователя процедуры от этого обязательства, обычно предпочтительно сообщить об ошибке,
    используя ~assertion-violation~ (науршение соглашения) следующим образом:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            (assertion-violation 'reciprocal
              "improper argument"
              n))))

    (reciprocal .25) → 4.0
    (reciprocal 0) → exception in reciprocal: improper argument 0
    (reciprocal 'a) → exception in reciprocal: improper argument a
#+end_src

    Первый аргумент ~assertion-violation~ это символом, показывающий, откуда исходит сообщение, второй является строкой,
    описывающей ошибку, а третий и последующие аргументы являются «раздражителями», которые будут включены в сообщение
    об ошибке.

    Давайте рассмотрим ещё одно условное выражение, ~cond~, которое часто оказывается более полезно, чем ~if~. ~cond~
    похож на ~if~ с той разницей, что он позволяет указывать множество пар тест -> выражение. Рассмотрим следующее
    определение процедуры ~sign~, которая возвращает -1, если ей передали негативный аргумент, +1 если позитивный, иначе
    ноль.

#+begin_src scheme
    (define sign
      (lambda (n)
        (if (< n 0)
            -1
            (if (> n 0)
                +1
                0))))

    (sign -88.3) → -1
    (sign 0) → 0
    (sign 333333333333) → 1
    (* (sign -88.3) (abs -88.3)) → -88.3
#+end_src

    Эти два ~if~ выражения могут быть заменены одним ~cond~ следующим образом:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [else 0])))
#+end_src

    Выражение ~cond~ обычно имеет следующую форму:

#+begin_src scheme
    (cond (test expr) ... (else expr))
#+end_src

    Конечно же клауза ~else~ может быть опущена. Это следует делать только в том случае, если невозможно, чтобы все
    тесты провалились, как в новой версии ~sign~ ниже:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [(= n 0) 0])))
#+end_src

    В этом определении ~sign~ не зависит от порядка в котором тесты будут проводиться, потому что только один из тестов
    может быть истиной, для любого ~n~. Следующая процедура рассчитывает налог для указанного дохода в прогрессивной
    налоговой системе с контрольными точками для 10000, 20000, 30000 долларов.

#+begin_src scheme
    (define income-tax
      (lambda (income)
        (cond
          [(<= income 10000) (* income .05)]
          [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
          [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
          [else (+ (* (- income 30000) .21) 2600.00)])))

    (income-tax 5000) → 250.0
    (income-tax 15000) → 900.0
    (income-tax 25000) → 1950.0
    (income-tax 50000) → 6800.0
#+end_src

    В этом примере важен порядок выполнения тестов - слева направо (сверху вниз).

**** Упражнение 2.7.1

     Определите предикат ~atom?~, который возвращает истину, если его аргумент не пара и ложь в обратном случае.

**** Упражнение 2.7.2

     Процедура ~length~ возвращает длину своего аргумента, который должен быть списком. Например, ~(length '(a b c))~
     это 3. Используя ~length~, определите процедуру ~shorter~, возвращающую кратчайший из двух списков в
     аргументах. Пусть она возвращает первый список, если длины равны.

#+begin_src scheme
     (shorter '(a b) '(c d e)) → (a b)
     (shorter '(a b) '(c d)) → (a b)
     (shorter '(a b) '(c)) → (c)
#+end_src

*** Простая рекурсия

    Мы видели, кака можно контролировать выполнение с помощью ~if~, ~or~ и ~cond~. Мы также можем выполнить выражение
    более одного раза, создав процедуру, содержащую это выражение и вызвав её несколько раз. Но что, если нам необходимо
    повторять некоторое выражение, например, для каждого элемента в списке или для каждого числа от одного до десяти? Мы
    можем сделать это с помощью рекурсии. В основе рекурсии лежит простая идея: вызов процедуры из самой этой
    процедуры. Освоение рекурсии может показаться сложным, на первых порах, однако освоившись с ней, вы получаете в своё
    распоряжение мощную силу, намного превосходящую обычные циклы.

    Рекурсивная процедура это процедура, вызывающая саму себя. Ниже представлен, возможно, самый простой вариант
    рекурсивной процедуры, которую мы назвали ~goodbye~.

#+begin_src scheme
    (define goodbye
      (lambda ()
        (goodbye)))

    (goodbye) →
#+end_src

    Эта процедура не принимает аргументов и просто немедленно вызывает саму себя. Здесь нет значения после → потому что
    ~goodbye~ никогда не вернёт управление (и результат).

    Обычно, чтобы получить практическую пользу от рекурсивной процедуры мы должны предусмотреть некое условие остановки
    рекурсии. Большинство рекурсивных процедур должно содержать по меньшей мере два базовых элемента - /базовый вариант/
    и /шаг рекурсии/. Базовый вариант останавливает процедуру, возвращая значение в случае получения некого базового
    аргумента. Шаг рекурсии описывает результат в терминах вызова этой же процедуры, примененной к новому аргументу. Чтобы
    завершить рекурсию, этот новый аргумент должен быть ближе к базовому случаю, чем предыдущий.

    Давайте рассмотрим проблему поиска длины правильного списка рекурсивным способом. Нам нужны базовый случай и шаг
    рекурсии. Логичным базовым аргументом при рекурсии по списку почти всегда будет пустой список. Длина пустого списка
    равна нулю, так что базовый случай должен возвращать ноль, если его аргументом будет пустой список. Чтобы
    последовательно приближаться к пустому списку, естественнно будет на  шаге рекурсии применять ~cdr~ к
    аргументу. Непустой список на один элемент длинее, чем его ~cdr~, так что шаг рекурсии дает значение на единицу
    больше длины ~cdr~ списка.

#+begin_src scheme
    (define length
      (lambda (ls)
        (if (null? ls)
            0
            (+ (length (cdr ls)) 1))))

    (length '()) → 0
    (length '(a)) → 1
    (length '(a b)) → 2
#+end_src

    Выражение ~if~ проверяет не пуст ли список. Если это так, результат - ноль. Это базовый случай. Если нет, результат
    будет на единицу больше, чем длина ~cdr~ этого списка. Это шаг рекурсии.

    Многие реализации Scheme позволяют отслеживать выполнение процедуры, чтобы увидеть, как она работает. Например, в
    Chez Scheme одним из способов трассировки процедуры является ввод ~(trace name)~, где ~name~ - это имя процедуры,
    которую вы определили на верхнем уровне. Если вы трассируете ~length~, как определено выше, и передадите ей аргумент
    ~'(a b c d)~, вы должны увидеть что-то вроде этого:

#+BEGIN_EXAMPLE
    |(length (a b c d))
    | (length (b c d))
    | |(length (c d))
    | | (length (d))
    | | |(length ())
    | | |0
    | | 1
    | |2
    | 3
    |4
#+END_EXAMPLE

    Отступами обозначен уровень глубины рекурсии; вертикальные линии визуально соотносят вызовы процедур с их
    результатами. Обратите внимание, что с каждым вызовом ~length~ список становится меньше, пока окончательно не станет
    ~()~. Результат для ~()~ известен - это 0, и каждый уровень глубины добавляет к этому результату единицу.

    Давайте напишем процедуру ~list-copy~, возвращающую копию своего аргумента, который должен быть списком. Именно
    новый список из заново спареных элементов (но не старых пар) старого списка. Создание копии может быть полезным,
    если исходный список или копия могут быть модифицированы с помощью ~set-car!~ или ~set-cdr!~, о которые мы поговорим
    позже.

#+begin_src scheme
    (list-copy '()) → ()
    (list-copy '(a b c)) → (a b c)
#+end_src

    Посмотрите, можете ли вы определить ~list-copy~, прежде чем изучать определение ниже.

#+begin_src scheme
    (define list-copy
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (car ls)
                  (list-copy (cdr ls))))))
#+end_src

    Определение ~list-copy~ аналогично определению ~length~. Тест в базовом случае такой же, ~(null? ls)~.  Значение в
    базовом случае равно ~()~, а не 0, потому что мы строим список, а не число. Рекурсивный вызов такой же, но вместо
    добавления единицы, ~list-copy~ спаривает ~car~ списка-аргумента с результатом рекурсивного вызова.

    Нет причин, по которым не может быть более одного базового случая. Процедура ~memv~ принимает два аргумента, объект
    и список. Возвращает первый подсписок (хвост списка), чей ~car~ равен объекту, или ~#f~, если объект не найден в
    списке. Значение ~memv~ может использоваться как список или как значение истинности в условном выражении.

#+begin_src scheme
    (define memv
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eqv? (car ls) x) ls]
          [else (memv x (cdr ls))])))

    (memv 'a '(a b b d)) → (a b b d)
    (memv 'b '(a b b d)) → (b b d)
    (memv 'c '(a b b d)) → #f
    (memv 'd '(a b b d)) → (d)
    (if (memv 'b '(a b b d))
        "yes"
        "no") → "yes"
#+end_src

    Здесь есть два условия для проверки, так что используем ~cond~. Первое условие ~cond~ проверяет базовое
    значение ~()~; ни один объект не является членом ~()~, поэтому ответ ~#f~. Вторая клауза проверяет, является ли
    ~car~ списка искомым объектом, и в этом случае возвращается список, являющийся первым хвостом, ~car~ которого
    содержит искомый объект. Шаг рекурсии просто продолжает обход дальше по списку.

    Также может быть более одного случая рекурсии. Как и ~memv~, процедура ~remv~, определенная ниже, принимает два
    аргумента, объект и список. Возвращает новый список, в котором все вхождения объекта удалены из списка.

#+begin_src scheme
    (define remv
      (lambda (x ls)
        (cond
          [(null? ls) '()]
          [(eqv? (car ls) x) (remv x (cdr ls))]
          [else (cons (car ls) (remv x (cdr ls)))])))

    (remv 'a '(a b b d)) → (b b d)
    (remv 'b '(a b b d)) → (a d)
    (remv 'c '(a b b d)) → (a b b d)
    (remv 'd '(a b b d)) → (a b b)
#+end_src

    Это определение аналогично определению ~memv~ выше, за исключением того, что ~remv~ не завершает работу, когда находит
    нужный элемент в ~car~ списка. Выполнение продолжается, просто игнорируя элемент. Если элемент не найден в ~car~,
    ~remv~ делает то же самое, что и ~list-copy~ выше: он спаривает ~car~ списка с результатом рекурсии.

    До сих пор рекурсия проходила только по ~cdr~ списка. Однако иногда полезно, чтобы процедура повторялась как на
    ~cdr~, так и на ~car~ списка. Процедура ~tree-copy~, определённая ниже, интерпретирует структуру пар как дерево, а
    не как список, где левое поддерево является ~car~ от пары, а правое - ~cdr~. Процедура совершает схожие с
    ~list-copy~ операции, образуя новые пары, но оставляя старые элементы (листья).

#+begin_src scheme
    (define tree-copy
      (lambda (tr)
        (if (not (pair? tr))
            tr
            (cons (tree-copy (car tr))
                  (tree-copy (cdr tr))))))

    (tree-copy '((a . b) . c)) → ((a . b) . c)
#+end_src

    Естественным базовым аргументом для древовидной структуры является все, что не является парой, поскольку рекурсия
    проходит через пары, а не списки. В этом случае рекурсивный шаг вдвойне рекурсивен, рекурсивно находит значение для
    ~car~, а также ~cdr~ аргумента.

    На этом этапе читатели, знакомые с другими языками, которые предоставляют специальные итерационные конструкции,
    например циклы ~while~ или ~for~, могут задаться вопросом, требуются ли подобные конструкции в Scheme. Такие
    конструкции не нужны; итерация в Scheme выражается более ясно и лаконично через рекурсию. Рекурсия носит более общий
    характер и устраняет необходимость назначения переменных, требуемых итерационными конструкциями многих других
    языков, в результате чего получается более надежный и понятный код. Некоторая рекурсия по сути является итерацией и
    выполняется таким же образом; Раздел 3.2 может сказать больше об этом. Однако зачастую нет необходимости проводить
    различие. Вместо этого сконцентрируйтесь на написании ясных, кратких и правильных программ.

    Прежде чем мы оставим тему рекурсии, давайте рассмотрим специальную форму повторения, называемую /отображением/.
    Рассмотрим следующую процедуру ~abs-all~, которая принимает список чисел в качестве входных данных и возвращает
    список их абсолютных значений.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (abs (car ls))
                  (abs-all (cdr ls))))))

    (abs-all '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Эта процедура формирует новый список из входного списка, применяя процедуру ~abs~ к каждому элементу. Мы говорим,
    что ~abs-all~ отображает входной список в выходной при помощи ~abs~. Отображение списков через процедуры - довольно
    распространенная вещь, поэтому Scheme предоставляет процедуру ~map~, которая отображает с помощью своего первого
    аргумента, процедуры, свой второй аргумент, список. Мы можем использовать ~map~, чтобы определить ~abs-all~.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (map abs ls)))
#+end_src

    Однако в действительности мы не нуждаемся в ~abs-all~, поскольку соответствующее прямое применение ~map~ такое же
    короткое и, возможно, более понятное.

#+begin_src scheme
    (map abs '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Конечно, мы можем использовать ~lambda~ чтобы создать аргумент-процедуру для ~map~, например, чтобы возводить в
    квадрат числа в списке.

#+begin_src scheme
    (map (lambda (x) (* x x))
         '(1 -3 -5 7)) → (1 9 25 49)
#+end_src

    Мы можем отображать сразу несколько списков с помощью процедуры, имеющей столько же аргументов, например:

#+begin_src scheme
    (map cons '(a b c) '(1 2 3)) → ((a . 1) (b . 2) (c . 3))
#+end_src

    Списки должны иметь одинаковую длину, и процедура должна принимать столько аргументов, сколько списков
    передано. Каждый элемент выходного списка является результатом применения процедуры к соответствующим элементам
    входных списков.

    Глядя на первое определение ~abs-all~ выше, вы должны были уже начать догадываться, ещё до изученного только что,
    как могла бы быть устроена процедура ~map1~ - ограниченная версия ~map~, которая отображает процедуру с одним
    аргументом в одном списке.

#+begin_src scheme
    (define map1
      (lambda (p ls)
        (if (null? ls)
            '()
            (cons (p (car ls))
                  (map1 p (cdr ls))))))

    (map1 abs '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Все, что мы сделали, это заменили вызов ~abs~ в ~abs-all~ вызовом нового параметра ~p~. Определение более общего
    ~map~ дано в разделе 5.4.

**** Упражнение 2.8.1

     Опишите, что произойдет, если вы измените порядок аргументов ~cons~ в определении ~tree-copy~.

**** Упражнение 2.8.2

     Обратитесь к разделу 6.3 для описания ~append~ и напишите её новую версию с двумя аргументами. Что произойдет, если
     вы измените порядок аргументов в вызове ~append~ в пределах вашего определения ~append~?

**** Упражнение 2.8.3

     Определите процедуру ~make-list~, которая принимает неотрицательное целое число ~n~ и объект и возвращает новый
     список длиной ~n~, каждый элемент которого является этим объектом.

#+begin_src scheme
     (make-list 7 '()) → (() () () () () () ())
#+end_src

     [Подсказка: базовый тест должен быть ~(= n 0)~, а шаг рекурсии должен включать ~(- n 1)~. Тогда как ~()~ -
     естественный базовый случай для рекурсии по спискам, 0 - естественный базовый случай для рекурсии по
     неотрицательным целым числам. Точно так же вычитание 1 является естественным способом приблизить неотрицательное
     целое число к 0.]

**** Упражнение 2.8.4

     Процедуры ~list-ref~ и ~list-tail~ возвращают N-ный элемент и N-ный хвост списка соответственно.

#+begin_src scheme
     (list-ref '(1 2 3 4) 0) → 1
     (list-tail '(1 2 3 4) 0) → (1 2 3 4)
     (list-ref '(a short (nested) list) 2) → (nested)
     (list-tail '(a short (nested) list) 2) → ((nested) list)
#+end_src

     Определите обе процедуры.

**** Упражнение 2.8.5

     В упражнении 2.7.2 вы использовали ~length~ в определении процедуры ~shorter~, возвращающей кратчайший из двух
     переданных списков, или первый, если длины равны. Напишите ~shorter~ без использования ~length~. [Подсказка:
     определите рекурсивную процедуру-помошник ~shorter?~ и используйте её вместо сравнения длин списков.]

**** Упражнение 2.8.6

     Все рекурсивные процедуры, показанные до сих пор, были непосредственно рекурсивными. То есть каждая процедура
     непосредственно применяет себя к новому аргументу. Также возможно написать две процедуры, которые используют друг
     друга, что приводит к косвенной рекурсии. Определите процедуры ~even?~ (чётно?) и ~odd?~ (нечётно?), каждую в
     терминах другой. [Подсказка: что каждый должен возвращать, когда его аргумент равен 0?]

#+begin_src scheme
     (even? 17) → #f
     (odd? 17) → #t
#+end_src

**** Упражнение 2.8.7

     Используйте ~map~, чтобы определить процедуру ~transpose~, которая берет список пар и возвращает пару списков
     следующим образом.

#+begin_src scheme
     (transpose '((a . 1) (b . 2) (c . 3))) → ((a b c) 1 2 3)
#+end_src

     [Подсказка: ~((a b c) 1 2 3)~ это то же, что и ~((a b c) . (1 2 3))~.]

*** Присваивания

    Хотя многие программы могут быть написаны без них, иногда полезны определения переменных верхнего уровня,
    let-связывания и lambda-связывания. /Присваивания/ не создают новые связывания, как в случае ~let~ или ~lambda~, а
    скорее изменяют значения существующих связываний. Присваивания выполняются с помощью  ~set!~.

#+begin_src scheme
    (define abcde '(a b c d e))
    abcde → (a b c d e)
    (set! abcde (cdr abcde))
    abcde → (b c d e)
    (let ([abcde '(a b c d e)])
      (set! abcde (reverse abcde))
      abcde) → (e d c b a)
#+end_src

    Многие языки требуют использования присваиваний для инициализации локальных переменных, отдельно от объявления или
    связывания переменных. В Scheme все локальные переменные получают значение сразу после связывания. Помимо
    необходимости выполнять отдельное присваивание для инициализации локальных переменных, это гарантирует, что
    программист не сможет забыть инициализировать их, что является распространенным источником ошибок в большинстве
    языков.

    Фактически, большинство назначений, которые либо необходимы, либо удобны в других языках, в Scheme как ненужны, так
    и неудобные, поскольку обычно существует более понятный способ выражения того же алгоритма без присвоений. Обычной
    практикой в некоторых языках является последовательное выполнение выражений и присваиваний, как в следующей
    процедуре, которая находит корни квадратного уравнения.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
          (cons root1 root2))))
#+end_src

    Корни вычисляются по известной формуле поиска корней квадратного уравнения,

#+ATTR_LATEX: :width 60px
[[./images/4.png]]

    что дает решения уравнения /0 = ax^2 + bx + c/. Выражение ~let~ в этом определении используется исключительно для
    установления привязок переменных, соответствующих объявлениям, требуемым в других языках. Первые три выражения
    присваивания вычисляют части формулы, а именно ~-b~ и ~2а~.

#+ATTR_LATEX: :width 60px
[[./images/5.png]]

    Последние два выражения присваивания вычисляют два корня. Пара из двух корней является результатом вычисления
    квадратичной формулы. Например, два корня /2x^2 - 4x - 6/ - это x = 3 и x = -1.

#+begin_src scheme
    (quadratic-formula 2 -4 -6) → (3 . -1)
#+end_src

    Вышеприведенное определение работает, но оно может быть написано более четко без присвоений, как показано ниже.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([minusb (- 0 b)]
              [radical (sqrt (- (* b b) (* 4 (* a c))))]
              [divisor (* 2 a)])
          (let ([root1 (/ (+ minusb radical) divisor)]
                [root2 (/ (- minusb radical) divisor)])
            (cons root1 root2)))))
#+end_src

    В этой версии ~set!~ выражения ушли, и у нас остался по сути тот же алгоритм. Однако, используя два выражения ~let~,
    определение яснее показывает зависимость ~root1~ и ~root2~ от значений ~minusb~, ~radius~ и ~divisor~. Не менее
    важно, что выражения let ясно показывают отсутствие зависимостей между собой для ~minusb~, ~radical~ и ~divisor~, а
    также между ~root1~ и ~root2~.

    Присвоения действительно имеют определённые применения в Scheme, иначе язык бы их не поддерживал. Рассмотрим
    следующую версию ~cons~, которая подсчитывает количество её вызовов, сохраняя счетчик в переменной с именем
    ~cons-count~. Здесь используется ~set!~ чтобы увеличить счетчик; нет способа добиться того же поведения без
    использования подобного рода присвоений.

#+begin_src scheme
    (define cons-count 0)
    (define cons
      (lambda (x y)
        (set! cons-count (+ cons-count 1))
        (cons x y)))
#+end_src

#+begin_src scheme
    (kons 'a '(b c)) → (a b c)
    kons-count → 1
    (kons 'a (kons 'b (kons 'c '()))) → (a b c)
    kons-count → 4
#+end_src

    Присвоения обычно используются для реализации процедур, которые должны поддерживать некоторое внутреннее
    состояние. Например, предположим, что мы хотим определить процедуру, которая возвращает 0 в первый раз, когда она
    вызывается, 1 во второй раз, 2 в третий раз и так далее до бесконечности. Мы могли бы написать что-то похожее на
    определенный выше ~cons-count~:

#+begin_src scheme
    (define next 0)
    (define count
      (lambda ()
        (let ([v next])
          (set! next (+ next 1))
          v)))

    (count) → 0
    (count) → 1
#+end_src

    Это решение несколько нежелательно в том смысле, что переменная ~next~ видна на верхнем уровне, даже если это не
    обязательно. Так как она видна на верхнем уровне, любой код в системе может изменить её значение, возможно,
    непреднамеренно повлиять на поведение счетчика неявным образом. Мы можем решить эту проблему с помощью
    let-связывания вне лямбда-выражения:

#+begin_src scheme
    (define count
      (let ([next 0])
        (lambda ()
          (let ([v next])
            (set! next (+ next 1))
            v))))
#+end_src

    Последнее решение также легко обобщается для предоставления нескольких счетчиков, каждый из которых имеет свой
    собственный локальный счетчик. Процедура ~make-counter~, определенная ниже, возвращает новую процедуру подсчета
    каждый раз, когда она вызывается.

#+begin_src scheme
    (define make-counter
      (lambda ()
        (let ([next 0])
          (lambda ()
            (let ([v next])
              (set! next (+ next 1))
              v)))))
#+end_src

    Поскольку ~next~ связывается внутри ~make-counter~, но вне процедуры, возвращаемой ~make-counter~, каждая
    возвращаемая процедура использует свой уникальный счетчик.

#+begin_src scheme
    (define count1 (make-counter))
    (define count2 (make-counter))

    (count1) → 0
    (count2) → 0
    (count1) → 1
    (count1) → 2
    (count2) → 1
#+end_src

   Если переменная состояния должна совместно использоваться более чем одной процедурой, определенной на верхнем уровне,
   но мы не хотим, чтобы переменная состояния была видимой на верхнем уровне, мы можем использовать ~let~, чтобы связать
   переменную и ~set!~ сделать процедуры видимыми на верхнем уровне.

#+begin_src scheme
    (define shhh #f)
    (define tell #f)
    (let ([secret 0])
      (set! shhh
        (lambda (message)
          (set! secret message)))
      (set! tell
        (lambda ()
          secret)))

    (shhh "sally likes harry")
    (tell) → "sally likes harry"
    secret → exception: variable secret is not bound
#+end_src

    Переменные должны быть определены до того, как им будет присвоено значение, поэтому мы вначале определяем ~shhh~ и
    присваиваем ему ~#f~ (подойдет любое начальное значение). Мы увидим эту структуру снова в Разделе 3.5, а лучший
    способ структурировать подобный код как библиотеку в Разделе 3.6.

    Локальное состояние иногда полезно для кэширования вычисленных значений, а так же позволяет производить ленивые
    вычисления, т. е. производить вычисления только один раз и только по требованию. Процедура ~lazy~ ниже принимает
    чанк (англ. thunk), процедуру нулевой арности, в качестве аргумента. Чанки часто используются для «замораживания»
    вычислений, которые по какой-то причине должны быть отложены, что в точности то, что нам нужно в данной
    ситуации. При передаче чанка ~t~, ~lazy~ возвращает новый чанк, который при вызове возвращает значение вызова
    ~t~. Единожды вычисленое, значение сохраняется в локальной переменной, так что вычисление больше не
    требуется. Логический флаг используется для записи того, был ли вычислен ~t~ и сохранено ли его значение.

#+begin_src scheme
    (define lazy
      (lambda (t)
        (let ([val #f] [flag #f])
          (lambda ()
            (if (not flag)
                (begin (set! val (t))
                       (set! flag #t)))
            val))))
#+end_src


    Синтаксическая форма ~begin~, используемая здесь впервые, выполняет свои подвыражения в последовательности слева
    направо и возвращает значение последнего подвыражения, как тело выражения ~let~ или лямбда-выражения. Мы также
    видим, что альтернативное подвыражение выражения ~if~ может быть опущено. Это должно быть сделано только тогда,
    когда значение ~if~ отбрасывается, как в этом случае.

    Ленивые вычисления особенно полезны для значений, которые требуют значительного времени для рассчёта. Откладывая
    вычисление, мы можем избежать рассчёта значения в целом, а сохраняя результат, мы избегаем вычисления его более
    одного раза.

    Функционирование ~lazy~ может быть лучше всего проиллюстрирована выводом сообщения из чанка, переданного в
    ~lazy~ в качестве аргумента.

#+begin_src scheme
    (define p
      (lazy (lambda ()
              (display "Ouch!")
              (newline)
              "got me")))
#+end_src

    При первом вызове ~p~  печатается сообщение ~"Ouch!"~ , и возвращается строка ~"got me"~ . Последующие вызовы
    возвращают ~"got me"~ , но сообщение не печатают. Процедуры ~display~ и ~newline~ - это первые примеры явного
    ввода/вывода, которые мы видели; ~display~ выводит строку без кавычек, а ~newline~  печатает символ новой строки.

    Чтобы дополнительно проиллюстрировать использование ~set!~, давайте рассмотрим реализацию объектов стека, внутренняя
    работа которых не видна снаружи. Объект стека принимает одно из четырех сообщений: ~empty?~, которое возвращает
    ~#t~, если стек пуст; ~push!~, который добавляет объект на вершину стека; ~top~, который возвращает объект с
    вершины стека; и ~pop!~, который удаляет объект сверху стека. Приведенная ниже процедура ~make-stack~ создает новый
    стек каждый раз, когда она вызывается, аналогично ~make-counter~.

#+begin_src scheme
    (define make-stack
      (lambda ()
        (let ([ls '()])
          (lambda (msg . args)
            (cond
              [(eqv? msg 'empty?) (null? ls)]
              [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
              [(eqv? msg 'top) (car ls)]
              [(eqv? msg 'pop!) (set! ls (cdr ls))]
              [else "oops"])))))
#+end_src

    Каждый стек хранится в виде списка, привязанного к переменной ~ls~; ~set!~ используется для изменения этой привязки
    в ~push!~ и ~pop!~. Обратите внимание, что список аргументов внутреннего лямбда-выражения использует синтаксис
    неправильного списка для связывания всех аргументов, кроме первого, со списком. Это полезно здесь, потому что в
    случае ~empty?~, ~top~ и ~pop!~ есть только один аргумент (сообщение), но в случае ~push!~ их два (сообщение и
    объект, который нужно поместить в стек).

#+begin_src scheme
    (define stack1 (make-stack))
    (define stack2 (make-stack))
    (list (stack1 'empty?) (stack2 'empty?)) → (#t #t)

    (stack1 'push! 'a)
    (list (stack1 'empty?) (stack2 'empty?)) → (#f #t)

    (stack1 'push! 'b)
    (stack2 'push! 'c)
    (stack1 'top) → b
    (stack2 'top) → c

    (stack1 'pop!)
    (stack1 'top) → a
    (list (stack1 'empty?) (stack2 'empty?)) → (#f #f)

    (stack1 'pop!)
    (list (stack1 'empty?) (stack2 'empty?)) → (#t #f)
#+end_src

    Как и в случае счетчиков, созданных ~make-counter~, состояние, используемое каждым объектом стека, напрямую доступно
    только внутри объекта. Каждый доступ или изменение этого состояния выполняется явно самим объектом. Одним из важных
    преимуществ является то, что мы можем изменить внутреннюю структуру стека, например, использовав вектор (см. Раздел
    6.9) вместо списка для хранения элементов без изменения его внешнего поведения. Поскольку поведение объекта известно
    абстрактно (не операционно), он считается абстрактным объектом. Смотри раздел 12.8 для получения дополнительной
    информации о создании абстрактных объектов.

    Помимо изменения значений переменных, мы также можем изменять значения полей пар ~car~ и ~cdr~, используя процедуры
    ~set-car!~ и ~set-cdr!~ .

#+begin_src scheme
    (define p (list 1 2 3))
    (set-car! (cdr p) 'two)
    p → (1 two 3)
    (set-cdr! p '())
    p → (1)
#+end_src

    Мы можем использовать эти операторы для определения типа данных 'очередь', который похож на стек, за исключением
    того, что новые элементы добавляются на одном конце и извлекаются из другого. Следующая реализация очереди
    использует структуру ~tconc~. ~tconc~ состоит из непустого списка и заголовка. Заголовок - это пара, ~car~ которой
    указывает на первую пару (заголовок) списка, а ~cdr~ указывает на последнюю пару (конец) списка.

#+ATTR_LATEX: :width 200px
[[./images/6.png]]

    Последний элемент списка является заполнителем и не считается частью очереди.

    Ниже приведены четыре операции с очередями: ~make-queue~, которая создает очередь; ~putq!~ , которая добавляет
    элемент в конец очереди; ~getq~, которая извлекает элемент в начале очереди; и ~delq!~, который удаляет элемент из
    начала очереди.

#+begin_src scheme
    (define make-queue
      (lambda ()
        (let ([end (cons 'ignored '())])
          (cons end end))))

    (define putq!
      (lambda (q v)
        (let ([end (cons 'ignored '())])
          (set-car! (cdr q) v)
          (set-cdr! (cdr q) end)
          (set-cdr! q end))))

    (define getq
      (lambda (q)
        (car (car q))))

    (define delq!
      (lambda (q)
        (set-car! q (cdr (car q)))))
#+end_src

    Все это простые операции, кроме ~putq!~, которая изменяет конечную пару, чтобы она содержала новое значение, и
    добавляет новую конечную пару.

#+begin_src scheme
    (define myq (make-queue))

    (putq! myq 'a)
    (putq! myq 'b)
    (getq myq) → a
    (delq! myq)
    (getq myq) → b
    (delq! myq)
    (putq! myq 'c)
    (putq! myq 'd)
    (getq myq) → c
    (delq! myq)
    (getq myq) → d
#+end_src

**** Упражнение 2.9.1

     Измените ~make-counter~ так, чтобы он принимал два аргумента: начальное значение для счетчика, которое будет
     использоваться вместо 0, и значение, на которое счетчик увеличивается каждый раз.

**** Упражнение 2.9.2

     Посмотрите описание случая в разделе 5.3. Замените выражение ~cond~ в ~make-stack~ на эквивалентное выражение
     ~case~. Добавить ~mt?~ как второе имя для сообщения ~empty?~.

**** Упражнение 2.9.3

     Измените объект стека, чтобы разрешить два сообщения ~ref~ и ~set!~. ~(stack 'ref i)~ должен возвращать i-й элемент
     от верхушки стека; ~(stack 'ref 0)~ должен быть эквивалентен ~(stack 'top)~. ~(stack 'set! i v)~ должен изменить
     i-й элемент с вершины стека на v.

#+begin_src scheme
     (define stack (make-stack))

     (stack 'push! 'a)
     (stack 'push! 'b)
     (stack 'push! 'c)

     (stack 'ref 0) → c
     (stack 'ref 2) → a
     (stack 'set! 1 'd)
     (stack 'ref 1) → d
     (stack 'top) → c
     (stack 'pop!)
     (stack 'top) → d
#+end_src

     [Подсказка: используйте ~list-ref~ для реализации ~ref~ и ~list-tail~ с ~set-car!~ чтобы реализовать ~set!~.]

**** Упражнение 2.9.4

     Scheme поддерживает также векторы, как и списки. Как и списки, векторы являются собирательными объектами, которые
     содержат другие объекты. В отличие от списков, векторы имеют фиксированный размер и располагаются в одном плоском
     блоке памяти, обычно с заголовком, содержащим длину вектора, как в векторе из десяти элементов ниже.

#+ATTR_LATEX: :width 200px
[[./images/7.png]]

     Это делает векторы более подходящими для приложений, нуждающихся в быстром доступе к любому элементу
     последовательности, но менее подходящими для приложений, которым требуются структуры данных, которые растут и
     сжимаются по мере необходимости.

     Посмотрите основные векторные операции в Разделе 6.9 и переопределите объект стека, чтобы использовать вектор
     вместо списка для хранения содержимого стека. Добавьте ~ref~ и ~set!~ сообщения из упражнения 2.9.3. Пусть новый
     ~make-stack~ принимает аргумент размера ~n~ и задает длину вектора ~n~, но никак иначе не изменяет внешний
     (абстрактный) интерфейс.

**** Упражнение 2.9.5

     Определите предикат ~emptyq?~, определяющий, пуста ли очередь. Измените ~getq~ и ~delq!~ так, чтобы вызвать
     исключение при обнаружении пустой очереди, используя ~assertion-violation~.

**** Упражнение 2.9.6

     В реализации очереди последняя пара в инкапсулированном списке является заполнителем, то есть никогда не содержит
     ничего полезного. Перепишите операторы очереди, чтобы избежать этой потраченной впустую пары. Убедитесь, что серия
     операций с очередями, приведенная ранее, работает с новой реализацией. Какую реализацию вы бы предпочли?

**** Упражнение 2.9.7

     Используя ~set-cdr!~, можно создавать циклические списки. Например, следующее выражение возвращает список, ~car~
     которого является символ ~a~, а ~cdr~ является самим списком.

#+begin_src scheme
     (let ([ls (cons 'a '())])
       (set-cdr! ls ls)
       ls)
#+end_src

     Что произойдёт, если вы введёте вышеприведенное выражение во время интерактивного сеанса Scheme? Что будет делать
     реализация ~length~ из раздела 2.8, если ей передать циклический список? Как поведёт себя встроенный примитив
     ~length~?

**** Упражнение 2.9.8

     Определите предикат ~list?~, который возвращает ~#t~, если его аргумент является правильным списком, и ~#f~ в
     противном случае (см. Раздел 6.3). Он должен возвращать ~#f~ для циклических списков, а также для списков,
     оканчивающихся объектами, отличными от ~()~.

#+begin_src scheme
     (list? '()) → #t
     (list? '(1 2 3)) → #t
     (list? '(a . b)) → #f
     (list? (let ([ls (cons 'a '())])
              (set-cdr! ls ls)
              ls)) → #f
#+end_src

     Сначала напишите упрощенную версию ~list?~ которая не обрабатывает случай с циклическими списки, а затем расширьте
     её для правильной обработки циклических списков. Пересматривайте свое определение, пока не убедитесь, что оно
     максимально четкое и краткое. [Подсказка: используйте следующий алгоритм "заяц и черепаха" для определения
     цикличных списков. Определите рекурсивную вспомогательную процедуру с двумя аргументами: заяц и черепаха. Запустите
     зайца и черепаху в начале списка. Сделайте так, чтобы заяц продвигался на два ~cdr~ каждый раз,
     когда черепаха продвигается на один ~cdr~. Если заяц ловит черепаху, значит это цикл.]

#+LATEX: \newpage
[[./images/ch3.png]]

** Двигаемся дальше

   Предыдущая глава подготовила вас к написанию программ Scheme с использованием небольшого набора наиболее полезных
   примитивных синтаксических форм и процедур. В этой главе представлен ряд дополнительных функций и методов
   программирования, которые позволят вам писать более сложные и эффективные программы.

*** Syntactic Extension

    Как мы видели в Разделе 2.5, синтаксическая форма ~let~ - это просто синтаксическое расширение, определяемое в
    терминах лямбда-выражения и применения процедуры, которые являются основными синтаксическими формами. В этот момент
    вам может быть интересно, какие синтаксические формы являются основными, а какие - синтаксическими расширениями, и
    как могут быть определены новые синтаксические расширения. В этом разделе приведены некоторые ответы на эти
    вопросы.

    По правде говоря, нам не нужно проводить различие между основными формами и синтаксическими расширениями, поскольку
    после определения синтаксическое расширение имеет точно такой же статус, что и основная форма. Проведение различия,
    однако, облегчает понимание языка, поскольку позволяет нам сосредоточить внимание на основных формах и понять все
    остальные с точки зрения этих форм.

    Для реализации Scheme необходимо различать основные формы и синтаксические расширения. Реализация Scheme
    разворачивает синтаксические расширения в основные формы на первом этапе компиляции или интерпретации, позволяя
    остальной части компилятора или интерпретатора сосредоточиться только на основных формах. Однако набор основных
    форм, остающихся после раскрытия, которые будут обрабатываться непосредственно компилятором или интерпретатором,
    зависит от реализации и может отличаться от набора форм, описанных здесь как основные.

    Таким образом, точный набор синтаксических форм, составляющих ядро ​​языка, является предметом споров, хотя должна
    быть возможность вывести все другие формы из любого набора форм, объявленных основными. Описанный здесь набор
    является одним из самых простых, для которых это ограничение выполняется.

    Основные синтаксические формы включают в себя формы определения верхнего уровня (~define~), константы, переменные,
    применение процедур, ~quote~, ~lambda~, ~if~ и ~set!~ выражения. Грамматика ниже описывает основной синтаксис Scheme
    в терминах этих определений и выражений. В грамматике вертикальные черты (~|~) разделяют альтернативы, а форма, за
    которой следует звездочка (~*~), представляет ноль или более вхождений формы. ~<variable>~ - это любой идентификатор
    Scheme. ~<datum>~ - это любой объект Scheme, например число, список, символ или вектор. ~<boolean>~ это либо ~#t~,
    либо ~#f~, ~<number>~ - это любое число, ~<character>~ - это любой символ, а ~<string>~ - это любая строка. Мы уже
    видели примеры чисел, строк, списков, символов и логических значений. См. главу 6 или описание формального
    синтаксиса, для получения дополнительной информации о синтаксисе этих и других объектов.

#+BEGIN_EXAMPLE
    <program>             → <form>*
    <form>                → <definition> | <expression>
    <definition>          → <variable definition> | (begin <definition>*)
    <variable definition> → (define <variable> <expression>)
    <expression>          → <constant>
                          | <variable>
                          | (quote <datum>)
                          | (lambda <formals> <expression> <expression>*)
                          | (if <expression> <expression> <expression>)
                          | (set! <variable> <expression>)
                          | <application>
    <constant>            → <boolean> | <number> | <character> | <string>
    <formals>             → <variable>
                          | (<variable>*)
                          | (<variable> <variable>* . <variable>)
    <application>         → (<expression> <expression>*)
#+END_EXAMPLE

    Грамматика неоднозначна в том смысле, что синтаксис применения процедур конфликтует с синтаксисами ~quote~,
    ~lambda~, ~if~ и ~set!~ выражения. Чтобы трактоваться как применение процедуры, первое ~<expression>~ не должно быть
    одним из этих ключевых слов, если только ключевое слово не было переопределено или связано локально.

    Синтаксис ~"defun"~ для определения, приведенный в разделе 2.6, не включен в ядро, так как определения в этой форме
    прямо переводятся в более простой синтаксис определения. Точно так же основной синтаксис для ~if~ не позволяет
    опустить альтернативу, как это было сделано в примере в Разделе 2.9. Выражение ~if~, в котором отсутствует
    альтернатива, может быть переведено в основной синтаксис ~if~, просто заменив отсутствующее подвыражение
    произвольной константой, такой как ~#f~.

    Форма ~begin~, содержащая только определения, считается определением в грамматике; это разрешено, чтобы позволить
    синтаксическим расширениям разворачиваться в более чем одно определение. Выражение ~begin~ т.е. форма ~beging~,
    содержащая выражения, не считается основной формой. Выражение ~begin~ в виде

#+begin_src scheme
    (begin e1 e2 ...)
#+end_src

    это эквивалент применения ~lambda~-выражения

#+begin_src scheme
    ((lambda () e1 e2 ...))
#+end_src

    следовательно, нет нужды содержать его в ядре.

    Теперь, когда мы создали набор основных синтаксических форм, давайте обратимся к обсуждению синтаксических
    расширений. Синтаксические расширения называются так потому, что они расширяют ядро синтаксиса Scheme. Все
    синтаксические расширения в программе на Scheme должны быть в конечном итоге сводимы к основным формам. Однако одно
    синтаксическое расширение может быть определено в терминах другого синтаксического расширения, если последнее в
    некотором смысле «ближе» к основному синтаксису. Синтаксические формы могут применяться везде, где ожидается
    выражение или определение, при условии, что расширенная форма раскрывается в определение или выражение по мере
    необходимости.

    Синтаксические расширения определяются с помощью ~define-syntax~. ~define-syntax~ аналогично ~define~, за
    исключением того, что ~define-syntax~ связывает процедуру синтаксического преобразования или преобразователь с
    ключевым словом (например, ~let~), а не связывает значение с переменной. Вот как мы можем определить ~let~ с помощью
    ~define-syntax~.

#+begin_src scheme
    (define-syntax let
      (syntax-rules ()
        [(_ ((x e) ...) b1 b2 ...)
         ((lambda (x ...) b1 b2 ...) e ...)]))
#+end_src

    Идентификатор, появляющийся после ~define-syntax~, является именем или ключевым словом определяемого синтаксического
    расширения, в данном случае ~let~. Форма ~syntax-rule~ - это выражение, которое выполняет преобразователь. Элемент,
    следующий за ~syntax-rule~ - это списком вспомогательных ключевых слов и это почти всегда ~()~. Примером
    вспомогательного ключевого слова является ~else~ в ~cond~ (другие примеры, требующие использования вспомогательных
    ключевых слов, приведены в главе 8). После списка вспомогательных ключевых слов приведена последовательность из
    одного или нескольких правил или пар образец/шаблон. Только одно правило появляется в нашем определении
    ~let~. Часть правила "образец" определяет форму, которую должен принимать вход, а "шаблон" указывает, во что вход
    должен быть преобразован.

    Образец всегда должен быть структурированным выражением, первым элементом которого является подчеркивание (~_~). (Как
    мы увидим в главе 8, использование ~_~ - это всего лишь соглашение, но оно хорошо подходит в нашем случае). Если
    присутствует более одного правила, подходящее выбирается путем сопоставления образцов по порядку с формой, поданой
    на вход, во время раскрытия. Если ни один из образцов не соответствует входным данным, это синтаксическое
    нарушение.

    Идентификаторы, отличные от подчеркивания или многоточия, встречающиеся в образце, являются переменными образца,
    если только они не указаны в качестве вспомогательных ключевых слов. Переменные образца соответствуют любой
    подструктуре и привязываются к этой подструктуре в соответствующем образце. Нотация ~pat ...~ в образце
    позволяет сопоставить ноль или более выражений в многоточии с прототипом ~pat~ во входных данных. Точно так же
    запись ~expr ...~ в шаблоне выдает ноль или более выражений, сопоставленных многоточием в прототипе ~expr~ в
    вывод. Количество ~pat~ на входе определяет количество ~expr~ на выходе; чтобы это работало, любой прототип
    многоточия в шаблоне должен содержать хотя бы одну переменную шаблона из прототипа многоточия в шиблоне.

    Единственное правило в нашем определении ~let~ должно быть достаточно самоочевидным, но стоит упомянуть несколько
    моментов. Во-первых, синтаксис ~let~ требует, чтобы тело содержало хотя бы одну форму; следовательно, мы указали ~b1
    b2 ...~ вместо ~b ...~, что может показаться более естественным. С другой стороны, ~let~ не требует, чтобы была хотя
    бы одна пара переменная/значение, поэтому мы могли просто использовать ~(x e) ...~. Во-вторых, переменные-образцы
    ~x~ и ~e~, хотя и вместе в одном прототипе в образце, разделены в шаблоне; возможна любая перестановка или
    рекомбинация. Наконец, три переменные образца ~x~, ~e~ и ~b2~, которые появляются в прототипах многоточия в образце,
    также появляются в прототипах многоточия в шаблоне. Это не совпадение; это требование. В общем случае, если
    переменная-образец появляется в прототипе многоточия в образце, она не может появляться вне прототипа многоточия в
    шаблоне.

    Определение ~and~ ниже несколько сложнее, чем определение для ~let~.

#+begin_src scheme
    (define-syntax and
      (syntax-rules ()
        [(_) #t]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (if e1 (and e2 e3 ...) #f)]))
#+end_src

    Это определение является рекурсивным и включает более одного правила. Напомним, что ~(and)~ возвращает ~#t~; первое
    правило заботится об этом случае. Второе и третье правила определяют базовый случай и шаг рекурсии и вместе
    переводят ~and~ выражение с двумя или более подвыражениями во вложенные выражения ~if~. Например, ~(and a b c)~
    разворачивается сначала в

#+begin_src scheme
    (if a (and b c) #f)
#+end_src

    а потом в

#+begin_src scheme
    (if a (if b (and c) #f) #f)
#+end_src

    и наконец в

#+begin_src scheme
    (if a (if b c #f) #f)
#+end_src

    При таком раскрытии, если ~a~ и ~b~ возвращают истинну, тогда результатом является значение ~c~, в противном случае
    ~#f~, что и требовалось.

    Версия ~and~ ниже проще, но, к сожалению, неверна.

#+begin_src scheme
    (define-syntax and ; incorrect!
      (syntax-rules ()
        [(_) #t]
        [(_ e1 e2 ...)
         (if e1 (and e2 ...) #f)]))
#+end_src

    Выражение

#+begin_src scheme
    (and (not (= x 0)) (/ 1 x))
#+end_src

    должно вернуть значение ~(/ 1 х)~, когда ~х~ не ноль. При неверной версии ~and~ выражение раскрывается следующим
    образом.

#+begin_src scheme
    (if (not (= x 0)) (and (/ 1 x)) #f) →
    (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) →
    (if (not (= x 0)) (if (/ 1 x) #t #f) #f)
#+end_src

    Окончательный ответ, если ~x~ не ноль, это ~#t~, а не значение ~(/ 1 х)~.

    Определение ~or~ ниже аналогично определению ~and~, за исключением того, что для каждого промежуточного значения
    должна быть введена временная переменная, чтобы мы могли одновременно проверить значение и вернуть его, если оно
    является истинной. (Временная переменная не нужна для ~and~, поскольку существует только одно ложное значение,
    ~#f~).

#+begin_src scheme
    (define-syntax or
      (syntax-rules ()
        [(_) #f]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (let ([t e1])
           (if t t (or e2 e3 ...)))]))
#+end_src

    Как и переменные, связанные лямбда-выражением или ~let~, идентификаторы, введенные шаблоном, имеют лексическую
    область видимости, то есть видимы только в выражениях, введенных шаблоном. Таким образом, даже если одно из
    выражений ~e2 e3 ...~ содержит ссылку на ~t~, введенная привязка для ~t~ не "захватывает" эти ссылки. Обычно это
    достигается путем автоматического переименования введенных идентификаторов.

    Как и в случае с более простой версией ~and~ приведенной выше, более простая версия ~or~ ниже является
    неправильной.

#+begin_src scheme
    (define-syntax or ; incorrect!
      (syntax-rules ()
        [(_) #f]
        [(_ e1 e2 ...)
         (let ([t e1])
           (if t t (or e2 ...)))]))
#+end_src

    Однако причина более тонкая и является предметом упражнения 3.2.6.

**** Упражнение 3.1.1

     Запишите шаги, необходимые для раскрытия расширения

#+begin_src scheme
     (let ([x (memv 'a ls)])
       (and x (memv 'b x)))
#+end_src

    в базовые формы.

**** Упражнение 3.1.2

     Запишите шаги, необходимые для раскрытия расширения

#+begin_src scheme
     (or (memv x '(a b c)) (list x))
#+end_src

     в базовые формы.

**** Упражнение 3.1.3

     ~let*~ аналогичен ~let~, но выполняет связывания по порядку. Каждое из выражений в правой части находится в рамках
     области действия предыдущих привязок.

#+begin_src scheme
     (let* ([a 5] [b (+ a a)] [c (+ a b)])
       (list a b c)) → (5 10 15)
#+end_src

     ~let*~ может быть реализован как вложенные выражения ~let~. Например, вышеприведенное выражение ~let*~ эквивалентно
     вложенным выражениям ~let~ ниже.

#+begin_src scheme
     (let ([a 5])
       (let ([b (+ a a)])
         (let ([c (+ a b)])
           (list a b c)))) → (5 10 15)
#+end_src

     Определите ~let*~ с помощью ~define-syntax~.

**** Упражнение 3.1.4

     Как мы видели в разделе 2.9, допустимо опускать третье или альтернативное подвыражение выражения ~if~. Однако это
     часто приводит к путанице. Scheme предоставляет две синтаксические формы, ~when~ и ~unless~, которые могут
     использоваться вместо таких «одноруких» ~if~.

#+begin_src scheme
     (when test expr1 expr2 ...)
     (unless test expr1 expr2 ...)
#+end_src

     В обеих формах тест вычисляется первым. Для ~when~, если ~test~ возвращает истину, остальные формы выполняются
     последовательно, как если бы они были заключены в неявное выражение ~begin~. Если ~test~ возвращает ложь, остальные
     формы не выполняются, а результат неопределён. ~unless~ ведёт себя аналогично, за исключением того, что остальные
     формы выполняются только если тест оценивается как ложный.

#+begin_src scheme
     (let ([x 3])
       (unless (= x 0) (set! x (+ x 1)))
       (when (= x 4) (set! x (* x 2)))
       x) → 8
#+end_src

     Определите ~when~ как синтаксическое расширение в терминах ~if~ и ~begin~, и определите ~unless~, только в терминах
     ~when~.

*** Больше о рекурсии

    В разделе 2.8 мы увидели, как определять рекурсивные процедуры, используя определения верхнего уровня. До этого мы
    видели, как создавать локальные связывания для процедур с использованием ~let~. Естественно задаться вопросом, может
    ли ~let~-процедура быть рекурсивной. Ответ - нет, по крайней мере, не прямым способом. Если вы попытаетесь выполнить
    выражение

#+begin_src scheme
    (let ([sum (lambda (ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5)))
#+end_src

    это, вероятно, вызовет исключение с сообщением о том, что ~sum~ не определена. Это связано с тем, что переменная
    ~sum~ видна только в теле выражения ~let~, а не в лямбда-выражении, значение которого связано с ~sum~. Мы можем
    обойти эту проблему, передав процедуру ~sum~ себе самой следующим образом.

#+begin_src scheme
    (let ([sum (lambda (sum ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum sum (cdr ls)))))])
      (sum sum '(1 2 3 4 5))) → 15
#+end_src

    Это работает и является разумным решением, но есть более простой способ, используя ~letrec~. Как и ~let~,
    синтаксическая форма ~letrec~ включает в себя набор пар переменная-значение и последовательность выражений,
    называемых телом ~letrec~.

#+begin_src scheme
    (letrec ((var expr) ...) body1 body2 ...)
#+end_src

    В отличие от ~let~, переменные ~var ...~ видны не только внутри тела ~letrec~, но и внутри выражения ~expr
    ...~. Таким образом, мы можем переписать приведенное выше выражение следующим образом.

#+begin_src scheme
    (letrec ([sum (lambda (ls)
                    (if (null? ls)
                        0
                        (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5))) → 15
#+end_src

    Используя ~letrec~, мы также можем определить взаимно рекурсивные процедуры, такие как процедуры ~even?~ и ~odd?~,
    которые были предметом упражнения 2.8.6.

#+begin_src scheme
    (letrec ([even?
              (lambda (x)
                (or (= x 0)
                    (odd? (- x 1))))]
             [odd?
              (lambda (x)
                (and (not (= x 0))
                     (even? (- x 1))))])
      (list (even? 20) (odd? 20))) → (#t #f)
#+end_src

    В выражении ~letrec~ ~expr ...~ чаще всего является лямбда-выражением, хотя это не обязательно. Однако необходимо
    соблюдать одно ограничение для выражений. Должна быть возможность вычислять каждое выражение без вычисления
    какой-либо из переменных ~var ...~. Это ограничение всегда выполняется, если все выражения являются
    лямбда-выражениями, поскольку, хотя переменные могут появляться в лямбда-выражениях, они не могут быть вычислены до
    тех пор, пока результирующие процедуры не будут вызваны в теле ~letrec~. Следующее выражение ~letrec~ подчиняется
    этому ограничению.

#+begin_src scheme
    (letrec ([f (lambda () (+ x 2))]
             [x 1])
      (f)) → 3
#+end_src

    А это нет.

#+begin_src scheme
    (letrec ([y (+ x 2)]
             [x 1])
      y)
#+end_src

    В этом случае возникает исключение, указывающее, что ~x~ не определено там, где на него ссылаются.

    Мы можем использовать ~letrec~, чтобы скрыть определения «вспомогательных» процедур, чтобы они не загромождали
    пространство имен верхнего уровня. Это демонстрирует определение ~list?~ ниже, который следует алгоритму «заяц и
    черепаха», описанному в упражнении 2.9.8.

#+begin_src scheme
    (define list?
      (lambda (x)
        (letrec ([race
                  (lambda (h t)
                    (if (pair? h)
                        (let ([h (cdr h)])
                          (if (pair? h)
                              (and (not (eq? h t))
                                   (race (cdr h) (cdr t)))
                              (null? h)))
                        (null? h)))])
          (race x x))))
#+end_src

    Когда рекурсивная процедура вызывается только в одном месте вне процедуры, как в примере выше, часто проще
    использовать именованное выражение ~let~. Именованные ~let~ выражения принимают следующую форму.

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    Именованный ~let~ похож на безымянный ~let~ в том, что он связывает переменные ~var ...~ со значениями ~expr ...~ в
    теле ~body1 body2 ...~. Как и в случае безымянного ~let~, переменные видны только внутри тела, а не внутри ~expr
    ...~. В дополнение, переменная ~name~ внутри тела связана с процедурой, которая может быть вызвана для рекурсии;
    аргументы процедуры становятся новыми значениями переменных ~var ...~.

    Определение ~list?~ было переписано ниже для использования именнованного ~let~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (let race ([h x] [t x])
          (if (pair? h)
              (let ([h (cdr h)])
                (if (pair? h)
                    (and (not (eq? h t))
                         (race (cdr h) (cdr t)))
                    (null? h)))
              (null? h)))))
#+end_src

    Так же, как обычный ~let~ может быть представлен в виде простого применения лямбда-выражения к аргументам, так и
    именованный ~let~ может быть представлен как применение рекурсивной процедуры к аргументам. Форма именованного ~let~

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    может быть переписана в терминах ~letrec~ следующим образом.

#+begin_src scheme
    ((letrec ((name (lambda (var ...) body1 body2 ...)))
       name)
     expr ...)
#+end_src

    Или иначе это может быть переписано как

#+begin_src scheme
    (letrec ((name (lambda (var ...) body1 body2 ...)))
      (name expr ...))
#+end_src

    при условии, что переменная ~name~ не появляется свободно в ~expr ...~.

    Как мы обсуждали в разделе 2.8, некоторая рекурсия по сути является итерацией и выполняется как таковая. Когда вызов
    процедуры находится в хвостовой позиции (см. ниже) по отношению к лямбда-выражению, он считается хвостовым вызовом,
    и системы Scheme должны правильно обрабатывать его как ~"goto"~ или прыжок. Когда процедура вызывает себя хвостовым
    вызовом или вызывает себя косвенно через серию хвостовых вызовов, результатом является хвостовая рекурсия. Поскольку
    хвостовые вызовы обрабатываются как переходы, хвостовая рекурсия может использоваться для неограниченной итерации
    вместо более ограниченных итерационных конструкций, предоставляемых другими языками программирования, не опасаясь
    переполнения любого вида стека рекурсии.

    Вызов находится в хвостовой позиции по отношению к лямбда-выражению, если его результат возвращается непосредственно
    из лямбда-выражения, т.е. если после вызова ничего не остается делать, кроме как возвращаться из
    лямбда-выражения. Например, вызов находится в хвостовой позиции, если это последнее выражение в теле
    лямбда-выражения, последующая или альтернативная часть выражения ~if~ в хвостовой позиции, последнее подвыражение
    ~and~ или ~or~ в хвостовой позиции, последнее выражение в теле ~let~ или ~letrec~ в хвостовой позиции и т. д. Каждый
    из вызовов ~f~ в приведенных ниже выражениях является хвостовым вызовом, а вызовы ~g~ - нет.

#+begin_src scheme
    (lambda () (f (g)))
    (lambda () (if (g) (f) (f)))
    (lambda () (let ([x 4]) (f)))
    (lambda () (or (g) (f)))
#+end_src

    В каждом случае результат вызовов ~f~ возвращаются напрямую, тогда как вызовы ~g~ - нет.

    Рекурсия в общем и именованный ~let~ позволяет, в частности, обеспечить естественный способ реализации многих
    алгоритмов, будь то итеративный, рекурсивный или частично итеративный, или частично рекурсивный; программист не
    принуждён выбирать между двумя различными механизмами.

    Следующие два определения факториала используют именованные выражения ~let~ для вычисления факториала ~n!~ целого
    неотрицательного числа ~n~. Первый использует рекурсивное определение ~n! = n × (n - 1)!~, где ~0!~ определяется
    как 1.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n])
          (if (= i 0)
              1
              (* i (fact (- i 1)))))))

    (factorial 0) → 1
    (factorial 1) → 1
    (factorial 2) → 2
    (factorial 3) → 6
    (factorial 10) → 3628800
#+end_src

    Вторая - это итерационная версия, в которой используется итеративное определение ~n! = n × (n - 1) × (n - 2) × ... ×
    1~, использующая аккумулятор ~a~ для хранения промежуточных результатов.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n] [a 1])
          (if (= i 0)
              a
              (fact (- i 1) (* a i))))))
#+end_src

    Аналогичная проблема заключается в вычислении n-го числа Фибоначчи для данного ~n~. Числа Фибоначчи представляют
    собой бесконечную последовательность целых чисел 0, 1, 1, 2, 3, 5, 8 и т. д., в которой каждое число является суммой
    двух предыдущих чисел в последовательности. Процедура вычисления n-го числа Фибоначчи наиболее естественно
    определяется рекурсивно следующим образом.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (let fib ([i n])
          (cond
            [(= i 0) 0]
            [(= i 1) 1]
            [else (+ (fib (- i 1)) (fib (- i 2)))]))))

    (fibonacci 0) → 0
    (fibonacci 1) → 1
    (fibonacci 2) → 1
    (fibonacci 3) → 2
    (fibonacci 4) → 3
    (fibonacci 5) → 5
    (fibonacci 6) → 8
    (fibonacci 20) → 6765
    (fibonacci 30) → 832040
#+end_src

    Это решение требует вычисления двух предыдущих чисел Фибоначчи на каждом шаге и, следовательно, является дважды
    рекурсивным. Например, для вычисления ~(fibonacci 4)~ требуется вычисление обоих ~(fib 3)~ и ~(fib 2)~, для
    вычисления ~(fib 3)~ требуется вычисление как ~(fib 2)~ и ~(fib 1)~, так и для вычисления ~(fib 2)~ требуется
    вычисление как ~(fib 1)~, так и ~(fib 0)~. Это очень неэффективно и становится все более неэффективным с ростом
    ~n~. Более эффективное решение состоит в том, чтобы адаптировать решение с аккумулятором из приведенного выше
    примера факториала, чтобы использовать два аккумулятора, ~a1~ для текущего числа Фибоначчи и ~a2~ для предыдущего.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (if (= n 0)
            0
            (let fib ([i n] [a1 1] [a2 0])
              (if (= i 1)
                  a1
                  (fib (- i 1) (+ a1 a2) a1))))))
#+end_src

    Здесь ноль рассматривается как особый случай, так как предшествующего значения нет. Это позволяет нам использовать
    один базовый случай ~(= i 1)~. Время, необходимое для вычисления n-го числа Фибоначчи с использованием этого
    итеративного решения, растет линейно с ростом ~n~, что существенно лучше по сравнению с дважды рекурсивной
    версией. Чтобы почувствовать разницу, попробуйте вычислить ~(fibonacci 35)~ и ~(fibonacci 40)~, используя оба
    определения, чтобы увидеть, сколько времени занимает каждое из них.

    Мы также можем почувствовать разницу, взглянув на трассировку для каждого на небольших входных данных. Первая
    трассировка ниже показывает вызовы ~fib~ в версии ~fibonacci~ без хвостовой рекурсии, со входом 5.

#+BEGIN_EXAMPLE
    |(fib 5)
    | (fib 4)
    | |(fib 3)
    | | (fib 2)
    | | |(fib 1)
    | | |1
    | | |(fib 0)
    | | |0
    | | 1
    | | (fib 1)
    | | 1
    | |2
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | 3
    | (fib 3)
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | |(fib 1)
    | |1
    | 2
    |5
#+END_EXAMPLE

    Обратите внимание, что есть несколько вызовов ~fib~ с аргументами 2, 1 и 0. Вторая трассировка показывает вызовы
    ~fib~ в хвостовой рекурсивной версии, опять же с 5 на входе.

#+BEGIN_EXAMPLE
    |(fib 5 1 0)
    |(fib 4 1 1)
    |(fib 3 2 1)
    |(fib 2 3 2)
    |(fib 1 5 3)
    |5
#+END_EXAMPLE

    Очевидно, что есть большая разница.

    Примеры с именованным ~let~, показанные до сих пор, были либо хвост-рекурсивными, либо не хвост-рекурсивными. Часто
    случается, что один рекурсивный вызов в одном и том же выражении является хвостово-рекурсивным, а другом -
    нет. Определение ~factor~ ниже вычисляет простые множители его неотрицательного целочисленного аргумента. Первый
    вызов ~f~ не хвост-рекурсивный, но второй - да.

#+begin_src scheme
    (define factor
      (lambda (n)
        (let f ([n n] [i 2])
          (cond
            [(>= i n) (list n)]
            [(integer? (/ n i))
             (cons i (f (/ n i) i))]
            [else (f n (+ i 1))]))))
#+end_src

#+begin_src scheme
    (factor 0) → (0)
    (factor 1) → (1)
    (factor 12) → (2 2 3)
    (factor 3628800) → (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
    (factor 9239) → (9239)
#+end_src

    Трассировка вызовов ~f~, произведенная в Chez Scheme путем замены ~let~ на ~trace-let~, при выполнении ~(factor
    120)~ ниже подчеркивает разницу между нехвостыми и хвостовыми вызовами.

#+BEGIN_EXAMPLE
    |(f 120 2)
    | (f 60 2)
    | |(f 30 2)
    | | (f 15 2)
    | | (f 15 3)
    | | |(f 5 3)
    | | |(f 5 4)
    | | |(f 5 5)
    | | |(5)
    | | (3 5)
    | |(2 3 5)
    | (2 2 3 5)
    |(2 2 2 3 5)
#+END_EXAMPLE

    Нехвостовой вызов ~f~ отображается с отступом относительно уровня, на котором его вызвали, поскольку вызывающий все
    еще активен, тогда как хвостовые вызовы отображаются на том же уровне отступа.

**** Упражнение 3.2.1

     Какие из рекурсивных процедур, определенных в разделе 3.2, являются хвостово-рекурсивными, а какие нет?

**** Упражнение 3.2.2

     Перепишите ~factor~, используя ~letrec~, чтобы связать ~f~ вместо именованного ~let~. Какую версию вы предпочитаете?

**** Упражнение 3.2.3

     Можно ли переписать приведенное ниже выражение ~letrec~, используя именованный ~let~? Если нет, то почему? Если да,
     то сделайте это.

#+begin_src scheme
     (letrec ([even?
               (lambda (x)
                 (or (= x 0)
                     (odd? (- x 1))))]
              [odd?
               (lambda (x)
                 (and (not (= x 0))
                      (even? (- x 1))))])
       (even? 20))
#+end_src

**** Упражнение 3.2.4

     Перепишите оба определения ~fibonacci~, приведенные в этом разделе, чтобы подсчитать количество рекурсивных вызовов
     ~fib~, используя счетчик, аналогичный тому, который использовался в примере с ~cons-count~ в разделе
     2.9. Подсчитайте количество рекурсивных вызовов, сделанных в каждом случае для различных входных значений. Что вы
     заметили?

**** Упражнение 3.2.5

     Дополните определение ~let~, данное в Разделе 3.1, для обработки именованных ~let~ и ~let~ без имен, используя два
     правила.

**** Упражнение 3.2.6

     Следующее определение ~or~ проще, чем приведенное в разделе 3.1.

#+begin_src scheme
     (define-syntax or ; incorrect!
       (syntax-rules ()
         [(_) #f]
         [(_ e1 e2 ...)
          (let ([t e1])
            (if t t (or e2 ...)))]))
#+end_src

     Поясните, почему это не правильно. [Подсказка: подумайте, что бы произошло, если бы эта версия или использовалась в
     ~even?~ и ~odd?~ для особенно больших значений на входе?]

**** Упражнение 3.2.7

     Определение ~factor~ не является наиболее эффективным из возможных. Во-первых, никакие множители ~n~, кроме самого
     ~n~, невозможно найти за пределами значения корня из ~n~. Во-вторых, деление ~(/ n i)~ выполняется дважды, когда
     множитель найден. В-третьих, после 2, никаких чётных множителей найдено быть не может. Перепишите ~factor~, чтобы
     исправить все три проблемы. Какая из этих проблем самая важная? Есть ли дополнительные улучшения, которые вы можете
     сделать?

*** Продолжения

    Во время выполнения выражения Scheme, реализация должна отслеживать две вещи: (1) что выполнять и (2) что делать со
    значением. Рассмотрим выполнение ~(null? x)~ в выражении ниже.

#+begin_src scheme
    (if (null? x) (quote ()) (cdr x))
#+end_src

    Реализация должна сначала выполнить ~(null? x)~ и, основываясь на его значении, выполнить либо ~(quote ())~, либо
    ~(cdr x)~. "Что выполнять" - это ~(null? x)~, а "что делать со значением" - это принимать решение, какое из
    выражений, ~(quote ())~ или ~(cdr x)~ выполнить. Мы называем "что делать со значением" /продолжением/ вычисления.

    Таким образом, в любой точке во время вычисления любого выражения есть продолжение, готовое завершить или, по
    крайней мере, продолжить вычисление с этой точки. Предположим, что ~x~ имеет значение ~(a b c)~. Мы можем выделить
    шесть продолжений во время выполнения ~(если (null? X) (quote ()) (cdr x))~, продолжения ожидают

    1. значение ~(if (null? x) (quote ()) (cdr x))~,
    2. значение ~(null? х)~,
    3. значение ~null?~,
    4. значение ~х~,
    5. значение ~cdr~, и
    6. значение ~х~ (снова).

    Продолжение ~(cdr x)~ не указано в списке, поскольку оно совпадает с продолжением ~(if (null? X) (quote ()) (cdr
    x))~.

    Scheme позволяет фиксировать продолжение любого выражения с помощью процедуры ~call/cc~. ~call/cc~ должна быть
    передана процедура ~p~ с одним аргументом. ~call/cc~ создает конкретное представление текущего продолжения и
    передает его в ~p~. Само продолжение представлено процедурой ~k~. Каждый раз, когда ~k~ применяется к значению, оно
    возвращает значение в продолжение от вызова ~call/cc~. Это значение становится, по сути, значением вызова ~call/cc~
    (результатом).

    Если ~p~ возвращается без вызова ~k~, значение, возвращаемое процедурой, становится значением приложения ~call/cc~.

    Рассмотрим простые примеры ниже.

#+begin_src scheme
    (call/cc
      (lambda (k)
        (* 5 4))) → 20

    (call/cc
      (lambda (k)
        (* 5 (k 4)))) → 4

    (+ 2
       (call/cc
         (lambda (k)
           (* 5 (k 4))))) → 6
#+end_src

    В первом примере продолжение захватывается и связывается с ~k~, но ~k~ никогда не используется, поэтому результатом
    является просто произведением 5 и 4. Во втором, продолжение вызывается перед умножением, поэтому результатом
    является значение, переданное в продолжение, 4. В третьем продолжение дополнено сложением с 2; таким образом,
    результат - это значение, переданное продолжению 4 плюс 2.

    Вот менее тривиальный пример, показывающий использование ~call/cc~ для обеспечения нелокального выхода из рекурсии.

#+begin_src scheme
    (define product
      (lambda (ls)
        (call/cc
          (lambda (break)
            (let f ([ls ls])
              (cond
                [(null? ls) 1]
                [(= (car ls) 0) (break 0)]
                [else (* (car ls) (f (cdr ls)))]))))))

    (product '(1 2 3 4 5)) → 120
    (product '(7 3 8 0 1 9 5)) → 0
#+end_src

    Нелокальный выход позволяет ~product~ возвращать результат немедленно, без выполнения остальных умножений, при
    обнаружении нулевого значения.

    Каждый из приведенных выше вызовов продолжения возвращается к продолжению, в то время как управление остается в
    пределах процедуры, переданной в ~call/cc~. В следующем примере используется продолжение после того, как эта
    процедура уже вернула значение.

#+begin_src scheme
    (let ([x (call/cc (lambda (k) k))])
      (x (lambda (ignore) "hi"))) → "hi"
#+end_src

    Продолжение, захваченное этим вызовом ~call/cc~, может быть описано как "возьмите значение, свяжите его с ~x~ и
    примени значение ~x~ к значению ~(lambda (ignore) "hi")~". Поскольку ~(lambda (k) k)~ возвращает свой аргумент, ~x~
    связан с самим продолжением; это продолжение применяется к процедуре, полученной в результате выполнения ~(lambda
    (ignore) "hi")~ . Это имеет эффект привязки ~x~ (снова!) к этой процедуре и применения процедуры к себе. Процедура
    игнорирует свой аргумент и возвращает "hi".

    Следующий вариант приведенного выше примера, вероятно, является самой запутанной программой Scheme своего размера;
    может быть легко догадаться, что он возвращает, но нужно подумать, почему.

#+begin_src scheme
    (((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") → "HEY!"
#+end_src

    Значение ~call/cc~ является его собственным продолжением, как в предыдущем примере. Это применяется к процедуре
    возвращающей свой аргумент ~(lambda (x) x)~, поэтому ~call/cc~ возвращается второй раз с этим значением. Затем
    процедура, возвращающая свой аргумент, применяется к себе, возвращая процедуру, возвращающую свой аргумент. Наконец,
    это применяется к "HEY!", В результате получается "HEY!".

    Продолжения, используемые таким образом, не всегда так озадачивают. Рассмотрим следующее определение факториала,
    которое сохраняет продолжение в основе рекурсии перед возвратом 1, присваивая его переменной верхнего уровня
    ~retry~.

#+begin_src scheme
    (define retry #f)

    (define factorial
      (lambda (x)
        (if (= x 0)
            (call/cc (lambda (k) (set! retry k) 1))
            (* x (factorial (- x 1))))))
#+end_src

    С этим определением ~factorial~ работает так, как мы ожидаем от факториала, за исключением того, что он имеет
    побочный эффект назначения повторных попыток.

#+begin_src scheme
    (factorial 4) → 24
    (retry 1) → 24
    (retry 2) → 48
#+end_src

    Продолжение, связанное с ~retry~, может быть описано как «Умножьте значение на 1, затем умножьте этот результат на
    2, затем умножьте этот результат на 3, а затем умножьте этот результат на 4». Если мы передадим продолжению другое
    значение, т. е. не 1, мы заставим базовое значение отличаться от 1 и, следовательно, изменим конечный результат.

#+begin_src scheme
    (retry 2) → 48
    (retry 5) → 120
#+end_src

    Этот механизм может быть основой для пакета точек останова, реализованного с помощью ~call/cc~; каждый раз, когда
    встречается точка останова, продолжение точки останова сохраняется, так что вычисление может быть перезапущено с
    точки останова (более одного раза, если это необходимо).

    Продолжения могут быть использованы для реализации различных форм многозадачности. Простой механизм «облегченного
    процесса», определенный ниже, позволяет чередовать несколько вычислений. Поскольку он не является вытесняющим, он
    требует, чтобы каждый процесс время от времени добровольно «приостанавливался», чтобы другие могли работать.

#+begin_src scheme
    (define lwp-list '())
    (define lwp
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))

    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))

    (define pause
      (lambda ()
        (call/cc
          (lambda (k)
            (lwp (lambda () (k #f)))
            (start)))))
#+end_src

    Следующие легкие процессы взаимодействуют, чтобы напечатать бесконечную последовательность строк, содержащих "hey!".

#+begin_src scheme
    (lwp (lambda () (let f () (pause) (display "h") (f))))
    (lwp (lambda () (let f () (pause) (display "e") (f))))
    (lwp (lambda () (let f () (pause) (display "y") (f))))
    (lwp (lambda () (let f () (pause) (display "!") (f))))
    (lwp (lambda () (let f () (pause) (newline) (f))))
    (start) → hey!
              hey!
              hey!
              hey!
              ...
#+end_src

    См. Раздел 12.11 для реализации механизмов, которые поддерживают вытесняющую многозадачность, с ~call/cc~.

**** Упражнение 3.3.1

     Используйте ~call/cc~, чтобы написать программу, которая зацикливается бесконечно, печатая последовательность
     чисел, начинающуюся с нуля. Не используйте никаких рекурсивных процедур и не используйте никаких присвоений.

**** Упражнение 3.3.2

     Перепишите ~product~ без ~call/cc~, сохранив функцию, при которой лишнее умножения не выполняются, если любой из
     элементов списка равен нулю.

**** Упражнение 3.3.3

     Что произойдет, если процесс, созданный ~lwp~, как определено выше, завершится, то есть просто вернет значение без
     вызова ~pause~? Определите процедуру выхода, которая позволяет завершать процесс, не влияя иначе на систему ~lwp~.
     Обязательно разберитесь со случаем, когда единственный оставшийся процесс завершается.

**** Упражнение 3.3.4

     Каждый раз, когда вызывается ~lwp~, список процессов копируется, потому что ~lwp~ использует ~append~ для
     добавления своего аргумента в конец списка процессов. Измените исходный код ~lwp~, чтобы использовать тип данных
     очереди, разработанный в разделе 2.9, чтобы избежать этой проблемы.

**** Упражнение 3.3.5

     Механизм облегченных процессов позволяет создавать новые процессы динамически, хотя пример, приведенный в этом
     разделе, этого не делает. Придумайте приложение, которое требует динамического создания новых процессов, и
     реализцйте его, используя механизм облегченных процессов.

*** Стиль передачи продолжений

    Как мы уже говорили в предыдущем разделе, продолжение ожидает значения каждого выражения. В частности, продолжения
    связанные с каждым вызовом процедуры. Когда одна процедура вызывает другую посредством нехвостого вызова, вызываемая
    процедура получает неявное продолжение, которое отвечает за завершение того, что осталось от тела вызывающей
    процедуры, плюс возврат к продолжению вызывающей процедуры. Если вызов является хвостовым, вызываемая процедура
    просто получает продолжение вызывающей процедуры.

    Мы можем сделать продолжения явными, заключив "что делать" в явный процедурный аргумент, передаваемый при каждом
    вызове. Например, продолжение вызова ~f~ в

#+begin_src scheme
    (letrec ([f (lambda (x) (cons 'a x))]
             [g (lambda (x) (cons 'b (f x)))]
             [h (lambda (x) (g (cons 'c x)))])
      (cons 'd (h '()))) → (d b a c)
#+end_src

    помещает символ ~b~ в возвращаемое ему значение, а затем возвращает результат этих объединений в продолжение вызова
    ~g~. Это продолжение аналогично продолжению вызова ~h~, который помещает символ ~d~ в возвращаемое ему значение. Мы
    можем переписать это в стиле передачи продолжения, или /CPS/ (англ. continuation-passing style, стиль передачи
    продолжений), заменив эти неявные продолжения явными процедурами.

#+begin_src scheme
    (letrec ([f (lambda (x k) (k (cons 'a x)))]
             [g (lambda (x k)
                  (f x (lambda (v) (k (cons 'b v)))))]
             [h (lambda (x k) (g (cons 'c x) k))])
      (h '() (lambda (v) (cons 'd v))))
#+end_src

    Как и неявное продолжение ~h~ и ~g~ в предыдущем примере, явное продолжение передается в ~h~ и ~g~,

#+begin_src scheme
    (lambda (v) (cons 'd v))
#+end_src

    добавляет символ ~d~ в значение, переданное ему. Аналогично, продолжение переданное ~f~,

#+begin_src scheme
    (lambda (v) (k (cons 'b v)))
#+end_src

    добавляет ~b~ в переданное ему значение, а затем передает это в продолжение ~g~.

    Выражения, написанные на CPS, конечно, сложнее, но у этого стиля программирования есть несколько полезных
    приложений. CPS позволяет процедуре передать более одного результата своему продолжению, поскольку процедура,
    реализующая продолжение, может принимать любое количество аргументов.

#+begin_src scheme
    (define car&cdr
      (lambda (p k)
        (k (car p) (cdr p))))

    (car&cdr '(a b c)
      (lambda (x y)
        (list y x))) → ((b c) a)
    (car&cdr '(a b c) cons) → (a b c)
    (car&cdr '(a b c a d) memv) → (a d)
#+end_src

    (Это также может быть сделано с несколькими значениями; см. Раздел 5.8.) CPS также позволяет процедуре принимать
    отдельные продолжения "успех" и "неудача", которые могут принимать различное количество аргументов. Примером
    является целочисленное деление ниже, которое передает частное и остаток первых двух аргументов своему третьему, если
    только второй аргумент (делитель) не равен нулю, и в этом случае он передает сообщение об ошибке своему четвертому
    аргументу.

#+begin_src scheme
    (define integer-divide
      (lambda (x y success failure)
        (if (= y 0)
            (failure "divide by zero")
            (let ([q (quotient x y)])
              (success q (- x (* q y)))))))

    (integer-divide 10 3 list (lambda (x) x)) → (3 1)
    (integer-divide 10 0 list (lambda (x) x)) → "divide by zero"
#+end_src

    Процедура ~quotient~, используемая в ~integer-divide~, возвращает частное от двух его аргументов, усеченных до нуля.

    Явные продолжения для успеха и неудачи иногда могут помочь избежать дополнительной коммуникации, необходимой для
    отделения успешного выполнения процедуры от неудачного выполнения. Кроме того, возможно иметь несколько успешных или
    неудачных продолжений для разных разновидностей успеха или неудачи, каждый из которых может принимать разное число и
    тип аргументов. См. разделы 12.10 и 12.11 для расширенных примеров, которые используют стиль передачи продолжения.

    В этот момент вы можете задаться вопросом о связи между CPS и продолжениями, записанными через
    ~call/cc~. Оказывается, что любая программа, использующая ~call/cc~, может быть переписана в CPS без ~call/cc~, но
    может потребоваться полное переписывание программы (иногда даже с учетом системных примитивов). Попробуйте
    преобразовать пример ~product~ из главы 3.3 в CPS, прежде чем смотреть на версию ниже.

#+begin_src scheme
    (define product
      (lambda (ls k)
        (let ([break k])
          (let f ([ls ls] [k k])
            (cond
              [(null? ls) (k 1)]
              [(= (car ls) 0) (break 0)]
              [else (f (cdr ls)
                       (lambda (x)
                         (k (* (car ls) x))))])))))

    (product '(1 2 3 4 5) (lambda (x) x)) → 120
    (product '(7 3 8 0 1 9 5) (lambda (x) x)) → 0
#+end_src

**** Упражнение 3.4.1

     Перепишите пример ~reciprocal~, впервые приведенный в Разделе 2.1, чтобы принимать как успешные, так и неудачные
     продолжения, как это сделано в ~integer-divide~ выше.

**** Упражнение 3.4.2

     Перепишите пример с ~retry~ используя CPS.

**** Упражнение 3.4.3

     Перепишите следующее выражение в CPS, чтобы избежать использования ~call/cc~.

#+begin_src scheme
     (define reciprocals
       (lambda (ls)
         (call/cc
           (lambda (k)
             (map (lambda (x)
                    (if (= x 0)
                        (k "zero found")
                        (/ 1 x)))
                  ls)))))

     (reciprocals '(2 1/3 5 1/4)) → (1/2 3 1/5 4)
     (reciprocals '(2 1/3 0 5 1/4)) → "zero found"
#+end_src

*** Внутренние объявления

    В разделе 2.6 мы обсудили определения верхнего уровня. Определения могут также появляться в начале тела
    лямбда-выражения, ~let~ или ~letrec~, и в этом случае создаваемые ими привязки являются локальными для тела.

#+begin_src scheme
    (define f (lambda (x) (* x x)))
    (let ([x 3])
      (define f (lambda (y) (+ y x)))
      (f 4)) → 7
    (f 4) → 16
#+end_src

    Процедуры, связанные внутренними определениями, могут быть взаимно рекурсивными, как с ~letrec~. Например, мы можем
    переписать ~even?~ и ~odd?~ из примера из раздела 3.2 с использованием внутренних определений следующим образом.

#+begin_src scheme
    (let ()
      (define even?
        (lambda (x)
          (or (= x 0)
              (odd? (- x 1)))))
      (define odd?
        (lambda (x)
          (and (not (= x 0))
               (even? (- x 1)))))
      (even? 20)) → #t
#+end_src

    Точно так же мы можем заменить использование ~letrec~ для связывания ~race~ внутренним определением ~race~ в нашем
    первом определении ~list?~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (define race
          (lambda (h t)
            (if (pair? h)
                (let ([h (cdr h)])
                  (if (pair? h)
                      (and (not (eq? h t))
                           (race (cdr h) (cdr t)))
                      (null? h)))
                (null? h))))
        (race x x)))
#+end_src

    Фактически, внутреннее определение переменных и ~letrec~ практически взаимозаменяемы. Единственная разница, кроме
    очевидной разницы в синтаксисе, состоит в том, что определения переменных гарантированно будут выполняться слева
    направо, а связывания ~letrec~ могут выполняться в любом порядке. Поэтому мы не можем полностью заменить тело
    лямбда-выражения, ~let~ или ~letrec~, содержащие внутренние определения, выражением ~letrec~. Однако мы можем
    использовать ~letrec*~, который, как и ~let*~, гарантирует порядок выполнения слева направо. Тело следующего вида

#+begin_src scheme
    (define var expr0)
    ...
    expr1
    expr2
    ...
#+end_src

    эквивалентно выражению ~letrec*~, связывающему определенные переменные со ассоциативными значениями в теле,
    содержащем выражения.

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    И наоборот, ~letrec*~ вида

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    может быть заменено выражением ~let~, содержащим внутренние определения и выражения из тела следующим образом.

#+begin_src scheme
    (let ()
      (define var expr0)
      ...
      expr1
      expr2
      ...
    )
#+end_src

    Кажущееся отсутствие симметрии между этими преобразованиями связано с тем, что выражения ~letrec*~ могут появляться
    везде, где выражение допустимо, тогда как внутренние определения могут появляться только в начале тела. Таким
    образом, заменяя ~letrec*~ внутренними определениями, мы обычно должны вводить выражение ~let~ для хранения
    определений.

    Другое различие между внутренними определениями и ~letrec~ или ~letrec*~ заключается в том, что синтаксические
    определения могут появляться среди внутренних определений, тогда как ~letrec~ и ~letrec*~ связывают только
    переменные.

#+begin_src scheme
    (let ([x 3])
      (define-syntax set-x!
        (syntax-rules ()
          [(_ e) (set! x e)]))
      (set-x! (+ x x))
      x) → 6
#+end_src

    Область действия синтаксического расширения, созданного внутренним определением синтаксиса, так же как и область
    определения внутренней переменной, ограничены телом, в котором появляется определение.

    Внутренние определения могут использоваться вместе с определениями и назначениями верхнего уровня, что помогает
    разбивать программаму на модули. Каждый модуль программы должен делать видимыми только те привязки, которые нужны
    другим модулям, в то же время скрывая другие привязки, которые в противном случае загромождают пространство имен
    верхнего уровня и, возможно, приводят к непреднамеренному использованию или переопределению этих привязок. Общий
    способ структурирования модуля показан ниже.

#+begin_src scheme
    (define export-var #f)
     ...
    (let ()
      (define var expr)
       ...
      init-expr
       ...
      (set! export-var export-val)
       ...
    )
#+end_src

    Первый набор определений устанавливает привязки верхнего уровня для переменных, которые мы хотим экспортировать
    (сделать видимыми глобально). Второй набор определений устанавливает локальные привязки, видимые только внутри
    модуля. Выражения ~init-expr ...~ выполняют любую инициализацию, которая должна произойти после установления
    локальных связываний. Наконец ~set!~ выражения присваивают экспортируемым переменным соответствующие значения.

    Преимущество этой формы модульности заключается в том, что охватывающее выражение ~let~ может быть удалено или
    закомментировано во время разработки программы, что делает внутренние определения определениями верхнего уровня, для
    облегчения интерактивного тестирования. Эта форма модульности также имеет несколько недостатков, как мы обсудим в
    следующем разделе.

    Следующий модуль экспортирует одну переменную ~calc~, которая связана с процедурой, реализующей простой
    четырехфункциональный калькулятор.

#+begin_src scheme
    (define calc #f)
    (let ()
      (define do-calc
        (lambda (ek expr)
          (cond
            [(number? expr) expr]
            [(and (list? expr) (= (length expr) 3))
             (let ([op (car expr)] [args (cdr expr)])
               (case op
                 [(add) (apply-op ek + args)]
                 [(sub) (apply-op ek - args)]
                 [(mul) (apply-op ek * args)]
                 [(div) (apply-op ek / args)]
                 [else (complain ek "invalid operator" op)]))]
            [else (complain ek "invalid expression" expr)])))
      (define apply-op
        (lambda (ek op args)
          (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
      (define complain
        (lambda (ek msg expr)
          (ek (list msg expr))))
      (set! calc
        (lambda (expr)
          ; grab an error continuation ek
          (call/cc
            (lambda (ek)
              (do-calc ek expr))))))

    (calc '(add (mul 3 2) -4)) → 2
    (calc '(div 1/2 1/6)) → 3
    (calc '(add (mul 3 2) (div 4))) → ("invalid expression" (div 4))
    (calc '(mul (add 1 -2) (pow 2 7))) → ("invalid operator" pow)
#+end_src

    В этом примере используется выражение ~case~, чтобы определить, какой оператор применить. ~case~ аналогичен ~cond~,
    за исключением того, что тест всегда одинаков: ~(memv val (key ...))~, где ~val~ - значение первой подформы ~case~,
    а ~(key ...)~ - список элементов в начале каждого случая ~case~. Выражение ~case~ в приведенном выше примере можно
    переписать с помощью ~cond~ следующим образом.

#+begin_src scheme
    (let ([temp op])
      (cond
        [(memv temp '(add)) (apply-op ek + args)]
        [(memv temp '(sub)) (apply-op ek - args)]
        [(memv temp '(mul)) (apply-op ek * args)]
        [(memv temp '(div)) (apply-op ek / args)]
        [else (complain ek "invalid operator" op)]))
#+end_src

**** Упражнение 3.5.1

     Переопределите ~complain~ в примере ~calc~ как эквивалентное синтаксическое расширение.

**** Упражнение 3.5.2

     В примере ~calc~ продолжение ошибки ~ek~ передается при каждом вызове ~apply-op~, ~complain~ и
     ~do-calc~. Переместите определения ~apply-op~, ~complain~ и ~do-calc~ внутрь, насколько это необходимо, чтобы
     исключить аргумент ~ek~ из определений и применений этих процедур.

**** Упражнение 3.5.3

     Исключите ~call/cc~ из ~calc~ и перепишите ~complain~, чтобы вызвать исключение с использованием
     ~assertion-violation~.

**** Упражнение 3.5.4

     Расширьте ~calc~ для обработки унарных выражений ~minus~, например,

#+begin_src scheme
     (calc '(minus (add 2 3))) → -5
#+end_src

     и другие операторы на ваш выбор.

*** Libraries

    At the end of the preceding section, we discussed a form of modularization that involves assigning a set of top-level
    variables from within a let while keeping unpublished helpers local to the let. This form of modularization has
    several drawbacks:

    * It is unportable, because the behavior and even existence of an interactive top level is not guaranteed by the
      Revised6 Report.
    * It requires assignments, which make the code appear somewhat awkward and may inhibit compiler analyses and
      optimizations.
    * It does not support the publication of keyword bindings, since there is no analogue to set! for keywords.

    An alternative that does not share these drawbacks is to create a library. A library exports a set of identifiers,
    each defined within the library or imported from some other library. An exported identifier need not be bound as a
    variable; it may be bound as a keyword instead.

    The following library exports two identifiers: the variable gpa->grade and the keyword gpa. The variable gpa->grade
    is bound to a procedure that takes a grade-point average (GPA), represented as a number, and returns the
    corresponding letter grade, based on a four-point scale. The keyword gpa names a syntactic extension whose subforms
    must all be letter grades and whose value is the GPA computed from those letter grades.

#+begin_src scheme
    (library (grades)
      (export gpa->grade gpa)
      (import (rnrs))

      (define in-range?
        (lambda (x n y)
          (and (>= n x) (< n y))))

      (define-syntax range-case
        (syntax-rules (- else)
          [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...
               [else ee1 ee2 ...]))]
          [(_ expr ((x - y) e1 e2 ...) ...)
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...))]))

      (define letter->number
        (lambda (x)
          (case x
            [(a)  4.0]
            [(b)  3.0]
            [(c)  2.0]
            [(d)  1.0]
            [(f)  0.0]
            [else (assertion-violation 'grade "invalid letter grade" x)])))

      (define gpa->grade
        (lambda (x)
          (range-case x
            [(0.0 - 0.5) 'f]
            [(0.5 - 1.5) 'd]
            [(1.5 - 2.5) 'c]
            [(2.5 - 3.5) 'b]
            [else 'a])))

      (define-syntax gpa
        (syntax-rules ()
          [(_ g1 g2 ...)
           (let ([ls (map letter->number '(g1 g2 ...))])
             (/ (apply + ls) (length ls)))])))
#+end_src

    The name of the library is (grades). This may seem like a funny kind of name, but all library names are
    parenthesized. The library imports from the standard (rnrs) library, which contains most of the primitive and keyword
    bindings we have used in this chapter and the last, and everything we need to implement gpa->grade and gpa.

    Along with gpa->grade and gpa, several other syntactic extensions and procedures are defined within the library, but
    none of the others are exported. The ones that aren't exported are simply helpers for the ones that are. Everything
    used within the library should be familiar, except for the apply procedure, which is described on page 107.

    If your Scheme implementation supports import in the interactive top level, you can test the two exports as shown
    below.

#+begin_src scheme
    (import (grades))
    (gpa c a c b b) → 2.8
    (gpa->grade 2.8) → b
#+end_src

    Chapter 10 describes libraries in more detail and provides additional examples of their use.

**** Упражнение 3.6.1

     Modify gpa to handle "x" grades, which do not count in the grade-point average. Be careful to handle gracefully the
     situation where each grade is x.

#+begin_src scheme
     (import (grades))
     (gpa a x b c) → 3.0
#+end_src

**** Упражнение 3.6.2

     Export from (grades) a new syntactic form, distribution, that takes a set of grades, like gpa, but returns a list of
     the form ((n g) ...), where n is the number of times g appears in the set, with one entry for each g. Have
     distribution call an unexported procedure to do the actual work.

#+begin_src scheme
     (import (grades))
     (distribution a b a c c c a f b a) → ((4 a) (2 b) (3 c) (0 d) (1 f))
#+end_src

**** Упражнение 3.6.3

     Now read about output operations in Section 7.8 and define a new export, histogram, as a procedure that takes a
     textual output port and a distribution, such as might be produced by distribution, and prints a histogram in the
     style illustrated by the example below.

#+begin_src scheme
     (import (grades))
     (histogram
       (current-output-port)
       (distribution a b a c c a c a f b a))
#+end_src

     prints:

#+BEGIN_EXAMPLE
   a: *****
   b: **
   c: ***
   d:
   f: *
#+END_EXAMPLE


#+LATEX: \newpage
[[./images/ch4.png]]

** Procedures and Variable Bindings
*** Variable References
*** Lambda
*** Case-Lambda
*** Local Binding
*** Multiple Values
*** Variable Definitions
*** Assignment



#+LATEX: \newpage
[[./images/ch5.png]]

** Control Operations
*** Procedure Application
*** Sequencing
*** Conditionals
*** Recursion and Iteration
*** Mapping and Folding
*** Continuations
*** Delayed Evaluation
*** Multiple Values
*** Eval

#+LATEX: \newpage
[[./images/ch6.png]]

** Operations on Objects
*** Constants and Quotation
*** Generic Equivalence and Type Predicates
*** Lists and Pairs
*** Numbers
*** Fixnums
*** Flonums
*** Characters
*** Strings
*** Vectors
*** Bytevectors
*** Symbols
*** Booleans
*** Hashtables
*** Enumerations

#+LATEX: \newpage
[[./images/ch7.png]]

** Input and Output
*** Transcoders
*** Opening Files
*** Standard Ports
*** String and Bytevector Ports
*** Opening Custom Ports
*** Port Operations
*** Input Operations
*** Output Operations
*** Convenience I/O
*** Filesystem Operations
*** Bytevector/String Conversions

#+LATEX: \newpage
[[./images/ch8.png]]

** Syntactic Extension
*** Keyword Bindings
*** Syntax-Rules Transformers
*** Syntax-Case Transformers
*** Examples

#+LATEX: \newpage
[[./images/ch9.png]]

** Records
*** Defining Records
*** Procedural Interface
*** Inspection

#+LATEX: \newpage
[[./images/ch10.png]]

** Libraries and Top-Level Programs
*** Standard Libraries
*** Defining New Libraries
*** Top-Level Programs
*** Examples

#+LATEX: \newpage
[[./images/ch11.png]]

** Exceptions and Conditions
*** Raising and Handling Exceptions
*** Defining Condition Types
*** Standard Condition Types

#+LATEX: \newpage
[[./images/ch12.png]]

** Extended Examples
*** Matrix and Vector Multiplication
*** Sorting
*** A Set Constructor
*** Word Frequency Counting
*** Scheme Printer
*** Formatted Output
*** A Meta-Circular Interpreter for Scheme
*** Defining Abstract Objects
*** Fast Fourier Transform
*** A Unification Algorithm
*** Multitasking with Engines

#+LATEX: \newpage
** Ответы к заданиям

#+LATEX: \newpage
* Формальный синтаксис

#+LATEX: \newpage
* Таблица синтаксических форм

#+LATEX: \newpage
* Предметный указатель


#+LATEX: \newpage
* Footnotes

[fn:1] Michael Adams and R. Kent Dybvig. Efficient nondestructive equality checking for trees and graphs. In Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming, 179-188, September 2008.

[fn:2] J. Michael Ashley and R. Kent Dybvig. An efficient implementation of multiple return values in Scheme. In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, 140-149, June 1994.

[fn:3] Alan Bawden. Quasiquotation in lisp. In Partial Evaluation and Semantic-Based Program Manipulation, 88-99, 1999.

[fn:4] William Briggs and Van Emden Henson. The DFT: An Owner's Manual for the Discrete Fourier Transform. Society for Industrial and Applied Mathematics, Philadelphia, PA, 1995.

[fn:5] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, 108-116, May 1996.

[fn:6] William F. Clocksin and Christopher S. Mellish. Programming in Prolog, second edition. Springer-Verlag, Berlin, 1984.

[fn:7] Sam M. Daniel. Efficient recursive FFT implementation in Prolog. In Proceedings of the Second International Conference on the Practical Application of Prolog, 175-185, 1994.

[fn:8] Mark Davis. Unicode Standard Annex #29: Text boundaries, 2006. http://www.unicode.org/reports/tr29/.

[fn:9] R. Kent Dybvig. Chez Scheme User's Guide: Version 8. Cadence Research Systems, 2009. http://www.scheme.com/csug8/.

[fn:10] R. Kent Dybvig and Robert Hieb. Engines from continuations. Computer Languages, 14(2):109-123, 1989.

[fn:11] R. Kent Dybvig and Robert Hieb. A new approach to procedures with variable arity. Lisp and Symbolic Computation, 3(3):229-244, September 1990.

[fn:12] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295-326, 1993.

[fn:13] Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth edition. MIT Press, Cambridge, MA, 1996.

[fn:14] Daniel P. Friedman, Christopher T. Haynes, and Eugene E. Kohlbecker. Programming with continuations. In P. Pepper, editor, Program Transformation and Programming Environments, 263-274. Springer-Verlag, New York, 1984.

[fn:15] Christopher T. Haynes and Daniel P. Friedman. Abstracting timed preemption with engines. Computer Languages, 12(2):109-121, 1987.

[fn:16] Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. Obtaining coroutines with continuations. Computer Languages, 11(3/4):143-153, 1986.

[fn:17] Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of first-class continuations. In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, 66-77, June 1990.

[fn:18] IEEE Computer Society. IEEE Standard for the Scheme Programming Language, May 1991. IEEE Std 1178-1990.

[fn:19] Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language, second edition. Prentice Hall, Englewood Cliffs, NJ, 1988.

[fn:20] P. Leach, M. Mealling, and R. Salz. A Universally Unique IDentifier (UUID) URN namespace, July 2005. RFC 4122. http://www.ietf.org/rfc/rfc4122.txt.

[fn:21] Peter Naur et al. Revised report on the algorithmic language ALGOL 60. Communications of the ACM, 6(1):1-17, January 1963.

[fn:22] David A. Plaisted. Constructs for sets, quantifiers, and rewrite rules in Lisp. Technical Report UIUCDCS-R-84-1176, University of Illinois at Urbana-Champaign Department of Computer Science, June 1984.

[fn:23] J. A. Robinson. A machine-oriented logic based on the resolution principle. Journal of the ACM, 12(1):23-41, 1965.

[fn:24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme, September 2007. http://www.r6rs.org/.

[fn:25] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---non-normative appendices, September 2007. http://www.r6rs.org/.

[fn:26] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---standard libraries, September 2007. http://www.r6rs.org/.

[fn:27] Guy L. Steele Jr. Common Lisp, the Language, second edition. Digital Press, Bedford, Massachusetts, 1990.

[fn:28] Guy L. Steele Jr. and Gerald J. Sussman. The revised report on Scheme, a dialect of Lisp. MIT AI Memo 452, Massachusetts Institute of Technology, January 1978.

[fn:29] Gerald J. Sussman and Guy L. Steele Jr. Scheme: An interpreter for extended lambda calculus. Higher-Order and Symbolic Computation, 11(4):405-439, 1998. Reprinted from the AI Memo 349, MIT (1975), with a foreword.

[fn:30] The Unicode Consortium. The Unicode Standard, Version 5.0, fifth edition. Addison-Wesley Professional, Boston, MA, 2006.

[fn:31] Oscar Waddell, Dipanwita Sarkar, and R. Kent Dybvig. Fixing letrec: A faithful yet efficient implementation of Scheme's recursive binding construct. Higher-Order and Symbolic Computation, 18(3/4):299-326, 2005.

[fn:32] Mitchell Wand. Continuation-based multiprocessing. Higher-Order and Symbolic Computation, 12(3):285-299, 1999. Reprinted from the proceedings of the 1980 Lisp Conference, with a foreword.
