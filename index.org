# -*- org-image-actual-width: 'true; -*-
# -*- fill-column: 120; -*-
#+STARTUP: nofninline

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [11pt,fleqn, oneside]
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LANGUAGE: RU
#+OPTIONS: toc:nil title:nil
#+TITLE: Язык программирования Scheme, 4-е издание
#+AUTHOR: R. Kent Dybvig

#+NAME: cover
#+ATTR_ORG: :width 300
[[./images/cover.png]]

#+LATEX: \newpage
#+LATEX: \tableofcontents

#+LATEX: \newpage

* Предисловие

  Язык Scheme увидел свет в 1975 году, благодаря стараниям Джеральда Дж.Суссмана и Гая Л.Стили младшего [fn:28],[fn:29], и
  был первым диалектом лиспа, полностью поддерживающим лексические области видимости, процедуры первого класса, и
  продолжения. В первоначальном виде это был очень простой язык, предназначенный, главным образом, для исследований и
  обучения, поддерживающий только небольшой набор предопределённых синтаксических форм и процедур. Сейчас Scheme -
  полноправный язык общего назначения, хотя он до сих пор черпает свою силу из небольшого набора ключевых идей. Ранние
  реализации языка были основаны на интерпретации и не отличались производительностью, однако сейчас существуют реализации
  Scheme, которые могут похвастаться сложными компиляторами, генерирующими код на ровне с кодом, генерируемым лучшими
  оптимизирующими компиляторами низкоуровневых языков, таких как C и Fortran.

  Данная книга нацелена на то, чтобы предоставить введение в язык программирования Scheme, но не в программирование в
  целом. Ожидается, что читатель уже имеет некоторый опыт в программировании и владеет терминами, обычно применяемыми в
  программировании. Читателю, не имеющему представления о Scheme и Lisp, следует сначала обратиться к ~The Little
  Schemer~ [fn:13], чтобы познакомиться с обработкой списков и рекурсией. Новичкам в программировании следует обратиться к
  литературе для новичков.

  Scheme был стандартизован как формально, так и неформально. IEEE стандарт ~Scheme Programming Language~ [fn:18]
  описывает формальный ANSI/IEEE стандарт для Scheme, однако он датирован 1991 годом. Связанная серия докладов 'Отчёты по
  пересмотру алгоритмического языка Scheme' ('Revised Reports on the Algorithmic Language Scheme') документируют
  развивающийся неофициальный стандарт, поддерживаемый большинством реализаций языка. Текущая версия отчёта из этой
  серии - 'Revised6 Report on the Algorithmic Language Scheme' [fn:24] была опубликована в 2007 году.

  Данная книга рассматривает версию языка, описываемую шестой версией (Revised6) отчёта. Она не нацелена на то, чтобы
  заменить данный отчёт, а скорее, предоставить более понятное введение и предметный указатель для языка, с более
  подробными разъяснениями и примерами, большего нацеленного на пользователей языка, а не разработчиков компиляторов для
  него. Описание возможностей, присущих конкретной реализации, отсутствует.

  В частности, возможности, специфичные для авторских реализаций ~Chez Scheme~ и ~Petite Chez Scheme~ описаны отдельно в
  Chez Scheme User's Guide [fn:9]. С другой стороны, не одна книга по Scheme не будет полной без описания интерактивной
  оболочки, поскольку почти каждая реализация Scheme поддерживает интерактивное использование системы в той или иной
  форме, не смотря на то, что данное поведение не стандартизировано Revised6 отчётом. Таким образом, в главах 2 и 3
  предполагается, что у читателя имеется реализация Scheme, которая поддерживает интерактивную оболочку, причем поведение
  соответствует описанию среды верхнего уровня в предыдущих отчетах и стандарту IEEE/ANSI.

  В тексте книги вы найдёте большое количество примеров маленького и среднего размера, а также отдельную главу,
  посвященную рассмотрению нескольких больших примеров. Большинство из них показывают, как могут быть реализованы
  стандартные синтаксические формы и процедуры Scheme, остальные - реализацию полезных расширений. Все эти примеры могут
  быть набраны непосредственно с клавиатуры в рамках сессии интерактивной оболочке.

  Книга разбита на 12 основных глав, плюс приложения. Глава 1 рассматривает те свойства и возможности языка Scheme,
  которые делают его полезным и приятным в использовании. В этой главе так же описаны типографические и нотационные
  соглашения, применяемые в этой книге.

  Глава 2 это введение в программирование на Scheme для начинающий Scheme-программистов, которая проведёт читателя через
  серию примеров, начиная с простейших выражений Scheme и продолжая всё более сложными примерами. Каждая секция второй
  главы представляет читателю маленький набор связанных функций языка, а в конце каждой секции содержится набор упражнений
  для дальнейшей практики. Читатель извлечёт значительно больше пользы из главы, если параллельно с чтением, будет сидеть
  за клавиатурой и набирать примеры и упражнения.

  Глава 3 так же содержит введение, но покрывает более сложные функции и принципы языка. Упражнения из этой главы могут
  быть интересны даже тем читателям, которые уже имеют некоторый опыт в Scheme.

  Главаы с 4 по 11 представляют из себя справочную часть книги. Здесь представлена каждая примитивная процедура и
  синтаксическая форма Scheme, которые, в свою очередь, сгруппированы в короткие секции связанных процедур и форм. Глава 4
  описывает операции объявления и присвоения процедур и переменных. Глава 5 - операции управления ходом выполнения
  программы. Глава 6 - операции над объектами различных типов (в т.ч. списки, числа, строки). Глава 7 - операции
  ввода-вывода. Глава 8 - расширение синтаксиса. Глава 9 - объявление типа данных 'запись'(record). Глава 10 - библиотеки
  и высокоуровневые (top-level) программы. Глава 11 - выражения и продолжения.

  Глава 12 содержит коллекцию примеров процедур, библиотек и программ, каждая с коротким обзором, примеры их
  использования, их реализация с краткими пояснениями и ряд упражнений для дальнейшей самостоятельной работы. Каждая из
  этих программ демонстрирует определённый функционал, а вместе они описывают стиль программирования, принятый в Scheme.

  Вслед за главой 12 идут библиографические ссылки, ответы на некоторые упражнения, полное описание формального синтаксиса
  программ и данных Scheme, включающее полный перечень синтаксических форм и процедур, а так же предметный
  указатель. Полный перечень форм и процедур полезен прежде всего как первое место, куда может заглянуть программист,
  неуверенный в структуре синтаксической формы или ожидаемых примитивной процедурой аргументах. Номера страниц,
  представленные в перечне форм и процедур, а так же номера страниц, выделенные курсивом, в предметном указателе,
  указывают местоположение в тексте, где было приведено описание данной процедуры или формы.

  В виду того, что справочная часть книги содержит такие аспекты языка, которые небыли представлены во введении, а так же
  ряд интересных, коротких примеров, для большинства читателей будет полезнее прочесть большую часть материала, чтобы
  познакомиться поближе с каждой возможностью языка и как это реализуется на других языках. Глава 6 является довольно
  длинной, так что она может быть пропущена при первом прочтении - обращайтесь к ней по мере необходимости, когда увидите
  ссылки на неё в тексте.

  Онлайн версия книги доступна по адресу http://www.scheme.com/tspl/ (русский перевод доступен по адресу
  http://github.com/noobsenslaver/scheme_book/releases). В полном перечне форм и в предметном указателе так же указаны
  номера страниц для печатной версии книги, так что ими можно пользоваться для облегчения поиска обладателям печатных
  версий книги.

  Касаемо иллюстраций: обложка и иллюстрация в начале каждой главы это алгоритмические композиции фонов линий, созданные
  художником Жаном-Пьером Эбертом, основанные на идее, вдохновленной трудами Джона Кейджа. Фон каждой линии вычисляется
  путём сопоставления некоего количества сеток параллельных линий. Каждая сетка регулярна, но линии нет. Например, линии
  имеют разную длину, что образует неровные края. Их тон и толщина немного отличаются. Они могут быть похожи, но не
  равны. Они пересекают друг друга под неким углом. Когда это угол мал, возникает интерференция. Линии сначала погружаются
  в различные скалярные поля, которые возмущают их исходную прямую форму, а потом проецируются на плоскость бумаги. Маски
  вводят отверстия в некоторых слоях. Для иллюстрации обложки сетки окрашены в разные оттенки.

  Все эти изображения созданы одной программой на Scheme, которая принимает большинство решений на вероятностной
  основе. Художник контролирует только размер холста, соотношение сторон, общую палитру цветов и уровни вероятности и
  нечеткости. Задача художника состоит в том, чтобы ввести достаточно шансов в нужном месте, чтобы результаты были
  одновременно удивительными, интересными и удовлетворяли эстетическому чувству художника. Это игра неопределенности,
  хаоса и гармонии.

  Благодарности: Многие люди так или иначе способствовали подготовке одного или нескольких изданий этой книги, в том числе
  Брюс Смит, Евгений Кольбекер, Маттиас Феллесинен, Дэн Фридман, Брюс Дуба, Фил Дыбвиг, Гай Стил, Боб Хиб, Крис Хейнс,
  Дэйв Плайед, Джоан Карри, Фрэнк Сильберманн, Павел Кертис, Джон Уайт, Карл Бруггман, Сэм Даниэль, Оскар Уодделл , Майк
  Эшли, Джон Лалонд, Джон Цукерман, Джон Симмонс, Боб Приор, Боб Бургер и Азиз Гулум. Многие другие предложили небольшие
  исправления и предложения. Оскар Уодделл помог создать систему набора, используемую для форматирования печатных и
  онлайн-версий этой книги. Небольшое количество текста и примеров было заимствовано из ~Revised6 отчёта~ и адаптировано
  для данной книги, за что благодарю авторов этого отчёта и многих других, кто способствовал его написанию. И наконец,
  самую большую благодарность я выражаю моей жене Сьюзан Дыбвиг, в первую очередь за то, что она предложила написать эту
  книгу, а так же за её неоценимую помощь в создании и публикации этого и предыдущих изданий.

#+LATEX: \newpage
[[./images/ch1.png]]

** Введение.

   Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
   типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
   данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
   имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
   языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
   графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
   реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
   изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
   природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
   полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.

   Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
   Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
   между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
   'Revised Reports' для Scheme. Последний, 'Revised6 Report' [fn:24], акцентирует внимание на переносимости, вводя ряд
   стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.

   Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
   реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
   языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
   проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
   информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.

   Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
   и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.

   Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
   пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
   от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
   списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
   освобождения памяти.

   Независимо от представления, /все/ данные являются объектами первого класса. Все они хранятся независимо и могут
   свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
   образования новых объектов.

   Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
   выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
   остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.

   Scheme относится к языкам с /вызовом-по-значению/ , но для, по меньшей мере,  мутабельных объектов (объекты, которые
   могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
   сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
   что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
   процедуры.

   В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
   ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
   составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
   надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
   реализацию и увеличивая надёжность.

   Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
   любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
   переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
   формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
   предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
   процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
   Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.

   В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
   Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
   кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
   т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
   пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
   блоке могут /затенять/ связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
   котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
   лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
   поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
   компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
   с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
   определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
   пока программа не выполнится.

   В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
   локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена пределах
   другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет конца блока.
   В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может быть
   произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже когда
   внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо самого
   кодом, хранит в себе лексический контекст (окружение).

   Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
   такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
   другим объектом.

   Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
   процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
   становятся элегантнее или эффективнее. Особый вид рекурсии, называемый /хвостовая рекурсия/, используется для
   выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
   другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
   самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
   (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
   Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
   обычным набором итерационных конструкций.

   Scheme поддерживает определение произвольных управляющих структур с помощью /продолжений/ . /Продолжение/ , это
   процедура, которая заключает в себе остальную часть программы в заданной точке. /Продолжение/ может быть получено в
   любой момент во время выполнения программы. Так же, как и с другими процедурами, /продолжение/ является объектом
   первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
   продолжает выполнение с той точки, где это /продолжение/ было создано. /Продолжения/ позволяют реализовать сложные
   механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.

   Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
   написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
   существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
   высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
   реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
   процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
   выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
   языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
   выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
   синтаксических выражений и объявлений процедур.

   Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
   объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
   многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
   60 [fn:21]. Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
   структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
   лексической областью действия.

   Common Lisp [fn:27] и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
   другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
   процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
   с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
   объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
   объектов первого класса. И хотя Common Lisp не поддерживает /продолжения/ или требует правильного обращения с
   хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
   похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
   универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).

   Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
   используемых в этой книге.

*** Синтаксис

    Программы на Scheme состоят из ключевых слов, переменных, структурирующих форм, константных данных (числа, буквы,
    строки, цитируемые векторы, цитируемые списки, цитируемые символы и т.д.), пробелов и комментариев.

    Ключевые слова, переменные и символы собирательно именуются идентификаторами. Идентификаторы могут быть образованы из
    букв, чисел и некоторых специальных символов, включающих ~?~, ~!~, ~.~, ~+~, ~-~, ~*~, ~/~, ~<~, ~=~, ~>~, ~:~, ~$~,
    ~%~, ~^~, ~&~, ~_~, ~~~, и ~@~, так же ряда дополнительных символов из Unicode. Идентификаторы не могут начинаться со
    знака @, а так же со знаков, с которых может начинаться число, таких как ~+~, ~-~, ~.~, исключение ~-~ знаки ~+~, ~-~
    и некоторые другие, которые могут быть идентификаторами сами по себе, а так же идентификаторы, начинающиеся с
    ~->~. Например, ~hi~, ~Hello~, ~n~, ~x~, ~x3~, ~x+2~, и ~?$&*!!!~ - корректные идентификаторы. Идентификаторы
    отделяются пробелами, комментарием, скобками, фигурными скобками, двойными кавычками и знаком решётки. Разделитель,
    или любая другая буква Unicode, могут быть включены в любое место в имени идентификатора путём экранирования в виде
    ~\xsv~, где sv - скалярное значение символа в шестнадцатеричном представлении.

    На длину идентификаторов не накладывается никаких ограничений, программист использовать столько символов в имени,
    сколько посчитает нужным. Однако, длинные идентификаторы не заменят комментариев, в то же время, их частое
    использование может сделать код трудным для форматирования и чтения. Хорошее правило, это использовать короткие имена
    идентификаторов в тех случаях, когда область видимости идентификатора мала, и длинные тогда, когда область видимости
    велика.

    Идентификаторы могут содержать любую комбинацию символов верхнего или нижнего регистров, регистр учитывается т.е. два
    идентификатора считаются различными, даже если они отличаются только регистром. Например, ~abcde~, ~Abcde~, ~AbCdE~ и
    ~ABCDE~ - все различные идентификаторы. Это нововведение, по сравнению с предыдущими отчётами по стандарту языка.

    Структурированные формы и списки констант заключаются в скобки, например ~(a b c)~ или ~(* (- x 2) y)~. Пустой список
    записывается как ~()~. Другие парные наборы скобок, такие как ~[~ ~]~, могут быть использованы вместо круглых скобок
    и часто используются для выделения подвыражений определенных стандартных синтаксических форм для удобочитаемости, как
    в примерах в этой книге. Векторы записываются таким же образом, как и списки, за исключением того, что они начинаются
    с ~#(~ и заканчиваются ~)~, например ~#(это вектор содержащий символы)~. Байт-векторы записываются как
    последовательность беззнаковых байтов (обычные целочисленные значения в диапазоне от 0 до 255), заключенных в ~#vu8(~
    и ~)~, например ~#vu8(3 250 45 73)~.

    Строки заключаются в двойные кавычки, например "Это строка" . Буквы предваряются ~#\~, например ~#\a~. Когда речь
    идёт о строках или буквах - регистр имеет значение, так же как и в случае с идентификаторами. Числа могут быть
    записаны в виде целочисленного значения (integer), например ~-123~, рационального числа, например ~1/2~, числа с
    плавающей точкой или в научной форме, например ~1.3~ или ~1e23~, как комплексное число, в прямоугольной или полярной
    системах координат например ~1.3-2.7i~ или ~-1.2@73~. В случае чисел регистр не имеет значения. Булевы значения,
    представляющие ложь и истину, обозначаются ~#f~ и ~#t~ соответственно. В Scheme, условные выражения обычно считают
    ~#f~ ложью, а любой другой объект истиной, так что ~3~, ~0~, ~()~, "false" или ~nil~ - всё это считается истиной.

    Детальное описание синтаксиса каждого константного типа данных дано в отдельной секции в главе 6 и в формальном
    описании синтаксиса, приведённом в конце книги.

    Выражения в Scheme могут занимать несколько строк, для этого не требуются специальные терминирующие
    символы. Учитывая, что количество пробельных символов и переводов строки между выражениями не имеет синтаксического
    значения, эту возможность следует использовать, чтобы программы на Scheme были выровнены таким образом, чтобы
    правильно отображать структуру кода и делать его настолько читаемым, насколько это возможно. Комментарии могут быть
    размещены в каждой строке программы, между символом ~;~ и концом строки. Комментарий, поясняющий конкретное выражение
    Scheme, обычно размещается в предыдущей строке, с тем же уровнем отступа. Комментарии, поясняющие процедуру или
    группу процедур, обычно размещаются перед процедурой, без отступа.

    Так же поддерживаются следующие два вида комментариев: блочные и комментарии по данным (datum). Блочные комментарии
    обосабливаются парой ~#|~ и ~|~, и могут быть вложенными. Комментарии данных начинаются с префикса ~#;~ , за которым
    следует печатная версия объекта данных. Комментарии по данным обычно используются, чтобы закомментировать конкретное
    объявление или выражение. Например, ~(список из трёх #;(а не четырёх) элементов)~. Комментарии по данным могут так же
    быть вложенными, например ~#;#;(a)(b)~, но это не имеет какого то особого значения, в сравнении, если бы
    комментировался каждый элемент по отдельности.

    Некоторые значения в Scheme, такие как процедуры или порты, не имеют стандартизированного печатного представления и
    по этому не могут быть представлены константой при печати. В этой книге используется обозначение ~#<пояснение>~,
    когда мы хотим оказать возвращаемый результат какой либо операции, возвращающей одно из таких значений, например
    ~#<procedure>~ или ~#<port>~.

*** Соглашения в именовании

    Соглашения по именованию, принятые в Scheme, разработаны так, чтобы обеспечивать высокий уровень системности и
    регулярности. Ниже приведён список таких соглашений:

    + Имена предикатов заканчиваются символом вопроса (?). Предикаты, это процедуры, возвращающие истину или ложь, такие
      как ~eq?~, ~zero?~ и ~string=?~. Обычные для чисел операции сравнения, такие как ~=~, ~<~, ~>~, ~<=~, и ~>=~
      являются исключением из правил.
    + Предикаты типов, например ~pair?~, составляются из имени типа, в данном случае /pair/ и знака вопроса.
    + Имена большинства процедур предикатов для букв, строк и векторов начинаются с префикса ~char-~, ~string-~,
      ~vector-~, например ~string-append~. (Имена некоторых процедур для списков начинаются с ~list-~, но большинство
      нет)
    + Имена процедур, которые преобразуют объект одного типа в объект другого типа, записываются как ~type1->type2~,
      например ~vector->list~.
    + Имена процедур и синтаксических форм, производящих побочные эффекты, оканчиваются знаком восклицательного знака
      (~!~). Например ~set!~ и ~vector-set!~. Процедуры, производящие операции ввода-вывода, формально так же считаются
      процедурами с побочными эффектами, однако они попадают под исключение из правил.
    + Программистам следует следовать этим соглашениям по именованию там, где это возможно.

*** Типографические и нотационные соглашения

    Про стандартные процедуры или синтаксические формы, единственная цель которых выполнение побочных эффектов, сказано,
    что возвращаемый ими результат не определён. Это значит, что конкретная реализация свободна возвращать любое
    количество значений, каждое из которых может быть любым объектом Scheme. Не рассчитывайте на то, что эти возвращаемые
    значения одинаковы для всех реализаций, одинаковые для версий одной и той же реализации, или даже одинаковы между
    двумя вызовами одной и той же процедуры или синтаксической формы. Некоторые реализации Scheme используют специальные
    объекты для обозначения неопределённого значения. Печать этого объекта часто подавляется интерактивными системами
    Scheme, поэтому значения выражений, возвращающих неопределённые значения, не печатаются.

    В то время, как большинство стандартных процедур возвращает одно значение, язык поддерживает процедуры, которые
    возвращают ноль, одно, более одного, или переменное количество значений, используя механизм, описанный в главе
    5.8. Некоторые стандартные выражения могут вычисляться в множество значений, если одно из подвыражений вычисляется в
    множество значений т.е. когда вызывается процедура, возвращающая несколько значений. Когда такое случается, выражению
    предписано возвращать /значения/, а не /значение/ его подвыражения. То же касается стандартных процедур, принимающих
    аргументом функцию - им предписывается возвращать множественное значение в том случае, если процедура-аргумент,
    влияющая на результат, возвращает множественное значение.

    В этой книге используются слова 'должен' и 'следует', чтобы описать программные требования, такие как требование,
    чтобы передаваемый индекс был меньше, чем длина вектора, при вызове ~vector-ref~. Если использовано слово 'должен', это
    значит, что реализация будет отслеживать выполнение этих требований т.е. будет выброшено исключение, обычно с типом
    условия ~&assertion~. Если используется слово 'следует', исключение может быть выброшено, а может не быть, если нет -
    поведение программы не определено. Фраза 'нарушение синтаксиса' используется, чтобы описать ситуацию, когда программа
    сформирована неправильно. Нарушения синтаксиса обнаруживаются в основном при выполнении программы. Когда нарушение
    синтаксиса обнаружено, выбрасывается исключение типа ~&syntax~ и программа прекращает работу.

    Типографические соглашения, используемые в этой книге весьма просты. Все объекты напечатаны таким же образом, как они
    выглядели бы, если бы их набрали на клавиатуре. Это касается ключевых слов синтаксиса, переменных, константных
    объектов, выражений Scheme, и примеров программ. Выделение /курсивом/ используется для обозначения синтаксических
    переменных в пояснениях синтаксических форм, аргументов и процедур. Так же курсивом выделены технических термины,
    используемые впервые. Обычно, имена и синтаксические формы находятся в нижнем регистре, даже если они начинают новое
    предложение.  То же касается и синтаксических переменных, выделенных курсивом.

    В описании синтаксических форм и процедур, один или несколько прототипов шаблонов показывают синтаксическую форму или
    формы или корректное количество аргументов для применения процедуры. Ключевое слово или имя процедуры выделяются
    машинописным шрифтом, так же как и круглые скобки. Остальные части синтаксиса или аргументы выделяются курсивом,
    используя имя, обозначающее тип выражения или аргумента, ожидаемого синтаксической формой или процедурой. Окружности
    используются для обозначения нуля или более вхождений подвыражения или аргумента. Например, ~(or expr ...)~
    описывает синтаксическую форму ~or~, которая имеет ноль или более подвыражений, и ~(member obj list)~ описывает
    процедуру ~member~, которая ожидает два аргумента - объект и список.

    Нарушением синтаксиса считается случай, когда структура синтаксической формы не совпадает с её прототипом. Обычно,
    выбрасывается исключение типа ~&assertion~, если количество аргументов, переданных в стандартную процедуру не
    совпадает с тем, которое ожидается к получению. Исключение с типом условия ~&assertion~ также выбрасывается, если
    стандартная процедура получает аргумент, который не подразумевается в его названии, или не удовлетворяет другим
    критериям, указанным в описании процедуры. Например, прототип для ~vector-set!~ таков:

#+begin_src scheme
    (vector-set! vector n obj)
#+end_src

    и описание говорится, что ~n~ должен быть неотрицательным целым числом, строго меньшим, чем длина вектора. Таким
    образом, ~vector-set!~ должен получить три аргумента, первый из которых должен быть вектором, второй должен быть
    неотрицательным целым числом, меньше длины вектора, и третьим может быть любой объект Scheme. В противном случае,
    будет выброшено исключение с типом условий ~&assertion~.

    В большинстве случаев тип ожидаемого аргумента очевиден, как в случае в ~vector~, ~obj~ или ~binary-input-port~. В
    остальных же случаях, по большей части использующихся в описании числовых операций, используются сокращения, такие
    как /int/ для целочисленных, /exint/ (от exact integer) для строгого указания целочисленного типа и /fx/ для типа
    /fixnum/. Эти сокращения поясняются в начале разделов, где мы их впервые коснёмся.

#+LATEX: \newpage
[[./images/ch2.png]]

** Начало

   Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
   параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

   После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
   Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
   данных и управляющие конструкции.

*** Взаимодействие с интерактивной оболочкой Scheme

    Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
    разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
    "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
    или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
    выполнения на экран.

    Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
    выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
    работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
    и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
    в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
    реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
    качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
    программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
    для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
    образом, как если бы они были набраны на клавиатуре интерактивно.

    Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
    значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
    позволяет сконцентрироваться на написании программы.

    Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
    можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После ⇒ следует значение
    выражения, что следует читать как "имеет следующее значение". Знак ⇒ применим для определений и в тех случаях, когда
    значение выражения неопределено.

    Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
    потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
    строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
    выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
    она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

    Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
    будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
    набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
    значение вычисления любой константы - сама константа.

#+begin_src scheme
    "Hi Mom!" ⇒ "Hi Mom!"
#+end_src

    Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
    однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+begin_src scheme
    "hello" ⇒ "hello"
    42 ⇒ 42
    22/7 ⇒ 22/7
    3.141592653 ⇒ 3.141592653
    + ⇒ #<procedure>
    (+ 76 31) ⇒ 107
    (* -12 10) ⇒ -120
    '(a b c d) ⇒ (a b c d)
#+end_src

    Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
    одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
    попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
    ожидать её даже после окончания ввода.

    Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
    дождаться пояснений, найдя их далее в главе.

#+begin_src scheme
    (car '(a b c)) ⇒ a
    (cdr '(a b c)) ⇒ (b c)
    (cons 'a '(b c)) ⇒ (a b c)
    (cons (car '(a b c))
          (cdr '(d e f))) ⇒ (a e f)
#+end_src

    Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
    выражение по парным двойным кавычкам и скобкам.

    Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
    (define square
      (lambda (n)
        (* n n)))
#+end_src

    Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
    процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
    связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
    выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
    предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
    операций, вроде ~*~.

    Опробуем наш ~square~ в деле:

#+begin_src scheme
    (square 5) ⇒ 25
    (square -200) ⇒ 40000
    (square 0.5) ⇒ 0.25
    (square -1/2) ⇒ 1/4
#+end_src

    Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
    "reciprocal.ss."

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
    вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
    (load "reciprocal.ss")
#+end_src

    Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+begin_src scheme
    (reciprocal 10) ⇒ 1/10
    (reciprocal 1/10) ⇒ 10
    (reciprocal 0) ⇒ "oops!"
    (reciprocal (reciprocal 1/10)) ⇒ 1/10
#+end_src

*** Простейшие выражения

    Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
    списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
    примеров со строками и числами.

    Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
    ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+begin_src scheme
    123456789987654321 ⇒ 123456789987654321
    3/4 ⇒ 3/4
    2.718281828 ⇒ 2.718281828
    2.2+1.1i ⇒ 2.2+1.1i
#+end_src

    Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
    целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
    используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

    Scheme предстадоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
    поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
    обозначают применение процедуры к набору аргументов.

#+begin_src scheme
    (+ 1/2 1/2) ⇒ 1
    (- 1.5 1/2) ⇒ 1.0

    (* 3 1/2) ⇒ 3/2
    (/ 1.5 3/4) ⇒ 2.0
#+end_src

    Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
    процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
    постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
    относительно приоритета или ассоциативности операторов.

    Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
    образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
    формул.

#+begin_src scheme
    (+ (+ 2 2) (+ 2 2)) ⇒ 8
    (- 2 (* 4 1/3)) ⇒ 2/3
    (* 2 (* 2 (* 2 (* 2 2)))) ⇒ 32
    (/ (* 6/7 7/2) (- 4.5 1.5)) ⇒ 1.0
#+end_src

    Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
    мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
    лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

    Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
    содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
    является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
    обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
    не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
    строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
    элементов, каждый из которых это список из двух элементов.

    Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
    Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
    ~(procedure arg ...)~?

    В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
    применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
    Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
    потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
    список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
    применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+begin_src scheme
    (quote (1 2 3 4 5)) ⇒ (1 2 3 4 5)
    (quote ("да" "это" "всё" "ещё" "список")) ⇒ ("да" "это" "всё" "ещё" "список")
    (quote (+ 3 4)) ⇒ (+ 3 4)
#+end_src

    С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
    ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
    третьего.

    Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
    обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
    аббривеатурой для ~quote~.

#+begin_src scheme
    '(1 2 3 4) ⇒ (1 2 3 4)
    '((1 2) (3 4)) ⇒ ((1 2) (3 4))
    '(/ (* 2 -1) 3) ⇒ (/ (* 2 -1) 3)
#+end_src

    Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
    будет заключён в выражение ~quote~.

    Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
    принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
    процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
    принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

    Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+begin_src scheme
    (quote hello) ⇒ hello
#+end_src

    Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hellp~ как
    переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
    выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
    об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
    думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
    списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
    идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
    используются для представления переменных в описании символьных уравнений или программ, символы могут также
    использоваться, например, как слова в описании предложений естественного языка.

    Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
    символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
    написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
    в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
    самых значительных особенностей Scheme.

    Числа и строки также могут цитироваться:

#+begin_src scheme
    '2 ⇒ 2
    '2/3 ⇒ 2/3
    (quote "Hi Mom!") ⇒ "Hi Mom!"
#+end_src

    Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

    Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
    значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
    оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
    на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+begin_src scheme
    (car '(a b c)) ⇒ a
    (cdr '(a b c)) ⇒ (b c)
    (cdr '(a)) ⇒ ()

    (car (cdr '(a b c))) ⇒ b
    (cdr (cdr '(a b c))) ⇒ (c)

    (car '((a b) (c d))) ⇒ (a b)
    (cdr '((a b) (c d))) ⇒ ((c d))
#+end_src

    Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
    /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

    Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
    ~cons~ вернёт список.

#+begin_src scheme
    (cons 'a '()) ⇒ (a)
    (cons 'a '(b c)) ⇒ (a b c)
    (cons 'a (cons 'b (cons 'c '()))) ⇒ (a b c)
    (cons '(a b) '(c d)) ⇒ ((a b) c d)

    (car (cons 'a '(b c))) ⇒ a
    (cdr (cons 'a '(b c))) ⇒ (b c)
    (cons (car '(a b c))
          (cdr '(d e f))) ⇒ (a e f)
    (cons (car '(a b c))
          (cdr '(a b c))) ⇒ (a b c)
#+end_src

    "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
    путём добавления элемента в начало списка называется /consing/.

    Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
    пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
    следующая пара в последовательности.

#+ATTR_LATEX: :width 200px
[[./images/1.png]]

    /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
    /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
    /правильным/ становится любой список, /cdr/ которого /правильный/ список.

    Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
    списка.

#+begin_src scheme
    (cons 'a 'b) ⇒ (a . b)
    (cdr '(a . b)) ⇒ b
    (cons 'a '(b . c)) ⇒ (a b . c)
#+end_src

    Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
    чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
    /правильные/ списки без точек.

#+begin_src scheme
    '(a . (b . (c . ()))) ⇒ (a b c)
#+end_src

    Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
    строит /правильные/ списки.

#+begin_src scheme
    (list 'a 'b 'c) ⇒ (a b c)
    (list 'a) ⇒ (a)
    (list) ⇒ ()
#+end_src

    Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
    чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

**** Упражнение 2.2.1

     Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
     1. ~1.2 × (2 - 1/3) + -8.7~
     2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
     3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
     4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~

**** Упражнение 2.2.2

     Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
     возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.

**** Упражнение 2.2.3

     Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
     ответы:
     1. ~(cons 'car 'cdr)~
     2. ~(list 'this '(is silly))~
     3. ~(cons 'is '(this silly?))~
     4. ~(quote (+ 2 3))~
     5. ~(cons '+ '(2 3))~
     6. ~(car '(+ 2 3))~
     7. ~(cdr '(+ 2 3))~
     8. ~cons~
     9. ~(quote cons)~
     10. ~(quote (quote cons))~
     11. ~(car (quote (quote cons)))~
     12. ~(+ 2 3)~
     13. ~(+ '2 '3)~
     14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
     15. ~((car (list + - * /)) 2 3)~

**** Упражнение 2.2.4

     ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
     которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.

**** Упражнение 2.2.5

     Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:

#+ATTR_LATEX: :width 200px
[[./images/2.png]]

**** Упражнение 2.2.6

     Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
     ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~

**** Упражнение 2.2.7

     Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
     b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
     выражения ~((a b) (c d))~.

**** Упражнение 2.2.8

     Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
     объяснение?

*** Выполнение Scheme выражений

    Let's turn to a discussion of how Scheme evaluates the expressions you type. We have already established the rules
    for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out
    in your mind a rule for evaluating procedure applications of the form (procedure arg1 ... argn). Here, procedure is
    an expression representing a Scheme procedure, and arg1 ... argn are expressions representing its arguments. One
    possibility is the following.

    + Find the value of procedure.
    + Find the value of arg1.
    + ...
    + Find the value of argn.
    + Apply the value of procedure to the values of arg1 ... argn.

    For example, consider the simple procedure application (+ 3 4). The value of + is the addition procedure, the value
    of 3 is the number 3, and the value of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so our
    value is the object 7.

    By applying this process at each level, we can find the value of the nested expression (* (+ 3 4) 2). The value of *
    is the multiplication procedure, the value of (+ 3 4) we can determine to be the number 7, and the value of 2 is the
    number 2. Multiplying 7 by 2 we get 14, so our answer is 14.

    This rule works for procedure applications but not for quote expressions because the subexpressions of a procedure
    application are evaluated, whereas the subexpression of a quote expression is not. The evaluation of a quote
    expression is more similar to the evaluation of constant objects. The value of a quote expression of the form (quote
    object) is simply object.

    Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided
    by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme
    programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions
    defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining core syntactic forms and a
    few syntactic extensions in the remaining sections of this chapter. Section 3.1 summarizes the core syntactic forms
    and introduces the syntactic extension mechanism.

    Before we go on to more syntactic forms and procedures, two points related to the evaluation of procedure
    applications are worthy of note. First, the process given above is overspecified, in that it requires the
    subexpressions to be evaluated from left to right. That is, procedure is evaluated before arg1, arg1 is evaluated
    before arg2, and so on. This need not be the case. A Scheme evaluator is free to evaluate the expressions in any
    order---left to right, right to left, or any other sequential order. In fact, the subexpressions may be evaluated in
    different orders for different applications, even in the same implementation.

    The second point is that procedure is evaluated in the same way as arg1 ... argn. While procedure is often a variable
    that names a particular procedure, this need not be the case. Exercise 2.2.3 had you determine the value of the
    expression ((car (list + - * /)) 2 3). Here, procedure is (car (list + - * /)). The value of (car (list + - * /)) is
    the addition procedure, just as if procedure were simply the variable +.

**** Exercise 2.3.1

     Write down the steps necessary to evaluate the expression below.

#+begin_src scheme
     ((car (cdr (list + - * /))) 17 5)
#+end_src

*** Variables and Let Expressions

    Suppose expr is a Scheme expression that contains a variable var. Suppose, additionally, that we would like var to
    have the value val when we evaluate expr. For example, we might like x to have the value 2 when we evaluate (+ x
    3). Or, we might want y to have the value 3 when we evaluate (+ 2 y). The following examples demonstrate how to do
    this using Scheme's let syntactic form.

#+begin_src scheme
    (let ((x 2))
      (+ x 3)) ⇒ 5

    (let ((y 3))
      (+ 2 y)) ⇒ 5

    (let ((x 2) (y 3))
      (+ x y)) ⇒ 5
#+end_src

    The let syntactic form includes a list of variable-expression pairs, along with a sequence of expressions referred to
    as the body of the let. The general form of a let expression is

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    We say the variables are bound to the values by the let. We refer to variables bound by let as let-bound variables.

    A let expression is often used to simplify an expression that would contain two identical subexpressions. Doing so
    also ensures that the value of the common subexpression is computed only once.

#+begin_src scheme
    (+ (* 4 4) (* 4 4)) ⇒ 32

    (let ((a (* 4 4))) (+ a a)) ⇒ 32
#+end_src

    Brackets are often used in place of parentheses to delimit the bindings of a let expression.

#+begin_src scheme
    (let ([list1 '(a b c)] [list2 '(d e f)])
      (cons (cons (car list1)
                  (car list2))
            (cons (car (cdr list1))
                  (car (cdr list2))))) ⇒ ((a . d) b . e)
#+end_src

    Scheme treats forms enclosed in brackets just like forms enclosed in parentheses. An open bracket must be matched by
    a close bracket, and an open parenthesis must be matched by a close parenthesis. We use brackets for let (and, as
    we'll see, several other standard syntactic forms) to improve readability, especially when we might otherwise have
    two or more consecutive open parentheses.

    Since expressions in the first position of a procedure application are evaluated no differently from other
    expressions, a let-bound variable may be used there as well.

#+begin_src scheme
    (let ([f +])
      (f 2 3)) ⇒ 5

    (let ([f +] [x 2])
      (f x 3)) ⇒ 5

    (let ([f +] [x 2] [y 3])
      (f x y)) ⇒ 5
#+end_src

    The variables bound by let are visible only within the body of the let.

#+begin_src scheme
    (let ([+ *])
      (+ 2 3)) ⇒ 6

    (+ 2 3) ⇒ 5
#+end_src

    This is fortunate, because we would not want the value of + to be the multiplication procedure everywhere.

    It is possible to nest let expressions.

#+begin_src scheme
    (let ([a 4] [b -3])
      (let ([a-squared (* a a)]
            [b-squared (* b b)])
        (+ a-squared b-squared))) ⇒ 25
#+end_src

    When nested let expressions bind the same variable, only the binding created by the inner let is visible within its body.

#+begin_src scheme
    (let ([x 1])
      (let ([x (+ x 1)])
        (+ x x))) ⇒ 4
#+end_src

    The outer let expression binds x to 1 within its body, which is the second let expression. The inner let expression
    binds x to (+ x 1) within its body, which is the expression (+ x x). What is the value of (+ x 1)? Since (+ x 1)
    appears within the body of the outer let but not within the body of the inner let, the value of x must be 1 and hence
    the value of (+ x 1) is 2. What about (+ x x)? It appears within the body of both let expressions. Only the inner
    binding for x is visible, so x is 2 and (+ x x) is 4.

    The inner binding for x is said to shadow the outer binding. A let-bound variable is visible everywhere within the
    body of its let expression except where it is shadowed. The region where a variable binding is visible is called its
    scope. The scope of the first x in the example above is the body of the outer let expression minus the body of the
    inner let expression, where it is shadowed by the second x. This form of scoping is referred to as lexical scoping,
    since the scope of each binding can be determined by a straightforward textual analysis of the program.

    Shadowing may be avoided by choosing different names for variables. The expression above could be rewritten so that
    the variable bound by the inner let is new-x.

#+begin_src scheme
    (let ([x 1])
      (let ([new-x (+ x 1)])
        (+ new-x new-x))) ⇒ 4
#+end_src

    Although choosing different names can sometimes prevent confusion, shadowing can help prevent the accidental use of
    an "old" value. For example, with the original version of the preceding example, it would be impossible for us to
    mistakenly refer to the outer x within the body of the inner let.

**** Exercise 2.4.1

     Rewrite the following expressions, using let to remove common subexpressions and to improve the structure of the
     code. Do not perform any algebraic simplifications.

     + ~(+ (- (* 3 a) b) (+ (* 3 a) b))~
     + ~(cons (car (list a b c)) (cdr (list a b c)))~

**** Exercise 2.4.2

     Determine the value of the following expression. Explain how you derived this value.

#+begin_src scheme
     (let ([x 9])
       (* x
          (let ([x (/ x 3)])
            (+ x x))))
#+end_src

**** Exercise 2.4.3

     Rewrite the following expressions to give unique names to each different let-bound variable so that none of the
     variables is shadowed. Verify that the value of your expression is the same as that of the original expression.

     +
#+begin_src scheme
     (let ([x 'a] [y 'b])
       (list (let ([x 'c]) (cons x y))
             (let ([y 'd]) (cons x y))))
#+end_src

     +
#+begin_src scheme
     (let ([x '((a b) c)])
       (cons (let ([x (cdr x)])
               (car x))
             (let ([x (car x)])
               (cons (let ([x (cdr x)])
                       (car x))
                     (cons (let ([x (car x)])
                             x)
                           (cdr x))))))
#+end_src

*** Lambda Expressions

    In the expression ~(let ([x (* 3 4)]) (+ x x))~, the variable x is bound to the value of (* 3 4). What if we would
    like the value of (+ x x) where x is bound to the value of (/ 99 11)? Where x is bound to the value of (- 2 7)? In
    each case we need a different let expression. When the body of the let is complicated, however, having to repeat it
    can be inconvenient.

    Instead, we can use the syntactic form lambda to create a new procedure that has x as a parameter and has the same
    body as the let expression.

#+begin_src scheme
    (lambda (x) (+ x x)) ⇒ #<procedure>
#+end_src

    The general form of a lambda expression is

#+begin_src scheme
    (lambda (var ...) body1 body2 ...)
#+end_src

    The variables var ... are the formal parameters of the procedure, and the sequence of expressions body1 body2 ... is
    its body. (Actually, the true general form is somewhat more general than this, as you will see later.)

    A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed
    representation as far as Scheme is concerned, however, so this book uses the notation #<procedure> to show that the
    value of an expression is a procedure.

    The most common operation to perform on a procedure is to apply it to one or more values.

#+begin_src scheme
    ((lambda (x) (+ x x)) (* 3 4)) ⇒ 24
#+end_src

    This is no different from any other procedure application. The procedure is the value of (lambda (x) (+ x x)), and
    the only argument is the value of (* 3 4), or 12. The argument values, or actual parameters, are bound to the formal
    parameters within the body of the lambda expression in the same way as let-bound variables are bound to their
    values. In this case, x is bound to 12, and the value of (+ x x) is 24. Thus, the result of applying the procedure to
    the value 12 is 24.

    Because procedures are objects, we can establish a procedure as the value of a variable and use the procedure more
    than once.

#+begin_src scheme
    (let ([double (lambda (x) (+ x x))])
      (list (double (* 3 4))
            (double (/ 99 11))
            (double (- 2 7)))) ⇒ (24 18 -10)
#+end_src

    Here, we establish a binding for double to a procedure, then use this procedure to double three different values.

    The procedure expects its actual parameter to be a number, since it passes the actual parameter on to +. In general,
    the actual parameter may be any sort of object. Consider, for example, a similar procedure that uses cons instead of
    +.

#+begin_src scheme
    (let ([double-cons (lambda (x) (cons x x))])
      (double-cons 'a)) ⇒ (a . a)
#+end_src

    Noting the similarity between double and double-cons, you should not be surprised to learn that they may be collapsed
    into a single procedure by adding an additional argument.

#+begin_src scheme
    (let ([double-any (lambda (f x) (f x x))])
      (list (double-any + 13)
            (double-any cons 'a))) ⇒ (26 (a . a))
#+end_src

    This demonstrates that procedures may accept more than one argument and that arguments passed to a procedure may
    themselves be procedures.

    As with let expressions, lambda expressions become somewhat more interesting when they are nested within other lambda
    or let expressions.

#+begin_src scheme
    (let ([x 'a])
      (let ([f (lambda (y) (list x y))])
        (f 'b))) ⇒ (a b)
#+end_src

    The occurrence of x within the lambda expression refers to the x outside the lambda that is bound by the outer let
    expression. The variable x is said to occur free in the lambda expression or to be a free variable of the lambda
    expression. The variable y does not occur free in the lambda expression since it is bound by the lambda expression. A
    variable that occurs free in a lambda expression should be bound, e.g., by an enclosing lambda or let expression,
    unless the variable is (like the names of primitive procedures) bound outside of the expression, as we discuss in the
    following section.

    What happens when the procedure is applied somewhere outside the scope of the bindings for variables that occur free
    within the procedure, as in the following expression?

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (f 'i 'am)) ⇒ (sam i am)
#+end_src

    The answer is that the same bindings that were in effect when the procedure was created are in effect again when the
    procedure is applied. This is true even if another binding for x is visible where the procedure is applied.

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (let ([x 'not-sam])
        (f 'i 'am))) ⇒ (sam i am)
#+end_src

    In both cases, the value of x within the procedure named f is sam.

    Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of
    argument expressions. For example, the two expressions below are equivalent.

#+begin_src scheme
    (let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)
#+end_src

    In fact, a let expression is a syntactic extension defined in terms of lambda and procedure application, which are
    both core syntactic forms. In general, any expression of the form

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    is equivalent to the following.

#+begin_src scheme
    ((lambda (var ...) body1 body2 ...)
     expr ...)
#+end_src

    See Section 3.1 for more about core forms and syntactic extensions.

    As mentioned above, the general form of lambda is a bit more complicated than the form we saw earlier, in that the
    formal parameter specification, (var ...), need not be a proper list, or indeed even a list at all. The formal
    parameter specification can be in any of the following three forms:

    + a proper list of variables, (var1 ... varn), such as we have already seen,
    + a single variable, varr, or
    + an improper list of variables, (var1 ... varn . varr).

    In the first case, exactly n actual parameters must be supplied, and each variable is bound to the corresponding
    actual parameter. In the second, any number of actual parameters is valid; all of the actual parameters are put into
    a single list and the single variable is bound to this list. The third case is a hybrid of the first two cases. At
    least n actual parameters must be supplied. The variables var1 ... varn are bound to the corresponding actual
    parameters, and the variable varr is bound to a list containing the remaining actual parameters. In the second and
    third cases, varr is sometimes referred to as a "rest" parameter because it holds the rest of the actual parameters
    beyond those that are individually named.

    Let's consider a few examples to help clarify the more general syntax of lambda expressions.

#+begin_src scheme
    (let ([f (lambda x x)])
      (f 1 2 3 4)) ⇒ (1 2 3 4)

    (let ([f (lambda x x)])
      (f)) ⇒ ()

    (let ([g (lambda (x . y) (list x y))])
      (g 1 2 3 4)) ⇒ (1 (2 3 4))

    (let ([h (lambda (x y . z) (list x y z))])
      (h 'a 'b 'c 'd)) ⇒ (a b (c d))
#+end_src

    In the first two examples, the procedure named f accepts any number of arguments. These arguments are automatically
    formed into a list to which the variable x is bound; the value of f is this list. In the first example, the arguments
    are 1, 2, 3, and 4, so the answer is (1 2 3 4). In the second, there are no arguments, so the answer is the empty
    list (). The value of the procedure named g in the third example is a list whose first element is the first argument
    and whose second element is a list containing the remaining arguments. The procedure named h is similar but separates
    out the second argument. While f accepts any number of arguments, g must receive at least one and h must receive at
    least two.

**** Exercise 2.5.1
     Determine the values of the expressions below.

     +
#+begin_src scheme
     (let ([f (lambda (x) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda x x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) y)])
       (f 'a))
#+end_src

**** Exercise 2.5.2

     How might the primitive procedure list be defined?

**** Exercise 2.5.3

     List the variables that occur free in each of the lambda expressions below. Do not omit variables that name
     primitive procedures such as + or cons.

     +
#+begin_src scheme
     (lambda (f x) (f x))
#+end_src

     +
#+begin_src scheme
     (lambda (x) (+ x x))
#+end_src

     +
#+begin_src scheme
     (lambda (x y) (f x y))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (cons x (f x y)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([z (cons x y)])
         (x y z)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([y (cons x y)])
         (x y z)))
#+end_src

*** Top-Level Definitions

    The variables bound by let and lambda expressions are not visible outside the bodies of these expressions. Suppose
    you have created an object, perhaps a procedure, that must be accessible anywhere, like + or cons. What you need is a
    top-level definition, which may be established with define. Top-level definitions, which are supported by most
    interactive Scheme systems, are visible in every expression you enter, except where shadowed by another binding.

    Let's establish a top-level definition of the double-any procedure of the last section.

#+begin_src scheme
    (define double-any
      (lambda (f x)
        (f x x)))
#+end_src

    The variable double-any now has the same status as cons or the name of any other primitive procedure. We can use
    double-any as if it were a primitive procedure.

#+begin_src scheme
    (double-any + 10) ⇒ 20
    (double-any cons 'a) ⇒ (a . a)
#+end_src

    A top-level definition may be established for any object, not just for procedures.

#+begin_src scheme
    (define sandwich "peanut-butter-and-jelly")

    sandwich ⇒ "peanut-butter-and-jelly"

#+end_src

    Most often, though, top-level definitions are used for procedures.

    As suggested above, top-level definitions may be shadowed by let or lambda bindings.

#+begin_src scheme
    (define xyz '(x y z))
    (let ([xyz '(z y x)])
      xyz) ⇒ (z y x)
#+end_src

    Variables with top-level definitions act almost as if they were bound by a let expression enclosing all of the
    expressions you type.

    Given only the simple tools you have read about up to this point, it is already possible to define some of the
    primitive procedures provided by Scheme and described later in this book. If you completed the exercises from the
    last section, you should already know how to define list.

#+begin_src scheme
    (define list (lambda x x))
#+end_src

    Also, Scheme provides the abbreviations cadr and cddr for the compositions of car with cdr and cdr with cdr. That is,
    (cadr list) is equivalent to (car (cdr list)), and, similarly, (cddr list) is equivalent to (cdr (cdr list)). They
    are easily defined as follows.

#+begin_src scheme
    (define cadr
      (lambda (x)
        (car (cdr x))))

    (define cddr
      (lambda (x)
        (cdr (cdr x))))

    (cadr '(a b c)) ⇒ b
    (cddr '(a b c)) ⇒ (c)
#+end_src

    Any definition (define var expr) where expr is a lambda expression can be written in a shorter form that suppresses
    the lambda. The exact syntax depends upon the format of the lambda expression's formal parameter specifier, i.e.,
    whether it is a proper list of variables, a single variable, or an improper list of variables. A definition of the
    form

#+begin_src scheme
    (define var0
      (lambda (var1 ... varn)
        e1 e2 ...))
#+end_src

    may be abbreviated

#+begin_src scheme
    (define (var0 var1 ... varn)
      e1 e2 ...)
#+end_src

    while

#+begin_src scheme
    (define var0
      (lambda varr
        e1 e2 ...))
#+end_src

    may be abbreviated

#+begin_src scheme
    (define (var0 . varr)
      e1 e2 ...)
#+end_src

    and

#+begin_src scheme
    (define var0
      (lambda (var1 ... varn . varr)
        e1 e2 ...))
#+end_src

    may be abbreviated

#+begin_src scheme
    (define (var0 var1 ... varn . varr)
      e1 e2 ...)
#+end_src

    For example, the definitions of cadr and list might be written as follows.

#+begin_src scheme
    (define (cadr x)
      (car (cdr x)))

    (define (list . x) x)

#+end_src

    This book does not often employ this alternative syntax. Although it is shorter, it tends to mask the reality that
    procedures are not intimately tied to variables, or names, as they are in many other languages. This syntax is often
    referred to, somewhat pejoratively, as the "defun" syntax for define, after the defun form provided by Lisp languages
    in which procedures are more closely tied to their names.

    Top-level definitions make it easier for us to experiment with a procedure interactively because we need not retype
    the procedure each time it is used. Let's try defining a somewhat more complicated variation of double-any, one that
    turns an "ordinary" two-argument procedure into a "doubling" one-argument procedure.

#+begin_src scheme
    (define doubler
      (lambda (f)
        (lambda (x) (f x x))))
#+end_src

    doubler accepts one argument, f, which must be a procedure that accepts two arguments. The procedure returned by
    doubler accepts one argument, which it uses for both arguments in an application of f. We can define, with doubler,
    the simple double and double-cons procedures of the last section.

#+begin_src scheme
    (define double (doubler +))
    (double 13/2) ⇒ 13

    (define double-cons (doubler cons))
    (double-cons 'a) ⇒ (a . a)
#+end_src

    We can also define double-any with doubler.

#+begin_src scheme
    (define double-any
      (lambda (f x)
        ((doubler f) x)))
#+end_src

    Within double and double-cons, f has the appropriate value, i.e., + or cons, even though the procedures are clearly
    applied outside the scope of f.

    What happens if you attempt to use a variable that is not bound by a let or lambda expression and that does not have
    a top-level definition? Try using the variable i-am-not-defined to see what happens.

#+begin_src scheme
    (i-am-not-defined 3)
#+end_src

    Most Scheme systems print a message indicating that an unbound- or undefined-variable exception has occurred.

    The system should not, however, complain about the appearance of an undefined variable within a lambda expression,
    until and unless the resulting procedure is applied. The following should not cause an exception, even though we have
    not yet established a top-level definition of proc2.

#+begin_src scheme
    (define proc1
      (lambda (x y)
        (proc2 y x)))
#+end_src

    If you try to apply proc1 before defining proc2, you should get a undefined exception message. Let's give proc2 a
    top-level definition and try proc1.

#+begin_src scheme
    (define proc2 cons)
    (proc1 'a 'b) ⇒ (b . a)
#+end_src

    When you define proc1, the system accepts your promise to define proc2, and does not complain unless you use proc1
    before defining proc2. This allows you to define procedures in any order you please. This is especially useful when
    you are trying to organize a file full of procedure definitions in a way that makes your program more readable. It is
    necessary when two procedures defined at top level depend upon each other; we will see some examples of this later.

**** Exercise 2.6.1
     What would happen if you were to type

#+begin_src scheme
     (double-any double-any double-any)
#+end_src

     given the definition of double-any from the beginning of this section?

**** Exercise 2.6.2
     A more elegant (though possibly less efficient) way to define cadr and cddr than given in this section is to define a
     procedure that composes two procedures to create a third. Write the procedure compose, such that (compose p1 p2) is
     the composition of p1 and p2 (assuming both take one argument). That is, (compose p1 p2) should return a new
     procedure of one argument that applies p1 to the result of applying p2 to the argument. Use compose to define cadr
     and cddr.

**** Exercise 2.6.3
     Scheme also provides caar, cdar, caaar, caadr, and so on, with any combination of up to four a's (representing car)
     and d's (representing cdr) between the c and the r (see Section 6.3). Define each of these with the compose procedure
     of the preceding exercise.

*** Conditional Expressions

    So far we have considered expressions that perform a given task unconditionally. Suppose that we wish to write the
    procedure abs. If its argument x is negative, abs returns -x; otherwise, it returns x. The most straightforward way
    to write abs is to determine whether the argument is negative and if so negate it, using the if syntactic form.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (< n 0)
            (- 0 n)
            n)))

    (abs 77) ⇒ 77
    (abs -77) ⇒ 77
#+end_src

    An if expression has the form (if test consequent alternative), where consequent is the expression to evaluate if
    test is true and alternative is the expression to evaluate if test is false. In the expression above, test is (< n
    0), consequent is (- 0 n), and alternative is n.

    The procedure abs could be written in a variety of other ways. Any of the following are valid definitions of abs.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (>= n 0)
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (not (< n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (or (> n 0) (= n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (= n 0)
            0
            (if (< n 0)
                (- 0 n)
                n))))

    (define abs
      (lambda (n)
        ((if (>= n 0) + -)
         0
         n)))
#+end_src

    The first of these definitions asks if n is greater than or equal to zero, inverting the test. The second asks if n
    is not less than zero, using the procedure not with <. The third asks if n is greater than zero or n is equal to
    zero, using the syntactic form or. The fourth treats zero separately, though there is no benefit in doing so. The
    fifth is somewhat tricky; n is either added to or subtracted from zero, depending upon whether n is greater than or
    equal to zero.

    Why is if a syntactic form and not a procedure? In order to answer this, let's revisit the definition of reciprocal
    from the first section of this chapter.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    The second argument to the division procedure should not be zero, since the result is mathematically undefined. Our
    definition of reciprocal avoids this problem by testing for zero before dividing. Were if a procedure, its arguments
    (including (/ 1 n)) would be evaluated before it had a chance to choose between the consequent and alternative. Like
    quote, which does not evaluate its only subexpression, if does not evaluate all of its subexpressions and so cannot
    be a procedure.

    The syntactic form or operates in a manner similar to if. The general form of an or expression is (or expr ...). If
    there are no subexpressions, i.e., the expression is simply (or), the value is false. Otherwise, each expr is
    evaluated in turn until either (a) one of the expressions evaluates to true or (b) no more expressions are left. In
    case (a), the value is true; in case (b), the value is false.

    To be more precise, in case (a), the value of the or expression is the value of the last subexpression
    evaluated. This clarification is necessary because there are many possible true values. Usually, the value of a test
    expression is one of the two objects #t, for true, or #f, for false.

#+begin_src scheme
    (< -1 0) ⇒ #t
    (> -1 0) ⇒ #f
#+end_src

    Every Scheme object, however, is considered to be either true or false by conditional expressions and by the
    procedure not. Only #f is considered false; all other objects are considered true.

#+begin_src scheme
    (if #t 'true 'false) ⇒ true
    (if #f 'true 'false) ⇒ false
    (if '() 'true 'false) ⇒ true
    (if 1 'true 'false) ⇒ true
    (if '(a b c) 'true 'false) ⇒ true

    (not #t) ⇒ #f
    (not "false") ⇒ #f
    (not #f) ⇒ #t

    (or) ⇒ #f
    (or #f) ⇒ #f
    (or #f #t) ⇒ #t
    (or #f 'a #f) ⇒ a
#+end_src

    The and syntactic form is similar in form to or, but an and expression is true if all its subexpressions are true,
    and false otherwise. In the case where there are no subexpressions, i.e., the expression is simply (and), the value
    is true. Otherwise, the subexpressions are evaluated in turn until either no more subexpressions are left or the
    value of a subexpression is false. The value of the and expression is the value of the last subexpression evaluated.

    Using and, we can define a slightly different version of reciprocal.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (and (not (= n 0))
             (/ 1 n))))

    (reciprocal 3) ⇒ 1/3
    (reciprocal 0.5) ⇒ 2.0
    (reciprocal 0) ⇒ #f
#+end_src

    In this version, the value is #f if n is zero and 1/n otherwise.

    The procedures =, <, >, <=, and >= are called predicates. A predicate is a procedure that answers a specific question
    about its arguments and returns one of the two values #t or #f. The names of most predicates end with a question mark
    ( ? ); the common numeric procedures listed above are exceptions to this rule. Not all predicates require numeric
    arguments, of course. The predicate null? returns true if its argument is the empty list () and false otherwise.

#+begin_src scheme
    (null? '()) ⇒ #t
    (null? 'abc) ⇒ #f
    (null? '(x y z)) ⇒ #f
    (null? (cdddr '(x y z))) ⇒ #t
#+end_src

    The procedure cdr must not be passed anything other than a pair, and an exception is raised when this happens. Common
    Lisp, however, defines (cdr '()) to be (). The following procedure, lisp-cdr, is defined using null? to return () if
    its argument is ().

#+begin_src scheme
    (define lisp-cdr
      (lambda (x)
        (if (null? x)
            '()
            (cdr x))))

    (lisp-cdr '(a b c)) ⇒ (b c)
    (lisp-cdr '(c)) ⇒ ()
    (lisp-cdr '()) ⇒ ()
#+end_src

    Another useful predicate is eqv?, which requires two arguments. If the two arguments are equivalent, eqv? returns
    true. Otherwise, eqv? returns false.

#+begin_src scheme
    (eqv? 'a 'a) ⇒ #t
    (eqv? 'a 'b) ⇒ #f
    (eqv? #f #f) ⇒ #t
    (eqv? #t #t) ⇒ #t
    (eqv? #f #t) ⇒ #f
    (eqv? 3 3) ⇒ #t
    (eqv? 3 2) ⇒ #f
    (let ([x "Hi Mom!"])
      (eqv? x x)) ⇒ #t
    (let ([x (cons 'a 'b)])
      (eqv? x x)) ⇒ #t
    (eqv? (cons 'a 'b) (cons 'a 'b)) ⇒ #f
#+end_src

    As you can see, eqv? returns true if the arguments are the same symbol, boolean, number, pair, or string. Two pairs
    are not the same by eqv? if they are created by different calls to cons, even if they have the same
    contents. Detailed equivalence rules for eqv? are given in Section 6.2.

    Scheme also provides a set of type predicates that return true or false depending on the type of the object, e.g.,
    pair?, symbol?, number?, and string?. The predicate pair?, for example, returns true only if its argument is a pair.

#+begin_src scheme
    (pair? '(a . c)) ⇒ #t
    (pair? '(a b c)) ⇒ #t
    (pair? '()) ⇒ #f
    (pair? 'abc) ⇒ #f
    (pair? "Hi Mom!") ⇒ #f
    (pair? 1234567890) ⇒ #f
#+end_src

    Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
    example, the following version of reciprocal checks first to see that its argument is a number before testing against
    zero or performing the division.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            "oops!")))

    (reciprocal 2/3) ⇒ 3/2
    (reciprocal 'a) ⇒ "oops!"
#+end_src

    By the way, the code that uses reciprocal must check to see that the returned value is a number and not a string. To
    relieve the caller of this obligation, it is usually preferable to report the error, using assertion-violation, as
    follows.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            (assertion-violation 'reciprocal
              "improper argument"
              n))))

    (reciprocal .25) ⇒ 4.0
    (reciprocal 0) ⇒ exception in reciprocal: improper argument 0
    (reciprocal 'a) ⇒ exception in reciprocal: improper argument a
#+end_src

    The first argument to assertion-violation is a symbol identifying where the message originates, the second is a
    string describing the error, and the third and subsequent arguments are "irritants" to be included with the error
    message.

    Let's look at one more conditional expression, cond, that is often useful in place of if. cond is similar to if
    except that it allows multiple test and alternative expressions. Consider the following definition of sign, which
    returns -1 for negative inputs, +1 for positive inputs, and 0 for zero.

#+begin_src scheme
    (define sign
      (lambda (n)
        (if (< n 0)
            -1
            (if (> n 0)
                +1
                0))))

    (sign -88.3) ⇒ -1
    (sign 0) ⇒ 0
    (sign 333333333333) ⇒ 1
    (* (sign -88.3) (abs -88.3)) ⇒ -88.3
#+end_src

    The two if expressions may be replaced by a single cond expression as follows.

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [else 0])))
#+end_src

    A cond expression usually takes the form

#+begin_src scheme
    (cond (test expr) ... (else expr))
#+end_src

    though the else clause may be omitted. This should be done only when there is no possibility that all the tests will
    fail, as in the new version of sign below.

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [(= n 0) 0])))
#+end_src

    These definitions of sign do not depend on the order in which the tests are performed, since only one of the tests
    can be true for any value of n. The following procedure computes the tax on a given amount of income in a progressive
    tax system with breakpoints at 10,000, 20,000, and 30,000 dollars.

#+begin_src scheme
    (define income-tax
      (lambda (income)
        (cond
          [(<= income 10000) (* income .05)]
          [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
          [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
          [else (+ (* (- income 30000) .21) 2600.00)])))

    (income-tax 5000) ⇒ 250.0
    (income-tax 15000) ⇒ 900.0
    (income-tax 25000) ⇒ 1950.0
    (income-tax 50000) ⇒ 6800.0
#+end_src

    In this example, the order in which the tests are performed, left to right (top to bottom), is significant.

**** Exercise 2.7.1

     Define the predicate atom?, which returns true if its argument is not a pair and false if it is.

**** Exercise 2.7.2

     The procedure length returns the length of its argument, which must be a list. For example, (length '(a b c))
     is 3. Using length, define the procedure shorter, which returns the shorter of two list arguments. Have it return the
     first list if they have the same length.

#+begin_src scheme
     (shorter '(a b) '(c d e)) ⇒ (a b)
     (shorter '(a b) '(c d)) ⇒ (a b)
     (shorter '(a b) '(c)) ⇒ (c)
#+end_src

*** Simple Recursion

    We have seen how we can control whether or not expressions are evaluated with if, and, or, and cond. We can also
    perform an expression more than once by creating a procedure containing the expression and invoking the procedure
    more than once. What if we need to perform some expression repeatedly, say for all the elements of a list or all the
    numbers from one to ten? We can do so via recursion. Recursion is a simple concept: the application of a procedure
    from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive
    power far beyond ordinary looping constructs.

    A recursive procedure is a procedure that applies itself. Perhaps the simplest recursive procedure is the following,
    which we will call goodbye.

#+begin_src scheme
    (define goodbye
      (lambda ()
        (goodbye)))

    (goodbye) ⇒
#+end_src

    This procedure takes no arguments and simply applies itself immediately. There is no value after the ⇒
    because goodbye never returns.

    Obviously, to make practical use out of a recursive procedure, we must have some way to terminate the recursion. Most
    recursive procedures should have at least two basic elements, a base case and a recursion step. The base case
    terminates the recursion, giving the value of the procedure for some base argument. The recursion step gives the
    value in terms of the value of the procedure applied to a different argument. In order for the recursion to
    terminate, the different argument must be closer to the base argument in some way.

    Let's consider the problem of finding the length of a proper list recursively. We need a base case and a recursion
    step. The logical base argument for recursion on lists is nearly always the empty list. The length of the empty list
    is zero, so the base case should give the value zero for the empty list. In order to become closer to the empty list,
    the natural recursion step involves the cdr of the argument. A nonempty list is one element longer than its cdr, so
    the recursion step gives the value as one more than the length of the cdr of the list.

#+begin_src scheme
    (define length
      (lambda (ls)
        (if (null? ls)
            0
            (+ (length (cdr ls)) 1))))

    (length '()) ⇒ 0
    (length '(a)) ⇒ 1
    (length '(a b)) ⇒ 2
#+end_src

    The if expression asks if the list is empty. If so, the value is zero. This is the base case. If not, the value is
    one more than the length of the cdr of the list. This is the recursion step.

    Many Scheme implementations allow you to trace the execution of a procedure to see how it operates. In Chez Scheme,
    for example, one way to trace a procedure is to type (trace name), where name is the name of a procedure you have
    defined at top level. If you trace length as defined above and pass it the argument '(a b c d), you should see
    something like this:

#+BEGIN_EXAMPLE
    |(length (a b c d))
    | (length (b c d))
    | |(length (c d))
    | | (length (d))
    | | |(length ())
    | | |0
    | | 1
    | |2
    | 3
    |4
#+END_EXAMPLE

    The indentation shows the nesting level of the recursion; the vertical lines associate applications visually with
    their values. Notice that on each application of length the list gets smaller until it finally reaches (). The value
    at () is 0, and each outer level adds 1 to arrive at the final value.

    Let's write a procedure, list-copy, that returns a copy of its argument, which must be a list. That is, list-copy
    returns a new list consisting of the elements (but not the pairs) of the old list. Making a copy might be useful if
    either the original list or the copy might be altered via set-car! or set-cdr!, which we discuss later.

#+begin_src scheme
    (list-copy '()) ⇒ ()
    (list-copy '(a b c)) ⇒ (a b c)
#+end_src

    See if you can define list-copy before studying the definition below.

#+begin_src scheme
    (define list-copy
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (car ls)
                  (list-copy (cdr ls))))))
#+end_src

    The definition of list-copy is similar to the definition of length. The test in the base case is the same, (null?
    ls). The value in the base case is (), however, not 0, because we are building up a list, not a number. The recursive
    call is the same, but instead of adding one, list-copy conses the car of the list onto the value of the recursive
    call.

    There is no reason why there cannot be more than one base case. The procedure memv takes two arguments, an object and
    a list. It returns the first sublist, or tail, of the list whose car is equal to the object, or #f if the object is
    not found in the list. The value of memv may be used as a list or as a truth value in a conditional expression.

#+begin_src scheme
    (define memv
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eqv? (car ls) x) ls]
          [else (memv x (cdr ls))])))

    (memv 'a '(a b b d)) ⇒ (a b b d)
    (memv 'b '(a b b d)) ⇒ (b b d)
    (memv 'c '(a b b d)) ⇒ #f
    (memv 'd '(a b b d)) ⇒ (d)
    (if (memv 'b '(a b b d))
        "yes"
        "no") ⇒ "yes"
#+end_src

    Here there are two conditions to check, hence the use of cond. The first cond clause checks for the base value of ();
    no object is a member of (), so the answer is #f. The second clause asks if the car of the list is the object, in
    which case the list is returned, being the first tail whose car contains the object. The recursion step just
    continues down the list.

    There may also be more than one recursion case. Like memv, the procedure remv defined below takes two arguments, an
    object and a list. It returns a new list with all occurrences of the object removed from the list.

#+begin_src scheme
    (define remv
      (lambda (x ls)
        (cond
          [(null? ls) '()]
          [(eqv? (car ls) x) (remv x (cdr ls))]
          [else (cons (car ls) (remv x (cdr ls)))])))

    (remv 'a '(a b b d)) ⇒ (b b d)
    (remv 'b '(a b b d)) ⇒ (a d)
    (remv 'c '(a b b d)) ⇒ (a b b d)
    (remv 'd '(a b b d)) ⇒ (a b b)
#+end_src

    This definition is similar to the definition of memv above, except remv does not quit once it finds the element in
    the car of the list. Rather, it continues, simply ignoring the element. If the element is not found in the car of the
    list, remv does the same thing as list-copy above: it conses the car of the list onto the recursive value.

    Up to now, the recursion has been only on the cdr of a list. It is sometimes useful, however, for a procedure to
    recur on the car as well as the cdr of the list. The procedure tree-copy defined below treats the structure of pairs
    as a tree rather than as a list, with the left subtree being the car of the pair and the right subtree being the cdr
    of the pair. It performs a similar operation to list-copy, building new pairs while leaving the elements (leaves)
    alone.

#+begin_src scheme
    (define tree-copy
      (lambda (tr)
        (if (not (pair? tr))
            tr
            (cons (tree-copy (car tr))
                  (tree-copy (cdr tr))))))

    (tree-copy '((a . b) . c)) ⇒ ((a . b) . c)
#+end_src

    The natural base argument for a tree structure is anything that is not a pair, since the recursion traverses pairs
    rather than lists. The recursive step in this case is doubly recursive, finding the value recursively for the car as
    well as the cdr of the argument.

    At this point, readers who are familiar with other languages that provide special iteration constructs, e.g., while
    or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary;
    iteration in Scheme is expressed more clearly and succinctly via recursion. Recursion is more general and eliminates
    the need for the variable assignments required by many other languages' iteration constructs, resulting in code that
    is more reliable and easier to follow. Some recursion is essentially iteration and executes as such; Section 3.2 has
    more to say about this. Often, there is no need to make a distinction, however. Concentrate instead on writing clear,
    concise, and correct programs.

    Before we leave the topic of recursion, let's consider a special form of repetition called mapping. Consider the
    following procedure, abs-all, that takes a list of numbers as input and returns a list of their absolute values.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (abs (car ls))
                  (abs-all (cdr ls))))))

    (abs-all '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    This procedure forms a new list from the input list by applying the procedure abs to each element. We say that
    abs-all maps abs over the input list to produce the output list. Mapping a procedure over a list is a fairly common
    thing to do, so Scheme provides the procedure map, which maps its first argument, a procedure, over its second, a
    list. We can use map to define abs-all.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (map abs ls)))
#+end_src

    We really do not need abs-all, however, since the corresponding direct application of map is just as short and
    perhaps clearer.

#+begin_src scheme
    (map abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    Of course, we can use lambda to create the procedure argument to map, e.g., to square the elements of a list of
    numbers.

#+begin_src scheme
    (map (lambda (x) (* x x))
         '(1 -3 -5 7)) ⇒ (1 9 25 49)
#+end_src

    We can map a multiple-argument procedure over multiple lists, as in the following example.

#+begin_src scheme
    (map cons '(a b c) '(1 2 3)) ⇒ ((a . 1) (b . 2) (c . 3))
#+end_src

    The lists must be of the same length, and the procedure should accept as many arguments as there are lists. Each
    element of the output list is the result of applying the procedure to corresponding members of the input list.

    Looking at the first definition of abs-all above, you should be able to derive, before studying it, the following
    definition of map1, a restricted version of map that maps a one-argument procedure over a single list.

#+begin_src scheme
    (define map1
      (lambda (p ls)
        (if (null? ls)
            '()
            (cons (p (car ls))
                  (map1 p (cdr ls))))))

    (map1 abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    All we have done is to replace the call to abs in abs-all with a call to the new parameter p. A definition of the
    more general map is given in Section 5.4.

**** Exercise 2.8.1

     Describe what would happen if you switched the order of the arguments to cons in the definition of tree-copy.

**** Exercise 2.8.2

     Consult Section 6.3 for the description of append and define a two-argument version of it. What would happen if you
     switched the order of the arguments in the call to append within your definition of append?

**** Exercise 2.8.3

     Define the procedure make-list, which takes a nonnegative integer n and an object and returns a new list, n long,
     each element of which is the object.

#+begin_src scheme
     (make-list 7 '()) ⇒ (() () () () () () ())
#+end_src

     [Hint: The base test should be (= n 0), and the recursion step should involve (- n 1). Whereas () is the natural base
     case for recursion on lists, 0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
     1 is the natural way to bring a nonnegative integer closer to 0.]

**** Exercise 2.8.4

     The procedures list-ref and list-tail return the nth element and nth tail of a list ls.

#+begin_src scheme
     (list-ref '(1 2 3 4) 0) ⇒ 1
     (list-tail '(1 2 3 4) 0) ⇒ (1 2 3 4)
     (list-ref '(a short (nested) list) 2) ⇒ (nested)
     (list-tail '(a short (nested) list) 2) ⇒ ((nested) list)
#+end_src

     Define both procedures.

**** Exercise 2.8.5

     Exercise 2.7.2 had you use length in the definition of shorter, which returns the shorter of its two list arguments,
     or the first if the two have the same length. Write shorter without using length. [Hint: Define a recursive helper,
     shorter?, and use it in place of the length comparison.]

**** Exercise 2.8.6

     All of the recursive procedures shown so far have been directly recursive. That is, each procedure directly applies
     itself to a new argument. It is also possible to write two procedures that use each other, resulting in indirect
     recursion. Define the procedures odd? and even?, each in terms of the other. [Hint: What should each return when its
     argument is 0?]

#+begin_src scheme
     (even? 17) ⇒ #f
     (odd? 17) ⇒ #t
#+end_src

**** Exercise 2.8.7

     Use map to define a procedure, transpose, that takes a list of pairs and returns a pair of lists as follows.

#+begin_src scheme
     (transpose '((a . 1) (b . 2) (c . 3))) ⇒ ((a b c) 1 2 3)
#+end_src

     [Hint: ((a b c) 1 2 3) is the same as ((a b c) . (1 2 3)).]

*** Assignment

    Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound
    variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the
    values of existing bindings. Assignments are performed with set!.

#+begin_src scheme
    (define abcde '(a b c d e))
    abcde ⇒ (a b c d e)
    (set! abcde (cdr abcde))
    abcde ⇒ (b c d e)
    (let ([abcde '(a b c d e)])
      (set! abcde (reverse abcde))
      abcde) ⇒ (e d c b a)
#+end_src

    Many languages require the use of assignments to initialize local variables, separate from the declaration or binding
    of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the
    separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to
    initialize them, a common source of errors in most languages.

    In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and
    inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One
    common practice in some languages is to sequence expression evaluation with a series of assignments, as in the
    following procedure that finds the roots of a quadratic equation.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
          (cons root1 root2))))
#+end_src

    The roots are computed according to the well-known quadratic formula,

#+ATTR_LATEX: :width 60px
[[./images/4.png]]

    which yields the solutions to the equation 0 = ax2 + bx + c. The let expression in this definition is employed solely
    to establish the variable bindings, corresponding to the declarations required in other languages. The first three
    assignment expressions compute subpieces of the formula, namely -b,

#+ATTR_LATEX: :width 60px
[[./images/5.png]]

    and 2a. The last two assignment
    expressions compute the two roots in terms of the subpieces. A pair of the two roots is the value of
    quadratic-formula. For example, the two roots of 2x2 - 4x - 6 are x = 3 and x = -1.

#+begin_src scheme
    (quadratic-formula 2 -4 -6) ⇒ (3 . -1)
#+end_src

    The definition above works, but it can be written more clearly without the assignments, as shown below.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([minusb (- 0 b)]
              [radical (sqrt (- (* b b) (* 4 (* a c))))]
              [divisor (* 2 a)])
          (let ([root1 (/ (+ minusb radical) divisor)]
                [root2 (/ (- minusb radical) divisor)])
            (cons root1 root2)))))
#+end_src

    In this version, the set! expressions are gone, and we are left with essentially the same algorithm. By employing two
    let expressions, however, the definition makes clear the dependency of root1 and root2 on the values of minusb,
    radical, and divisor. Equally important, the let expressions make clear the lack of dependencies among minusb,
    radical, and divisor and between root1 and root2.

    Assignments do have some uses in Scheme, otherwise the language would not support them. Consider the following
    version of cons that counts the number of times it is called, storing the count in a variable named cons-count. It
    uses set! to increment the count; there is no way to achieve the same behavior without assignments.

#+begin_src scheme
    (define kons-count 0)
    (define kons
      (lambda (x y)
        (set! kons-count (+ kons-count 1))
        (cons x y)))
#+end_src

#+begin_src scheme
    (kons 'a '(b c)) ⇒ (a b c)
    kons-count ⇒ 1
    (kons 'a (kons 'b (kons 'c '()))) ⇒ (a b c)
    kons-count ⇒ 4
#+end_src

    Assignments are commonly used to implement procedures that must maintain some internal state. For example, suppose we
    would like to define a procedure that returns 0 the first time it is called, 1 the second time, 2 the third time, and
    so on indefinitely. We could write something similar to the definition of cons-count above:

#+begin_src scheme
    (define next 0)
    (define count
      (lambda ()
        (let ([v next])
          (set! next (+ next 1))
          v)))

    (count) ⇒ 0
    (count) ⇒ 1
#+end_src

    This solution is somewhat undesirable in that the variable next is visible at top level even though it need not
    be. Since it is visible at top level, any code in the system can change its value, perhaps inadvertently affecting
    the behavior of count in a subtle way. We can solve this problem by let-binding next outside of the lambda
    expression:

#+begin_src scheme
    (define count
      (let ([next 0])
        (lambda ()
          (let ([v next])
            (set! next (+ next 1))
            v))))
#+end_src

    The latter solution also generalizes easily to provide multiple counters, each with its own local counter. The
    procedure make-counter, defined below, returns a new counting procedure each time it is called.

#+begin_src scheme
    (define make-counter
      (lambda ()
        (let ([next 0])
          (lambda ()
            (let ([v next])
              (set! next (+ next 1))
              v)))))
#+end_src

    Since next is bound inside of make-counter but outside of the procedure returned by make-counter, each procedure it
    returns maintains its own unique counter.

#+begin_src scheme
    (define count1 (make-counter))
    (define count2 (make-counter))

    (count1) ⇒ 0
    (count2) ⇒ 0
    (count1) ⇒ 1
    (count1) ⇒ 2
    (count2) ⇒ 1
#+end_src

    If a state variable must be shared by more than one procedure defined at top level, but we do not want the state
    variable to be visible at top level, we can use let to bind the variable and set! to make the procedures visible at
    top level.

#+begin_src scheme
    (define shhh #f)
    (define tell #f)
    (let ([secret 0])
      (set! shhh
        (lambda (message)
          (set! secret message)))
      (set! tell
        (lambda ()
          secret)))

    (shhh "sally likes harry")
    (tell) ⇒ "sally likes harry"
    secret ⇒ exception: variable secret is not bound
#+end_src

    Variables must be defined before they can be assigned, so we define shhh and tell to be #f initially. (Any initial
    value would do.) We'll see this structure again in Section 3.5 and a better way to structure code like this as a
    library in Section 3.6.

    Local state is sometimes useful for caching computed values or allowing a computation to be evaluated lazily, i.e.,
    only once and only on demand. The procedure lazy below accepts a thunk, or zero-argument procedure, as an
    argument. Thunks are often used to "freeze" computations that must be delayed for some reason, which is exactly what
    we need to do in this situation. When passed a thunk t, lazy returns a new thunk that, when invoked, returns the
    value of invoking t. Once computed, the value is saved in a local variable so that the computation need not be
    performed again. A boolean flag is used to record whether t has been invoked and its value saved.

#+begin_src scheme
    (define lazy
      (lambda (t)
        (let ([val #f] [flag #f])
          (lambda ()
            (if (not flag)
                (begin (set! val (t))
                       (set! flag #t)))
            val))))
#+end_src

    The syntactic form begin, used here for the first time, evaluates its subexpressions in sequence from left to right
    and returns the value of the last subexpression, like the body of a let or lambda expression. We also see that the
    alternative subexpression of an if expression can be omitted. This should be done only when the value of the if is
    discarded, as it is in this case.

    Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the
    evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than
    once.

    The operation of lazy can best be illustrated by printing a message from within a thunk passed to lazy.

#+begin_src scheme
    (define p
      (lazy (lambda ()
              (display "Ouch!")
              (newline)
              "got me")))
#+end_src

    The first time p is invoked, the message Ouch! is printed and the string "got me" is returned. Thereafter, "got me"
    is returned but the message is not printed. The procedures display and newline are the first examples of explicit
    input/output we have seen; display prints the string without quotation marks, and newline prints a newline
    character.

    To further illustrate the use of set!, let's consider the implementation of stack objects whose internal workings are
    not visible on the outside. A stack object accepts one of four messages: empty?, which returns #t if the stack is
    empty; push!, which adds an object to the top of the stack; top, which returns the object on the top of the stack;
    and pop!, which removes the object on top of the stack. The procedure make-stack given below creates a new stack each
    time it is called in a manner similar to make-counter.

#+begin_src scheme
    (define make-stack
      (lambda ()
        (let ([ls '()])
          (lambda (msg . args)
            (cond
              [(eqv? msg 'empty?) (null? ls)]
              [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
              [(eqv? msg 'top) (car ls)]
              [(eqv? msg 'pop!) (set! ls (cdr ls))]
              [else "oops"])))))
#+end_src

    Each stack is stored as a list bound to the variable ls; set! is used to change this binding for push! and
    pop!. Notice that the argument list of the inner lambda expression uses the improper list syntax to bind args to a
    list of all arguments but the first. This is useful here because in the case of empty?, top, and pop! there is only
    one argument (the message), but in the case of push! there are two (the message and the object to push onto the
    stack).

#+begin_src scheme
    (define stack1 (make-stack))
    (define stack2 (make-stack))
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #t)

    (stack1 'push! 'a)
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #t)

    (stack1 'push! 'b)
    (stack2 'push! 'c)
    (stack1 'top) ⇒ b
    (stack2 'top) ⇒ c

    (stack1 'pop!)
    (stack1 'top) ⇒ a
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #f)

    (stack1 'pop!)
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #f)
#+end_src

    As with the counters created by make-counter, the state maintained by each stack object is directly accessible only
    within the object. Each reference or change to this state is made explicitly by the object itself. One important
    benefit is that we can change the internal structure of the stack, perhaps to use a vector (see Section 6.9) instead
    of a list to hold the elements, without changing its external behavior. Because the behavior of the object is known
    abstractly (not operationally), it is known as an abstract object. See Section 12.8 for more about creating abstract
    objects.

    In addition to changing the values of variables, we can also change the values of the car and cdr fields of a pair,
    using the procedures set-car! and set-cdr!.

#+begin_src scheme
    (define p (list 1 2 3))
    (set-car! (cdr p) 'two)
    p ⇒ (1 two 3)
    (set-cdr! p '())
    p ⇒ (1)
#+end_src

    We can use these operators to define a queue data type, which is like a stack except that new elements are added at
    one end and extracted from the other. The following queue implementation uses a tconc structure. A tconc consists of
    a nonempty list and a header. The header is a pair whose car points to the first pair (head) of the list and whose
    cdr points to the last pair (end) of the list.

#+ATTR_LATEX: :width 200px
[[./images/6.png]]

    The last element of the list is a placeholder and not considered part of the queue.

    Four operations on queues are defined below: make-queue, which constructs a queue; putq!, which adds an element to
    the end of a queue; getq, which retrieves the element at the front of a queue; and delq!, which removes the element
    at the front of a queue.

#+begin_src scheme
    (define make-queue
      (lambda ()
        (let ([end (cons 'ignored '())])
          (cons end end))))

    (define putq!
      (lambda (q v)
        (let ([end (cons 'ignored '())])
          (set-car! (cdr q) v)
          (set-cdr! (cdr q) end)
          (set-cdr! q end))))

    (define getq
      (lambda (q)
        (car (car q))))

    (define delq!
      (lambda (q)
        (set-car! q (cdr (car q)))))
#+end_src

    All are simple operations except for putq!, which modifies the end pair to contain the new value and adds a new end
    pair.

#+begin_src scheme
    (define myq (make-queue))

    (putq! myq 'a)
    (putq! myq 'b)
    (getq myq) ⇒ a
    (delq! myq)
    (getq myq) ⇒ b
    (delq! myq)
    (putq! myq 'c)
    (putq! myq 'd)
    (getq myq) ⇒ c
    (delq! myq)
    (getq myq) ⇒ d
#+end_src

**** Exercise 2.9.1

     Modify make-counter to take two arguments: an initial value for the counter to use in place of 0 and an amount to
     increment the counter by each time.

**** Exercise 2.9.2

     Look up the description of case in Section 5.3. Replace the cond expression in make-stack with an equivalent case
     expression. Add mt? as a second name for the empty? message.

**** Exercise 2.9.3

     Modify the stack object to allow the two messages ref and set!. (stack 'ref i) should return the ith element from the
     top of the stack; (stack 'ref 0) should be equivalent to (stack 'top). (stack 'set! i v) should change the ith
     element from the top of the stack to v.

#+begin_src scheme
     (define stack (make-stack))

     (stack 'push! 'a)
     (stack 'push! 'b)
     (stack 'push! 'c)

     (stack 'ref 0) ⇒ c
     (stack 'ref 2) ⇒ a
     (stack 'set! 1 'd)
     (stack 'ref 1) ⇒ d
     (stack 'top) ⇒ c
     (stack 'pop!)
     (stack 'top) ⇒ d
#+end_src

     [Hint: Use list-ref to implement ref and list-tail with set-car! to implement set!.]

**** Exercise 2.9.4

     Scheme supports vectors as well as lists. Like lists, vectors are aggregate objects that contain other
     objects. Unlike lists, vectors have a fixed size and are laid out in one flat block of memory, typically with a
     header containing the length of the vector, as in the ten-element vector below.

#+ATTR_LATEX: :width 200px
[[./images/7.png]]

     This makes vectors more suitable for applications needing fast access to any element of the aggregate but less
     suitable for applications needing data structures that grow and shrink as needed.

     Look up the basic vector operations in Section 6.9 and reimplement the stack object to use a vector instead of a list
     to hold the stack contents. Include the ref and set! messages of Exercise 2.9.3. Have the new make-stack accept a
     size argument n and make the vector length n, but do not otherwise change the external (abstract) interface.

**** Exercise 2.9.5

     Define a predicate, emptyq?, for determining if a queue is empty. Modify getq and delq! to raise an exception when an
     empty queue is found, using assertion-violation.

**** Exercise 2.9.6

     In the queue implementation, the last pair in the encapsulated list is a placeholder, i.e., it never holds anything
     useful. Recode the queue operators to avoid this wasted pair. Make sure that the series of queue operations given
     earlier works with the new implementation. Which implementation do you prefer?

**** Exercise 2.9.7

     Using set-cdr!, it is possible to create cyclic lists. For example, the following expression evaluates to a list
     whose car is the symbol a and whose cdr is the list itself.

#+begin_src scheme
     (let ([ls (cons 'a '())])
       (set-cdr! ls ls)
       ls)
#+end_src

     What happens when you enter the above expression during an interactive Scheme session? What will the implementation
     of length on page 42 do when given a cyclic list? What does the built-in length primitive do?

**** Exercise 2.9.8

     Define the predicate list?, which returns #t if its argument is a proper list and #f otherwise (see Section 6.3). It
     should return #f for cyclic lists as well as for lists terminated by objects other than ().

#+begin_src scheme
     (list? '()) ⇒ #t
     (list? '(1 2 3)) ⇒ #t
     (list? '(a . b)) ⇒ #f
     (list? (let ([ls (cons 'a '())])
              (set-cdr! ls ls)
              ls)) ⇒ #f
#+end_src

     First write a simplified version of list? that does not handle cyclic lists, then extend this to handle cyclic lists
     correctly. Revise your definition until you are satisfied that it is as clear and concise as possible. [Hint: Use the
     following "hare and tortoise" algorithm to detect cycles. Define a recursive help procedure of two arguments, the
     hare and the tortoise. Start both the hare and the tortoise at the beginning of the list. Have the hare advance by
     two cdrs each time the tortoise advances by one cdr. If the hare catches the tortoise, there must be a cycle.]


#+LATEX: \newpage
[[./images/ch3.png]]

** Going Further
   The preceding chapter prepared you to write Scheme programs using a small set of the most useful primitive syntactic
   forms and procedures. This chapter introduces a number of additional features and programming techniques that will
   allow you to write more sophisticated and efficient programs.

*** Syntactic Extension
    As we saw in Section 2.5, the let syntactic form is merely a syntactic extension defined in terms of a lambda
    expression and a procedure application, both core syntactic forms. At this point, you might be wondering which
    syntactic forms are core forms and which are syntactic extensions, and how new syntactic extensions may be
    defined. This section provides some answers to these questions.

    In truth, it is not necessary for us to draw a distinction between core forms and syntactic extensions, since once
    defined, a syntactic extension has exactly the same status as a core form. Drawing a distinction, however, makes
    understanding the language easier, since it allows us to focus attention on the core forms and to understand all
    others in terms of them.

    It is necessary for a Scheme implementation to distinguish between core forms and syntactic extensions. A Scheme
    implementation expands syntactic extensions into core forms as the first step of compilation or interpretation,
    allowing the rest of the compiler or interpreter to focus only on the core forms. The set of core forms remaining
    after expansion to be handled directly by the compiler or interpreter is implementation-dependent, however, and may
    be different from the set of forms described as core here.

    The exact set of syntactic forms making up the core of the language is thus subject to debate, although it must be
    possible to derive all other forms from any set of forms declared to be core forms. The set described here is among
    the simplest for which this constraint is satisfied.

    The core syntactic forms include top-level define forms, constants, variables, procedure applications, quote
    expressions, lambda expressions, if expressions, and set! expressions. The grammar below describes the core syntax of
    Scheme in terms of these definitions and expressions. In the grammar, vertical bars ( | ) separate alternatives, and a
    form followed by an asterisk ( * ) represents zero or more occurrences of the form. <variable> is any Scheme
    identifier. <datum> is any Scheme object, such as a number, list, symbol, or vector. <boolean> is either #t or #f,
    <number> is any number, <character> is any character, and <string> is any string. We have already seen examples of
    numbers, strings, lists, symbols, and booleans. See Chapter 6 or the formal syntax description starting on page 455 for
    more on the object-level syntax of these and other objects.

#+BEGIN_EXAMPLE
    <program>             → <form>*
    <form>                → <definition> | <expression>
    <definition>          → <variable definition> | (begin <definition>*)
    <variable definition> → (define <variable> <expression>)
    <expression>          → <constant>
                          | <variable>
                          | (quote <datum>)
                          | (lambda <formals> <expression> <expression>*)
                          | (if <expression> <expression> <expression>)
                          | (set! <variable> <expression>)
                          | <application>
    <constant>            → <boolean> | <number> | <character> | <string>
    <formals>             → <variable>
                          | (<variable>*)
                          | (<variable> <variable>* . <variable>)
    <application>         → (<expression> <expression>*)
#+END_EXAMPLE

    The grammar is ambiguous in that the syntax for procedure applications conflicts with the syntaxes for quote, lambda,
    if, and set! expressions. In order to qualify as a procedure application, the first <expression> must not be one of
    these keywords, unless the keyword has been redefined or locally bound.

    The "defun" syntax for define given in Section 2.6 is not included in the core, since definitions in that form are
    straightforwardly translated into the simpler define syntax. Similarly, the core syntax for if does not permit the
    alternative to be omitted, as did one example in Section 2.9. An if expression lacking an alternative can be
    translated into the core syntax for if merely by replacing the missing subexpression with an arbitrary constant, such
    as #f.

    A begin that contains only definitions is considered to be a definition in the grammar; this is permitted in order to
    allow syntactic extensions to expand into more than one definition. begin expressions, i.e., begin forms containing
    expressions, are not considered core forms. A begin expression of the form

#+begin_src scheme
    (begin e1 e2 ...)
#+end_src

    is equivalent to the lambda application

#+begin_src scheme
    ((lambda () e1 e2 ...))
#+end_src

    and hence need not be considered core.

    Now that we have established a set of core syntactic forms, let's turn to a discussion of syntactic
    extensions. Syntactic extensions are so called because they extend the syntax of Scheme beyond the core syntax. All
    syntactic extensions in a Scheme program must ultimately be derived from the core forms. One syntactic extension,
    however, may be defined in terms of another syntactic extension, as long as the latter is in some sense "closer" to
    the core syntax. Syntactic forms may appear anywhere an expression or definition is expected, as long as the extended
    form expands into a definition or expression as appropriate.

    Syntactic extensions are defined with define-syntax. define-syntax is similar to define, except that define-syntax
    associates a syntactic transformation procedure, or transformer, with a keyword (such as let), rather than
    associating a value with a variable. Here is how we might define let with define-syntax.

#+begin_src scheme
    (define-syntax let
      (syntax-rules ()
        [(_ ((x e) ...) b1 b2 ...)
         ((lambda (x ...) b1 b2 ...) e ...)]))
#+end_src

    The identifier appearing after define-syntax is the name, or keyword, of the syntactic extension being defined, in
    this case let. The syntax-rules form is an expression that evaluates to a transformer. The item following
    syntax-rules is a list of auxiliary keywords and is nearly always (). An example of an auxiliary keyword is the else
    of cond. (Other examples requiring the use of auxiliary keywords are given in Chapter 8.) Following the list of
    auxiliary keywords is a sequence of one or more rules, or pattern/template pairs. Only one rule appears in our
    definition of let. The pattern part of a rule specifies the form that the input must take, and the template specifies
    to what the input should be transformed.

    The pattern should always be a structured expression whose first element is an underscore ( _ ). (As we will see in
    Chapter 8, the use of _ is only a convention, but it is a good one to follow.) If more than one rule is present, the
    appropriate one is chosen by matching the patterns, in order, against the input during expansion. It is a syntax
    violation if none of the patterns match the input.

    Identifiers other than an underscore or ellipsis appearing within a pattern are pattern variables, unless they are
    listed as auxiliary keywords. Pattern variables match any substructure and are bound to that substructure within the
    corresponding template. The notation pat ... in the pattern allows for zero or more expressions matching the ellipsis
    prototype pat in the input. Similarly, the notation expr ... in the template produces zero or more expressions from
    the ellipsis prototype expr in the output. The number of pats in the input determines the number of exprs in the
    output; in order for this to work, any ellipsis prototype in the template must contain at least one pattern variable
    from an ellipsis prototype in the pattern.

    The single rule in our definition of let should be fairly self-explanatory, but a few points are worth
    mentioning. First, the syntax of let requires that the body contain at least one form; hence, we have specified b1 b2
    ... instead of b ..., which might seem more natural. On the other hand, let does not require that there be at least
    one variable/value pair, so we were able to use, simply, (x e) .... Second, the pattern variables x and e, though
    together within the same prototype in the pattern, are separated in the template; any sort of rearrangement or
    recombination is possible. Finally, the three pattern variables x, e, and b2 that appear in ellipsis prototypes in
    the pattern also appear in ellipsis prototypes in the template. This is not a coincidence; it is a requirement. In
    general, if a pattern variable appears within an ellipsis prototype in the pattern, it cannot appear outside an
    ellipsis prototype in the template.

    The definition of and below is somewhat more complex than the one for ~let~.

#+begin_src scheme
    (define-syntax and
      (syntax-rules ()
        [(_) #t]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (if e1 (and e2 e3 ...) #f)]))
#+end_src

    This definition is recursive and involves more than one rule. Recall that (and) evaluates to #t; the first rule takes
    care of this case. The second and third rules specify the base case and recursion steps of the recursion and together
    translate and expressions with two or more subexpressions into nested if expressions. For example, (and a b c)
    expands first into

#+begin_src scheme
    (if a (and b c) #f)
#+end_src

    then

#+begin_src scheme
    (if a (if b (and c) #f) #f)
#+end_src

    and finally

#+begin_src scheme
    (if a (if b c #f) #f)
#+end_src

    With this expansion, if a and b evaluate to a true value, then the value is the value of c, otherwise #f, as desired.

    The version of and below is simpler but, unfortunately, incorrect.

#+begin_src scheme
    (define-syntax and ; incorrect!
      (syntax-rules ()
        [(_) #t]
        [(_ e1 e2 ...)
         (if e1 (and e2 ...) #f)]))
#+end_src

    The expression

#+begin_src scheme
    (and (not (= x 0)) (/ 1 x))
#+end_src

    should return the value of (/ 1 x) when x is not zero. With the incorrect version of and, the expression expands as
    follows.

#+begin_src scheme
    (if (not (= x 0)) (and (/ 1 x)) #f) →
    (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) →
    (if (not (= x 0)) (if (/ 1 x) #t #f) #f)
#+end_src

    The final answer if x is not zero is #t, not the value of (/ 1 x).

    The definition of or below is similar to the one for and except that a temporary variable must be introduced for each
    intermediate value so that we can both test the value and return it if it is a true value. (A temporary variable is not
    needed for and since there is only one false value, #f.)

#+begin_src scheme
    (define-syntax or
      (syntax-rules ()
        [(_) #f]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (let ([t e1])
           (if t t (or e2 e3 ...)))]))
#+end_src

    Like variables bound by lambda or let, identifiers introduced by a template are lexically scoped, i.e., visible only
    within expressions introduced by the template. Thus, even if one of the expressions e2 e3 ... contains a reference to
    t, the introduced binding for t does not "capture" those references. This is typically accomplished via automatic
    renaming of introduced identifiers.

    As with the simpler version of and given above, the simpler version of or below is incorrect.

#+begin_src scheme
    (define-syntax or ; incorrect!
      (syntax-rules ()
        [(_) #f]
        [(_ e1 e2 ...)
         (let ([t e1])
           (if t t (or e2 ...)))]))
#+end_src

    The reason is more subtle, however, and is the subject of Exercise 3.2.6.

**** Exercise 3.1.1

     Write out the expansion steps necessary to expand

#+begin_src scheme
     (let ([x (memv 'a ls)])
       (and x (memv 'b x)))
#+end_src

    into core forms.

**** Exercise 3.1.2

     Write out the expansion steps necessary to expand

#+begin_src scheme
     (or (memv x '(a b c)) (list x))
#+end_src

     into core forms.

**** Exercise 3.1.3

     ~let*~ is similar to let but evaluates its bindings in sequence. Each of the right-hand-side expressions is within
     the scope of the earlier bindings.

#+begin_src scheme
     (let* ([a 5] [b (+ a a)] [c (+ a b)])
       (list a b c)) → (5 10 15)
#+end_src

     ~let*~ can be implemented as nested let expressions. For example, the ~let*~ expression above is equivalent to the
     nested let expressions below.

#+begin_src scheme
     (let ([a 5])
       (let ([b (+ a a)])
         (let ([c (+ a b)])
           (list a b c)))) → (5 10 15)
#+end_src

     Define ~let*~ with define-syntax.

**** Exercise 3.1.4

     As we saw in Section 2.9, it is legal to omit the third, or alternative, subexpression of an if expression. Doing
     so, however, often leads to confusion. Scheme provides two syntactic forms, when and unless, that may be used in
     place of such "one-armed" if expressions.

#+begin_src scheme
     (when test expr1 expr2 ...)
     (unless test expr1 expr2 ...)
#+end_src

     With both forms, test is evaluated first. For when, if test evaluates to true, the remaining forms are evaluated in
     sequence as if enclosed in an implicit begin expression. If test evaluates to false, the remaining forms are not
     evaluated, and the result is unspecified. unless is similar except that the remaining forms are evaluated only if
     test evaluates to false.

#+begin_src scheme
     (let ([x 3])
       (unless (= x 0) (set! x (+ x 1)))
       (when (= x 4) (set! x (* x 2)))
       x) → 8
#+end_src

     Define when as a syntactic extension in terms of if and begin, and define unless in terms of when.

*** More Recursion
    In Section 2.8, we saw how to define recursive procedures using top-level definitions. Before that, we saw how to
    create local bindings for procedures using let. It is natural to wonder whether a let-bound procedure can be
    recursive. The answer is no, at least not in a straightforward way. If you try to evaluate the expression

#+begin_src scheme
    (let ([sum (lambda (ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5)))
#+end_src

    it will probably raise an exception with a message to the effect that sum is undefined. This is because the variable
    sum is visible only within the body of the let expression and not within the lambda expression whose value is bound
    to sum. We can get around this problem by passing the procedure sum to itself as follows.

#+begin_src scheme
    (let ([sum (lambda (sum ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum sum (cdr ls)))))])
      (sum sum '(1 2 3 4 5))) → 15
#+end_src

    This works and is a clever solution, but there is an easier way, using letrec. Like let, the letrec syntactic form
    includes a set of variable-value pairs, along with a sequence of expressions referred to as the body of the letrec.

#+begin_src scheme
    (letrec ((var expr) ...) body1 body2 ...)
#+end_src

    Unlike let, the variables var ... are visible not only within the body of the letrec but also within expr .... Thus,
    we can rewrite the expression above as follows.

#+begin_src scheme
    (letrec ([sum (lambda (ls)
                    (if (null? ls)
                        0
                        (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5))) → 15
#+end_src

    Using ~letrec~, we can also define mutually recursive procedures, such as the procedures ~even?~ and ~odd?~ that were
    the subject of Exercise 2.8.6.

#+begin_src scheme
    (letrec ([even?
              (lambda (x)
                (or (= x 0)
                    (odd? (- x 1))))]
             [odd?
              (lambda (x)
                (and (not (= x 0))
                     (even? (- x 1))))])
      (list (even? 20) (odd? 20))) → (#t #f)
#+end_src

    In a letrec expression, expr ... are most often lambda expressions, though this need not be the case. One restriction
    on the expressions must be obeyed, however. It must be possible to evaluate each expr without evaluating any of the
    variables var .... This restriction is always satisfied if the expressions are all lambda expressions, since even
    though the variables may appear within the lambda expressions, they cannot be evaluated until the resulting
    procedures are invoked in the body of the letrec. The following letrec expression obeys this restriction.

#+begin_src scheme
    (letrec ([f (lambda () (+ x 2))]
             [x 1])
      (f)) → 3
#+end_src

    while the following does not.

#+begin_src scheme
    (letrec ([y (+ x 2)]
             [x 1])
      y)
#+end_src

    In this case, an exception is raised indicating that x is not defined where it is referenced.

    We can use letrec to hide the definitions of "help" procedures so that they do not clutter the top-level
    namespace. This is demonstrated by the definition of list? below, which follows the "hare and tortoise" algorithm
    outlined in Exercise 2.9.8.

#+begin_src scheme
    (define list?
      (lambda (x)
        (letrec ([race
                  (lambda (h t)
                    (if (pair? h)
                        (let ([h (cdr h)])
                          (if (pair? h)
                              (and (not (eq? h t))
                                   (race (cdr h) (cdr t)))
                              (null? h)))
                        (null? h)))])
          (race x x))))
#+end_src

    When a recursive procedure is called in only one place outside the procedure, as in the example above, it is often
    clearer to use a named let expression. Named let expressions take the following form.

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    Named let is similar to unnamed let in that it binds the variables var ... to the values of expr ... within the body
    body1 body2 .... As with unnamed let, the variables are visible only within the body and not within expr .... In
    addition, the variable name is bound within the body to a procedure that may be called to recur; the arguments to the
    procedure become the new values for the variables var ....

    The definition of ~list?~ has been rewritten below to use named ~let~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (let race ([h x] [t x])
          (if (pair? h)
              (let ([h (cdr h)])
                (if (pair? h)
                    (and (not (eq? h t))
                         (race (cdr h) (cdr t)))
                    (null? h)))
              (null? h)))))
#+end_src

    Just as let can be expressed as a simple direct application of a lambda expression to arguments, named let can be
    expressed as the application of a recursive procedure to arguments. A named let of the form

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    can be rewritten in terms of letrec as follows.

#+begin_src scheme
    ((letrec ((name (lambda (var ...) body1 body2 ...)))
       name)
     expr ...)
#+end_src

    Alternatively, it can be rewritten as

#+begin_src scheme
    (letrec ((name (lambda (var ...) body1 body2 ...)))
      (name expr ...))
#+end_src

    provided that the variable name does not appear free within expr ....

    As we discussed in Section 2.8, some recursion is essentially iteration and executes as such. When a procedure call
    is in tail position (see below) with respect to a lambda expression, it is considered to be a tail call, and Scheme
    systems must treat it properly, as a "goto" or jump. When a procedure tail-calls itself or calls itself indirectly
    through a series of tail calls, the result is tail recursion. Because tail calls are treated as jumps, tail recursion
    can be used for indefinite iteration in place of the more restrictive iteration constructs provided by other
    programming languages, without fear of overflowing any sort of recursion stack.

    A call is in tail position with respect to a lambda expression if its value is returned directly from the lambda
    expression, i.e., if nothing is left to do after the call but to return from the lambda expression. For example, a
    call is in tail position if it is the last expression in the body of a lambda expression, the consequent or
    alternative part of an if expression in tail position, the last subexpression of an and or or expression in tail
    position, the last expression in the body of a let or letrec in tail position, etc. Each of the calls to f in the
    expressions below are tail calls, but the calls to g are not.

#+begin_src scheme
    (lambda () (f (g)))
    (lambda () (if (g) (f) (f)))
    (lambda () (let ([x 4]) (f)))
    (lambda () (or (g) (f)))
#+end_src

    In each case, the values of the calls to f are returned directly, whereas the calls to g are not.

    Recursion in general and named let in particular provide a natural way to implement many algorithms, whether
    iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct
    mechanisms.

    The following two definitions of factorial use named let expressions to compute the factorial, n!, of a nonnegative
    integer n. The first employs the recursive definition n! = n × (n - 1)!, where 0! is defined to be 1.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n])
          (if (= i 0)
              1
              (* i (fact (- i 1)))))))

    (factorial 0) → 1
    (factorial 1) → 1
    (factorial 2) → 2
    (factorial 3) → 6
    (factorial 10) → 3628800
#+end_src

    The second is an iterative version that employs the iterative definition ~n! = n × (n - 1) × (n - 2) × ... × 1~,
    using an accumulator, a, to hold the intermediate products.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n] [a 1])
          (if (= i 0)
              a
              (fact (- i 1) (* a i))))))
#+end_src

    A similar problem is to compute the nth Fibonacci number for a given n. The Fibonacci numbers are an infinite
    sequence of integers, 0, 1, 1, 2, 3, 5, 8, etc., in which each number is the sum of the two preceding numbers in the
    sequence. A procedure to compute the nth Fibonacci number is most naturally defined recursively as follows.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (let fib ([i n])
          (cond
            [(= i 0) 0]
            [(= i 1) 1]
            [else (+ (fib (- i 1)) (fib (- i 2)))]))))

    (fibonacci 0) → 0
    (fibonacci 1) → 1
    (fibonacci 2) → 1
    (fibonacci 3) → 2
    (fibonacci 4) → 3
    (fibonacci 5) → 5
    (fibonacci 6) → 8
    (fibonacci 20) → 6765
    (fibonacci 30) → 832040
#+end_src

    This solution requires the computation of the two preceding Fibonacci numbers at each step and hence is doubly
    recursive. For example, to compute (fibonacci 4) requires the computation of both (fib 3) and (fib 2), to compute
    (fib 3) requires computing both (fib 2) and (fib 1), and to compute (fib 2) requires computing both (fib 1) and (fib
    0). This is very inefficient, and it becomes more inefficient as n grows. A more efficient solution is to adapt the
    accumulator solution of the factorial example above to use two accumulators, a1 for the current Fibonacci number and
    a2 for the preceding one.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (if (= n 0)
            0
            (let fib ([i n] [a1 1] [a2 0])
              (if (= i 1)
                  a1
                  (fib (- i 1) (+ a1 a2) a1))))))
#+end_src

    Here, zero is treated as a special case, since there is no preceding value. This allows us to use the single base
    case (= i 1). The time it takes to compute the nth Fibonacci number using this iterative solution grows linearly with
    n, which makes a significant difference when compared to the doubly recursive version. To get a feel for the
    difference, try computing (fibonacci 35) and (fibonacci 40) using both definitions to see how long each takes.

    We can also get a feel for the difference by looking at a trace for each on small inputs. The first trace below shows
    the calls to fib in the non-tail-recursive version of fibonacci, with input 5.

#+BEGIN_EXAMPLE
    |(fib 5)
    | (fib 4)
    | |(fib 3)
    | | (fib 2)
    | | |(fib 1)
    | | |1
    | | |(fib 0)
    | | |0
    | | 1
    | | (fib 1)
    | | 1
    | |2
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | 3
    | (fib 3)
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | |(fib 1)
    | |1
    | 2
    |5
#+END_EXAMPLE

    Notice how there are several calls to fib with arguments 2, 1, and 0. The second trace shows the calls to fib in the
    tail-recursive version, again with input 5.

#+BEGIN_EXAMPLE
    |(fib 5 1 0)
    |(fib 4 1 1)
    |(fib 3 2 1)
    |(fib 2 3 2)
    |(fib 1 5 3)
    |5
#+END_EXAMPLE

    Clearly, there is quite a difference.

    The named let examples shown so far are either tail-recursive or not tail-recursive. It often happens that one
    recursive call within the same expression is tail-recursive while another is not. The definition of factor below
    computes the prime factors of its nonnegative integer argument. The first call to f is not tail-recursive, but the
    second one is.

#+begin_src scheme
    (define factor
      (lambda (n)
        (let f ([n n] [i 2])
          (cond
            [(>= i n) (list n)]
            [(integer? (/ n i))
             (cons i (f (/ n i) i))]
            [else (f n (+ i 1))]))))
#+end_src

#+begin_src scheme
    (factor 0) → (0)
    (factor 1) → (1)
    (factor 12) → (2 2 3)
    (factor 3628800) → (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
    (factor 9239) → (9239)
#+end_src

    A trace of the calls to f, produced in Chez Scheme by replacing let with trace-let, in the evaluation of (factor 120)
    below highlights the difference between the nontail calls and the tail calls.

#+BEGIN_EXAMPLE
    |(f 120 2)
    | (f 60 2)
    | |(f 30 2)
    | | (f 15 2)
    | | (f 15 3)
    | | |(f 5 3)
    | | |(f 5 4)
    | | |(f 5 5)
    | | |(5)
    | | (3 5)
    | |(2 3 5)
    | (2 2 3 5)
    |(2 2 2 3 5)
#+END_EXAMPLE

    A nontail call to f is shown indented relative to its caller, since the caller is still active, whereas tail calls
    appear at the same level of indentation.

**** Exercise 3.2.1

     Which of the recursive procedures defined in Section 3.2 are tail-recursive, and which are not?

**** Exercise 3.2.2

     Rewrite factor using letrec to bind f in place of named let. Which version do you prefer?

**** Exercise 3.2.3

     Can the letrec expression below be rewritten using named let? If not, why not? If so, do it.

#+begin_src scheme
     (letrec ([even?
               (lambda (x)
                 (or (= x 0)
                     (odd? (- x 1))))]
              [odd?
               (lambda (x)
                 (and (not (= x 0))
                      (even? (- x 1))))])
       (even? 20))
#+end_src

**** Exercise 3.2.4

     Rewrite both definitions of fibonacci given in this section to count the number of recursive calls to fib, using a
     counter similar to the one used in the cons-count example of Section 2.9. Count the number of recursive calls made in
     each case for several input values. What do you notice?

**** Exercise 3.2.5

     Augment the definition of let given in Section 3.1 to handle named let as well as unnamed let, using two rules.

**** Exercise 3.2.6

     The following definition of or is simpler than the one given in Section 3.1.

#+begin_src scheme
     (define-syntax or ; incorrect!
       (syntax-rules ()
         [(_) #f]
         [(_ e1 e2 ...)
          (let ([t e1])
            (if t t (or e2 ...)))]))
#+end_src

     Say why it is not correct. [Hint: Think about what would happen if this version of or were used in the even? and
     odd? example given on page 66 for very large inputs.]

**** Exercise 3.2.7

     The definition of factor is not the most efficient possible. First, no factors of n besides n itself can possibly be
     found beyond →. Second, the division (/ n i) is performed twice when a factor is found. Third, after 2, no even
     factors can possibly be found. Recode factor to correct all three problems. Which is the most important problem to
     solve? Are there any additional improvements you can make?

*** Continuations

    During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate
    and (2) what to do with the value. Consider the evaluation of (null? x) within the expression below.

#+begin_src scheme
    (if (null? x) (quote ()) (cdr x))
#+end_src

    The implementation must first evaluate (null? x) and, based on its value, evaluate either (quote ()) or (cdr
    x). "What to evaluate" is (null? x), and "what to do with the value" is to make the decision which of (quote ()) and
    (cdr x) to evaluate and to do so. We call "what to do with the value" the continuation of a computation.

    Thus, at any point during the evaluation of any expression, there is a continuation ready to complete, or at least
    continue, the computation from that point. Let's assume that x has the value (a b c). We can isolate six
    continuations during the evaluation of (if (null? x) (quote ()) (cdr x)), the continuations waiting for

    1. the value of (if (null? x) (quote ()) (cdr x)),
    2. the value of (null? x),
    3. the value of null?,
    4. the value of x,
    5. the value of cdr, and
    6. the value of x (again).

    The continuation of ~(cdr x)~ is not listed because it is the same as the one waiting for ~(if (null? x) (quote ())
    (cdr x))~.

    Scheme allows the continuation of any expression to be captured with the procedure call/cc. call/cc must be passed a
    procedure p of one argument. call/cc constructs a concrete representation of the current continuation and passes it
    to p. The continuation itself is represented by a procedure k. Each time k is applied to a value, it returns the
    value to the continuation of the call/cc application. This value becomes, in essence, the value of the application of
    call/cc.

    If p returns without invoking k, the value returned by the procedure becomes the value of the application of call/cc.

    Consider the simple examples below.

#+begin_src scheme
    (call/cc
      (lambda (k)
        (* 5 4))) → 20

    (call/cc
      (lambda (k)
        (* 5 (k 4)))) → 4

    (+ 2
       (call/cc
         (lambda (k)
           (* 5 (k 4))))) → 6
#+end_src

    In the first example, the continuation is captured and bound to k, but k is never used, so the value is simply the
    product of 5 and 4. In the second, the continuation is invoked before the multiplication, so the value is the value
    passed to the continuation, 4. In the third, the continuation includes the addition by 2; thus, the value is the
    value passed to the continuation, 4, plus 2.

    Here is a less trivial example, showing the use of call/cc to provide a nonlocal exit from a recursion.

#+begin_src scheme
    (define product
      (lambda (ls)
        (call/cc
          (lambda (break)
            (let f ([ls ls])
              (cond
                [(null? ls) 1]
                [(= (car ls) 0) (break 0)]
                [else (* (car ls) (f (cdr ls)))]))))))

    (product '(1 2 3 4 5)) → 120
    (product '(7 3 8 0 1 9 5)) → 0
#+end_src

    The nonlocal exit allows product to return immediately, without performing the pending multiplications, when a zero
    value is detected.

    Each of the continuation invocations above returns to the continuation while control remains within the procedure
    passed to call/cc. The following example uses the continuation after this procedure has already returned.

#+begin_src scheme
    (let ([x (call/cc (lambda (k) k))])
      (x (lambda (ignore) "hi"))) → "hi"
#+end_src

    The continuation captured by this invocation of call/cc may be described as "Take the value, bind it to x, and apply
    the value of x to the value of (lambda (ignore) "hi")." Since (lambda (k) k) returns its argument, x is bound to the
    continuation itself; this continuation is applied to the procedure resulting from the evaluation of (lambda (ignore)
    "hi"). This has the effect of binding x (again!) to this procedure and applying the procedure to itself. The
    procedure ignores its argument and returns "hi".

    The following variation of the example above is probably the most confusing Scheme program of its size; it might be
    easy to guess what it returns, but it takes some thought to figure out why.

#+begin_src scheme
    (((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") → "HEY!"
#+end_src

    The value of the call/cc is its own continuation, as in the preceding example. This is applied to the identity
    procedure (lambda (x) x), so the call/cc returns a second time with this value. Then, the identity procedure is
    applied to itself, yielding the identity procedure. This is finally applied to "HEY!", yielding "HEY!".

    Continuations used in this manner are not always so puzzling. Consider the following definition of factorial that
    saves the continuation at the base of the recursion before returning 1, by assigning the top-level variable retry.

#+begin_src scheme
    (define retry #f)

    (define factorial
      (lambda (x)
        (if (= x 0)
            (call/cc (lambda (k) (set! retry k) 1))
            (* x (factorial (- x 1))))))
#+end_src

    With this definition, factorial works as we expect factorial to work, except it has the side effect of assigning
    retry.

#+begin_src scheme
    (factorial 4) → 24
    (retry 1) → 24
    (retry 2) → 48
#+end_src

    The continuation bound to retry might be described as "Multiply the value by 1, then multiply this result by 2, then
    multiply this result by 3, then multiply this result by 4." If we pass the continuation a different value, i.e., not
    1, we will cause the base value to be something other than 1 and hence change the end result.

#+begin_src scheme
    (retry 2) → 48
    (retry 5) → 120
#+end_src

    This mechanism could be the basis for a breakpoint package implemented with call/cc; each time a breakpoint is
    encountered, the continuation of the breakpoint is saved so that the computation may be restarted from the breakpoint
    (more than once, if desired).

    Continuations may be used to implement various forms of multitasking. The simple "light-weight process" mechanism
    defined below allows multiple computations to be interleaved. Since it is nonpreemptive, it requires that each
    process voluntarily "pause" from time to time in order to allow the others to run.

#+begin_src scheme
    (define lwp-list '())
    (define lwp
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))

    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))

    (define pause
      (lambda ()
        (call/cc
          (lambda (k)
            (lwp (lambda () (k #f)))
            (start)))))
#+end_src

    The following light-weight processes cooperate to print an infinite sequence of lines containing "hey!".

#+begin_src scheme
    (lwp (lambda () (let f () (pause) (display "h") (f))))
    (lwp (lambda () (let f () (pause) (display "e") (f))))
    (lwp (lambda () (let f () (pause) (display "y") (f))))
    (lwp (lambda () (let f () (pause) (display "!") (f))))
    (lwp (lambda () (let f () (pause) (newline) (f))))
    (start) → hey!
              hey!
              hey!
              hey!
              ...
#+end_src

    See Section 12.11 for an implementation of engines, which support preemptive multitasking, with call/cc.

**** Exercise 3.3.1

     Use call/cc to write a program that loops indefinitely, printing a sequence of numbers beginning at zero. Do not use
     any recursive procedures, and do not use any assignments.

**** Exercise 3.3.2

     Rewrite product without call/cc, retaining the feature that no multiplications are performed if any of the list
     elements are zero.

**** Exercise 3.3.3

     What would happen if a process created by lwp as defined above were to terminate, i.e., simply return without
     calling pause? Define a quit procedure that allows a process to terminate without otherwise affecting the lwp
     system. Be sure to handle the case in which the only remaining process terminates.

**** Exercise 3.3.4

     Each time lwp is called, the list of processes is copied because lwp uses append to add its argument to the end of
     the process list. Modify the original lwp code to use the queue data type developed in Section 2.9 to avoid this
     problem.

**** Exercise 3.3.5

     The light-weight process mechanism allows new processes to be created dynamically, although the example given in
     this section does not do so. Design an application that requires new processes to be created dynamically and
     implement it using the light-weight process mechanism.

*** Continuation Passing Style

    As we discussed in the preceding section, a continuation waits for the value of each expression. In particular, a
    continuation is associated with each procedure call. When one procedure invokes another via a nontail call, the
    called procedure receives an implicit continuation that is responsible for completing what is left of the calling
    procedure's body plus returning to the calling procedure's continuation. If the call is a tail call, the called
    procedure simply receives the continuation of the calling procedure.

    We can make the continuations explicit by encapsulating "what to do" in an explicit procedural argument passed along
    on each call. For example, the continuation of the call to f in

#+begin_src scheme
    (letrec ([f (lambda (x) (cons 'a x))]
             [g (lambda (x) (cons 'b (f x)))]
             [h (lambda (x) (g (cons 'c x)))])
      (cons 'd (h '()))) → (d b a c)
#+end_src

    conses the symbol b onto the value returned to it, then returns the result of this cons to the continuation of the
    call to g. This continuation is the same as the continuation of the call to h, which conses the symbol d onto the
    value returned to it. We can rewrite this in continuation-passing style, or CPS, by replacing these implicit
    continuations with explicit procedures.

#+begin_src scheme
    (letrec ([f (lambda (x k) (k (cons 'a x)))]
             [g (lambda (x k)
                  (f x (lambda (v) (k (cons 'b v)))))]
             [h (lambda (x k) (g (cons 'c x) k))])
      (h '() (lambda (v) (cons 'd v))))
#+end_src

    Like the implicit continuation of h and g in the preceding example, the explicit continuation passed to h and on to
    g,

#+begin_src scheme
    (lambda (v) (cons 'd v))
#+end_src

    conses the symbol d onto the value passed to it. Similarly, the continuation passed to f,

#+begin_src scheme
    (lambda (v) (k (cons 'b v)))
#+end_src

    conses b onto the value passed to it, then passes this on to the continuation of g.

    Expressions written in CPS are more complicated, of course, but this style of programming has some useful
    applications. CPS allows a procedure to pass more than one result to its continuation, because the procedure that
    implements the continuation can take any number of arguments.

#+begin_src scheme
    (define car&cdr
      (lambda (p k)
        (k (car p) (cdr p))))

    (car&cdr '(a b c)
      (lambda (x y)
        (list y x))) → ((b c) a)
    (car&cdr '(a b c) cons) → (a b c)
    (car&cdr '(a b c a d) memv) → (a d)
#+end_src

    (This can be done with multiple values as well; see Section 5.8.) CPS also allows a procedure to take separate
    "success" and "failure" continuations, which may accept different numbers of arguments. An example is integer-divide
    below, which passes the quotient and remainder of its first two arguments to its third, unless the second argument
    (the divisor) is zero, in which case it passes an error message to its fourth argument.

#+begin_src scheme
    (define integer-divide
      (lambda (x y success failure)
        (if (= y 0)
            (failure "divide by zero")
            (let ([q (quotient x y)])
              (success q (- x (* q y)))))))

    (integer-divide 10 3 list (lambda (x) x)) → (3 1)
    (integer-divide 10 0 list (lambda (x) x)) → "divide by zero"
#+end_src

    The procedure quotient, employed by integer-divide, returns the quotient of its two arguments, truncated toward
    zero.

    Explicit success and failure continuations can sometimes help to avoid the extra communication necessary to separate
    successful execution of a procedure from unsuccessful execution. Furthermore, it is possible to have multiple success
    or failure continuations for different flavors of success or failure, each possibly taking different numbers and
    types of arguments. See Sections 12.10 and 12.11 for extended examples that employ continuation-passing style.

    At this point you might be wondering about the relationship between CPS and the continuations captured via
    call/cc. It turns out that any program that uses call/cc can be rewritten in CPS without call/cc, but a total rewrite
    of the program (sometimes including even system-defined primitives) might be necessary. Try to convert the product
    example on page 75 into CPS before looking at the version below.

#+begin_src scheme
    (define product
      (lambda (ls k)
        (let ([break k])
          (let f ([ls ls] [k k])
            (cond
              [(null? ls) (k 1)]
              [(= (car ls) 0) (break 0)]
              [else (f (cdr ls)
                       (lambda (x)
                         (k (* (car ls) x))))])))))

    (product '(1 2 3 4 5) (lambda (x) x)) → 120
    (product '(7 3 8 0 1 9 5) (lambda (x) x)) → 0
#+end_src

**** Exercise 3.4.1

     Rewrite the reciprocal example first given in Section 2.1 to accept both success and failure continuations, like
     integer-divide above.

**** Exercise 3.4.2

     Rewrite the retry example from page 75 to use CPS.

**** Exercise 3.4.3

     Rewrite the following expression in CPS to avoid using call/cc.

#+begin_src scheme
     (define reciprocals
       (lambda (ls)
         (call/cc
           (lambda (k)
             (map (lambda (x)
                    (if (= x 0)
                        (k "zero found")
                        (/ 1 x)))
                  ls)))))

     (reciprocals '(2 1/3 5 1/4)) → (1/2 3 1/5 4)
     (reciprocals '(2 1/3 0 5 1/4)) → "zero found"
#+end_src

*** Internal Definitions

    In Section 2.6, we discussed top-level definitions. Definitions may also appear at the front of a lambda, let, or
    letrec body, in which case the bindings they create are local to the body.

#+begin_src scheme
    (define f (lambda (x) (* x x)))
    (let ([x 3])
      (define f (lambda (y) (+ y x)))
      (f 4)) → 7
    (f 4) → 16
#+end_src

    Procedures bound by internal definitions can be mutually recursive, as with letrec. For example, we can rewrite the
    even? and odd? example from Section 3.2 using internal definitions as follows.

#+begin_src scheme
    (let ()
      (define even?
        (lambda (x)
          (or (= x 0)
              (odd? (- x 1)))))
      (define odd?
        (lambda (x)
          (and (not (= x 0))
               (even? (- x 1)))))
      (even? 20)) → #t
#+end_src

    Similarly, we can replace the use of letrec to bind race with an internal definition of race in our first definition
    of list?.

#+begin_src scheme
    (define list?
      (lambda (x)
        (define race
          (lambda (h t)
            (if (pair? h)
                (let ([h (cdr h)])
                  (if (pair? h)
                      (and (not (eq? h t))
                           (race (cdr h) (cdr t)))
                      (null? h)))
                (null? h))))
        (race x x)))
#+end_src

    In fact, internal variable definitions and letrec are practically interchangeable. The only difference, other than
    the obvious difference in syntax, is that variable definitions are guaranteed to be evaluated from left to right,
    while the bindings of a letrec may be evaluated in any order. So we cannot quite replace a lambda, let, or letrec
    body containing internal definitions with a letrec expression. We can, however, use letrec*, which, like let*,
    guarantees left-to-right evaluation order. A body of the form

#+begin_src scheme
    (define var expr0)
    ...
    expr1
    expr2
    ...
#+end_src

    is equivalent to a letrec* expression binding the defined variables to the associated values in a body comprising the
    expressions.

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    Conversely, a letrec* of the form

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    can be replaced with a let expression containing internal definitions and the expressions from the body as follows.

#+begin_src scheme
    (let ()
      (define var expr0)
      ...
      expr1
      expr2
      ...
    )
#+end_src

    The seeming lack of symmetry between these transformations is due to the fact that letrec* expressions can appear
    anywhere an expression is valid, whereas internal definitions can appear only at the front of a body. Thus, in
    replacing a letrec* with internal definitions, we must generally introduce a let expression to hold the definitions.

    Another difference between internal definitions and letrec or letrec* is that syntax definitions may appear among the
    internal definitions, while letrec and letrec* bind only variables.

#+begin_src scheme
    (let ([x 3])
      (define-syntax set-x!
        (syntax-rules ()
          [(_ e) (set! x e)]))
      (set-x! (+ x x))
      x) → 6
#+end_src

    The scope of a syntactic extension established by an internal syntax definition, as with an internal variable
    definition, is limited to the body in which the syntax definition appears.

    Internal definitions may be used in conjunction with top-level definitions and assignments to help modularize
    programs. Each module of a program should make visible only those bindings that are needed by other modules, while
    hiding other bindings that would otherwise clutter the top-level namespace and possibly result in unintended use or
    redefinition of those bindings. A common way of structuring a module is shown below.

#+begin_src scheme
    (define export-var #f)
     ...
    (let ()
      (define var expr)
       ...
      init-expr
       ...
      (set! export-var export-val)
       ...
    )
#+end_src

    The first set of definitions establish top-level bindings for the variables we desire to export (make visible
    globally). The second set of definitions establish local bindings visible only within the module. The expressions
    init-expr ... perform any initialization that must occur after the local bindings have been established. Finally, the
    set! expressions assign the exported variables to the appropriate values.

    An advantage of this form of modularization is that the bracketing let expression may be removed or "commented out"
    during program development, making the internal definitions top-level to facilitate interactive testing. This form of
    modularization also has several disadvantages, as we discuss in the next section.

    The following module exports a single variable, calc, which is bound to a procedure that implements a simple
    four-function calculator.

#+begin_src scheme
    (define calc #f)
    (let ()
      (define do-calc
        (lambda (ek expr)
          (cond
            [(number? expr) expr]
            [(and (list? expr) (= (length expr) 3))
             (let ([op (car expr)] [args (cdr expr)])
               (case op
                 [(add) (apply-op ek + args)]
                 [(sub) (apply-op ek - args)]
                 [(mul) (apply-op ek * args)]
                 [(div) (apply-op ek / args)]
                 [else (complain ek "invalid operator" op)]))]
            [else (complain ek "invalid expression" expr)])))
      (define apply-op
        (lambda (ek op args)
          (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
      (define complain
        (lambda (ek msg expr)
          (ek (list msg expr))))
      (set! calc
        (lambda (expr)
          ; grab an error continuation ek
          (call/cc
            (lambda (ek)
              (do-calc ek expr))))))

    (calc '(add (mul 3 2) -4)) → 2
    (calc '(div 1/2 1/6)) → 3
    (calc '(add (mul 3 2) (div 4))) → ("invalid expression" (div 4))
    (calc '(mul (add 1 -2) (pow 2 7))) → ("invalid operator" pow)
#+end_src

    This example uses a case expression to determine which operator to apply. case is similar to cond except that the
    test is always the same: (memv val (key ...)), where val is the value of the first case subform and (key ...) is the
    list of items at the front of each case clause. The case expression in the example above could be rewritten using
    cond as follows.

#+begin_src scheme
    (let ([temp op])
      (cond
        [(memv temp '(add)) (apply-op ek + args)]
        [(memv temp '(sub)) (apply-op ek - args)]
        [(memv temp '(mul)) (apply-op ek * args)]
        [(memv temp '(div)) (apply-op ek / args)]
        [else (complain ek "invalid operator" op)]))
#+end_src

**** Exercise 3.5.1

     Redefine complain in the calc example as an equivalent syntactic extension.

**** Exercise 3.5.2

     In the calc example, the error continuation ek is passed along on each call to apply-op, complain, and do-calc. Move
     the definitions of apply-op, complain, and do-calc inward as far as necessary to eliminate the ek argument from the
     definitions and applications of these procedures.

**** Exercise 3.5.3

     Eliminate the call/cc from calc and rewrite complain to raise an exception using assertion-violation.

**** Exercise 3.5.4

     Extend calc to handle unary minus expressions, e.g.,

     (calc '(minus (add 2 3))) → -5

     and other operators of your choice.

*** Libraries

    At the end of the preceding section, we discussed a form of modularization that involves assigning a set of top-level
    variables from within a let while keeping unpublished helpers local to the let. This form of modularization has
    several drawbacks:

    * It is unportable, because the behavior and even existence of an interactive top level is not guaranteed by the
      Revised6 Report.
    * It requires assignments, which make the code appear somewhat awkward and may inhibit compiler analyses and
      optimizations.
    * It does not support the publication of keyword bindings, since there is no analogue to set! for keywords.

    An alternative that does not share these drawbacks is to create a library. A library exports a set of identifiers,
    each defined within the library or imported from some other library. An exported identifier need not be bound as a
    variable; it may be bound as a keyword instead.

    The following library exports two identifiers: the variable gpa->grade and the keyword gpa. The variable gpa->grade
    is bound to a procedure that takes a grade-point average (GPA), represented as a number, and returns the
    corresponding letter grade, based on a four-point scale. The keyword gpa names a syntactic extension whose subforms
    must all be letter grades and whose value is the GPA computed from those letter grades.

#+begin_src scheme
    (library (grades)
      (export gpa->grade gpa)
      (import (rnrs))

      (define in-range?
        (lambda (x n y)
          (and (>= n x) (< n y))))

      (define-syntax range-case
        (syntax-rules (- else)
          [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...
               [else ee1 ee2 ...]))]
          [(_ expr ((x - y) e1 e2 ...) ...)
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...))]))

      (define letter->number
        (lambda (x)
          (case x
            [(a)  4.0]
            [(b)  3.0]
            [(c)  2.0]
            [(d)  1.0]
            [(f)  0.0]
            [else (assertion-violation 'grade "invalid letter grade" x)])))

      (define gpa->grade
        (lambda (x)
          (range-case x
            [(0.0 - 0.5) 'f]
            [(0.5 - 1.5) 'd]
            [(1.5 - 2.5) 'c]
            [(2.5 - 3.5) 'b]
            [else 'a])))

      (define-syntax gpa
        (syntax-rules ()
          [(_ g1 g2 ...)
           (let ([ls (map letter->number '(g1 g2 ...))])
             (/ (apply + ls) (length ls)))])))
#+end_src

    The name of the library is (grades). This may seem like a funny kind of name, but all library names are
    parenthesized. The library imports from the standard (rnrs) library, which contains most of the primitive and keyword
    bindings we have used in this chapter and the last, and everything we need to implement gpa->grade and gpa.

    Along with gpa->grade and gpa, several other syntactic extensions and procedures are defined within the library, but
    none of the others are exported. The ones that aren't exported are simply helpers for the ones that are. Everything
    used within the library should be familiar, except for the apply procedure, which is described on page 107.

    If your Scheme implementation supports import in the interactive top level, you can test the two exports as shown
    below.

#+begin_src scheme
    (import (grades))
    (gpa c a c b b) → 2.8
    (gpa->grade 2.8) → b
#+end_src

    Chapter 10 describes libraries in more detail and provides additional examples of their use.

**** Exercise 3.6.1

     Modify gpa to handle "x" grades, which do not count in the grade-point average. Be careful to handle gracefully the
     situation where each grade is x.

#+begin_src scheme
     (import (grades))
     (gpa a x b c) → 3.0
#+end_src

**** Exercise 3.6.2

     Export from (grades) a new syntactic form, distribution, that takes a set of grades, like gpa, but returns a list of
     the form ((n g) ...), where n is the number of times g appears in the set, with one entry for each g. Have
     distribution call an unexported procedure to do the actual work.

#+begin_src scheme
     (import (grades))
     (distribution a b a c c c a f b a) → ((4 a) (2 b) (3 c) (0 d) (1 f))
#+end_src

**** Exercise 3.6.3

     Now read about output operations in Section 7.8 and define a new export, histogram, as a procedure that takes a
     textual output port and a distribution, such as might be produced by distribution, and prints a histogram in the
     style illustrated by the example below.

#+begin_src scheme
     (import (grades))
     (histogram
       (current-output-port)
       (distribution a b a c c a c a f b a))
#+end_src

     prints:

#+BEGIN_EXAMPLE
   a: *****
   b: **
   c: ***
   d:
   f: *
#+END_EXAMPLE


#+LATEX: \newpage
[[./images/ch4.png]]

** Procedures and Variable Bindings
*** Variable References
*** Lambda
*** Case-Lambda
*** Local Binding
*** Multiple Values
*** Variable Definitions
*** Assignment



#+LATEX: \newpage
[[./images/ch5.png]]

** Control Operations
*** Procedure Application
*** Sequencing
*** Conditionals
*** Recursion and Iteration
*** Mapping and Folding
*** Continuations
*** Delayed Evaluation
*** Multiple Values
*** Eval

#+LATEX: \newpage
[[./images/ch6.png]]

** Operations on Objects
*** Constants and Quotation
*** Generic Equivalence and Type Predicates
*** Lists and Pairs
*** Numbers
*** Fixnums
*** Flonums
*** Characters
*** Strings
*** Vectors
*** Bytevectors
*** Symbols
*** Booleans
*** Hashtables
*** Enumerations

#+LATEX: \newpage
[[./images/ch7.png]]

** Input and Output
*** Transcoders
*** Opening Files
*** Standard Ports
*** String and Bytevector Ports
*** Opening Custom Ports
*** Port Operations
*** Input Operations
*** Output Operations
*** Convenience I/O
*** Filesystem Operations
*** Bytevector/String Conversions

#+LATEX: \newpage
[[./images/ch8.png]]

** Syntactic Extension
*** Keyword Bindings
*** Syntax-Rules Transformers
*** Syntax-Case Transformers
*** Examples

#+LATEX: \newpage
[[./images/ch9.png]]

** Records
*** Defining Records
*** Procedural Interface
*** Inspection

#+LATEX: \newpage
[[./images/ch10.png]]

** Libraries and Top-Level Programs
*** Standard Libraries
*** Defining New Libraries
*** Top-Level Programs
*** Examples

#+LATEX: \newpage
[[./images/ch11.png]]

** Exceptions and Conditions
*** Raising and Handling Exceptions
*** Defining Condition Types
*** Standard Condition Types

#+LATEX: \newpage
[[./images/ch12.png]]

** Extended Examples
*** Matrix and Vector Multiplication
*** Sorting
*** A Set Constructor
*** Word Frequency Counting
*** Scheme Printer
*** Formatted Output
*** A Meta-Circular Interpreter for Scheme
*** Defining Abstract Objects
*** Fast Fourier Transform
*** A Unification Algorithm
*** Multitasking with Engines

#+LATEX: \newpage
** Ответы к заданиям

#+LATEX: \newpage
* Формальный синтаксис

#+LATEX: \newpage
* Таблица синтаксических форм

#+LATEX: \newpage
* Предметный указатель


#+LATEX: \newpage
* Footnotes

[fn:1] Michael Adams and R. Kent Dybvig. Efficient nondestructive equality checking for trees and graphs. In Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming, 179-188, September 2008.

[fn:2] J. Michael Ashley and R. Kent Dybvig. An efficient implementation of multiple return values in Scheme. In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, 140-149, June 1994.

[fn:3] Alan Bawden. Quasiquotation in lisp. In Partial Evaluation and Semantic-Based Program Manipulation, 88-99, 1999.

[fn:4] William Briggs and Van Emden Henson. The DFT: An Owner's Manual for the Discrete Fourier Transform. Society for Industrial and Applied Mathematics, Philadelphia, PA, 1995.

[fn:5] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, 108-116, May 1996.

[fn:6] William F. Clocksin and Christopher S. Mellish. Programming in Prolog, second edition. Springer-Verlag, Berlin, 1984.

[fn:7] Sam M. Daniel. Efficient recursive FFT implementation in Prolog. In Proceedings of the Second International Conference on the Practical Application of Prolog, 175-185, 1994.

[fn:8] Mark Davis. Unicode Standard Annex #29: Text boundaries, 2006. http://www.unicode.org/reports/tr29/.

[fn:9] R. Kent Dybvig. Chez Scheme User's Guide: Version 8. Cadence Research Systems, 2009. http://www.scheme.com/csug8/.

[fn:10] R. Kent Dybvig and Robert Hieb. Engines from continuations. Computer Languages, 14(2):109-123, 1989.

[fn:11] R. Kent Dybvig and Robert Hieb. A new approach to procedures with variable arity. Lisp and Symbolic Computation, 3(3):229-244, September 1990.

[fn:12] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295-326, 1993.

[fn:13] Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth edition. MIT Press, Cambridge, MA, 1996.

[fn:14] Daniel P. Friedman, Christopher T. Haynes, and Eugene E. Kohlbecker. Programming with continuations. In P. Pepper, editor, Program Transformation and Programming Environments, 263-274. Springer-Verlag, New York, 1984.

[fn:15] Christopher T. Haynes and Daniel P. Friedman. Abstracting timed preemption with engines. Computer Languages, 12(2):109-121, 1987.

[fn:16] Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. Obtaining coroutines with continuations. Computer Languages, 11(3/4):143-153, 1986.

[fn:17] Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of first-class continuations. In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, 66-77, June 1990.

[fn:18] IEEE Computer Society. IEEE Standard for the Scheme Programming Language, May 1991. IEEE Std 1178-1990.

[fn:19] Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language, second edition. Prentice Hall, Englewood Cliffs, NJ, 1988.

[fn:20] P. Leach, M. Mealling, and R. Salz. A Universally Unique IDentifier (UUID) URN namespace, July 2005. RFC 4122. http://www.ietf.org/rfc/rfc4122.txt.

[fn:21] Peter Naur et al. Revised report on the algorithmic language ALGOL 60. Communications of the ACM, 6(1):1-17, January 1963.

[fn:22] David A. Plaisted. Constructs for sets, quantifiers, and rewrite rules in Lisp. Technical Report UIUCDCS-R-84-1176, University of Illinois at Urbana-Champaign Department of Computer Science, June 1984.

[fn:23] J. A. Robinson. A machine-oriented logic based on the resolution principle. Journal of the ACM, 12(1):23-41, 1965.

[fn:24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme, September 2007. http://www.r6rs.org/.

[fn:25] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---non-normative appendices, September 2007. http://www.r6rs.org/.

[fn:26] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---standard libraries, September 2007. http://www.r6rs.org/.

[fn:27] Guy L. Steele Jr. Common Lisp, the Language, second edition. Digital Press, Bedford, Massachusetts, 1990.

[fn:28] Guy L. Steele Jr. and Gerald J. Sussman. The revised report on Scheme, a dialect of Lisp. MIT AI Memo 452, Massachusetts Institute of Technology, January 1978.

[fn:29] Gerald J. Sussman and Guy L. Steele Jr. Scheme: An interpreter for extended lambda calculus. Higher-Order and Symbolic Computation, 11(4):405-439, 1998. Reprinted from the AI Memo 349, MIT (1975), with a foreword.

[fn:30] The Unicode Consortium. The Unicode Standard, Version 5.0, fifth edition. Addison-Wesley Professional, Boston, MA, 2006.

[fn:31] Oscar Waddell, Dipanwita Sarkar, and R. Kent Dybvig. Fixing letrec: A faithful yet efficient implementation of Scheme's recursive binding construct. Higher-Order and Symbolic Computation, 18(3/4):299-326, 2005.

[fn:32] Mitchell Wand. Continuation-based multiprocessing. Higher-Order and Symbolic Computation, 12(3):285-299, 1999. Reprinted from the proceedings of the 1980 Lisp Conference, with a foreword.
