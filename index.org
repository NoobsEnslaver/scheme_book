# -*- org-image-actual-width: 'true; -*-
# -*- fill-column: 120; -*-

#+STARTUP: nofninline
#+STARTUP: showall

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [11pt,fleqn, oneside]
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LANGUAGE: RU
#+OPTIONS: toc:nil title:nil
#+TITLE: Язык программирования Scheme, 4-е издание
#+AUTHOR: R. Kent Dybvig

#+NAME: cover
#+ATTR_ORG: :width 300
[[./images/cover.png]]

#+LATEX: \newpage
#+LATEX: \tableofcontents

#+LATEX: \newpage

* Предисловие

  Язык Scheme увидел свет в 1975 году, благодаря стараниям Джеральда Дж.Суссмана и Гая Л.Стили младшего [fn:28],[fn:29], и
  был первым диалектом лиспа, полностью поддерживающим лексические области видимости, процедуры первого класса, и
  продолжения. В первоначальном виде это был очень простой язык, предназначенный, главным образом, для исследований и
  обучения, поддерживающий только небольшой набор предопределённых синтаксических форм и процедур. Сейчас Scheme -
  полноправный язык общего назначения, хотя он до сих пор черпает свою силу из небольшого набора ключевых идей. Ранние
  реализации языка были основаны на интерпретации и не отличались производительностью, однако сейчас существуют реализации
  Scheme, которые могут похвастаться сложными компиляторами, генерирующими код на ровне с кодом, генерируемым лучшими
  оптимизирующими компиляторами низкоуровневых языков, таких как C и Fortran.

  Данная книга нацелена на то, чтобы предоставить введение в язык программирования Scheme, но не в программирование в
  целом. Ожидается, что читатель уже имеет некоторый опыт в программировании и владеет терминами, обычно применяемыми в
  программировании. Читателю, не имеющему представления о Scheme и Lisp, следует сначала обратиться к ~The Little
  Schemer~ [fn:13], чтобы познакомиться с обработкой списков и рекурсией. Новичкам в программировании следует обратиться к
  литературе для новичков.

  Scheme был стандартизован как формально, так и неформально. IEEE стандарт ~Scheme Programming Language~ [fn:18]
  описывает формальный ANSI/IEEE стандарт для Scheme, однако он датирован 1991 годом. Связанная серия докладов 'Отчёты по
  пересмотру алгоритмического языка Scheme' ('Revised Reports on the Algorithmic Language Scheme') документируют
  развивающийся неофициальный стандарт, поддерживаемый большинством реализаций языка. Текущая версия отчёта из этой
  серии - 'Revised6 Report on the Algorithmic Language Scheme' [fn:24] была опубликована в 2007 году.

  Данная книга рассматривает версию языка, описываемую шестой версией (Revised6) отчёта. Она не нацелена на то, чтобы
  заменить данный отчёт, а скорее, предоставить более понятное введение и предметный указатель для языка, с более
  подробными разъяснениями и примерами, большего нацеленного на пользователей языка, а не разработчиков компиляторов для
  него. Описание возможностей, присущих конкретной реализации, отсутствует.

  В частности, возможности, специфичные для авторских реализаций ~Chez Scheme~ и ~Petite Chez Scheme~ описаны отдельно в
  Chez Scheme User's Guide [fn:9]. С другой стороны, не одна книга по Scheme не будет полной без описания интерактивной
  оболочки, поскольку почти каждая реализация Scheme поддерживает интерактивное использование системы в той или иной
  форме, не смотря на то, что данное поведение не стандартизировано Revised6 отчётом. Таким образом, в главах 2 и 3
  предполагается, что у читателя имеется реализация Scheme, которая поддерживает интерактивную оболочку, причем поведение
  соответствует описанию среды верхнего уровня в предыдущих отчетах и стандарту IEEE/ANSI.

  В тексте книги вы найдёте большое количество примеров маленького и среднего размера, а также отдельную главу,
  посвященную рассмотрению нескольких больших примеров. Большинство из них показывают, как могут быть реализованы
  стандартные синтаксические формы и процедуры Scheme, остальные - реализацию полезных расширений. Все эти примеры могут
  быть набраны непосредственно с клавиатуры в рамках сессии интерактивной оболочке.

  Книга разбита на 12 основных глав, плюс приложения. Глава 1 рассматривает те свойства и возможности языка Scheme,
  которые делают его полезным и приятным в использовании. В этой главе так же описаны типографические и нотационные
  соглашения, применяемые в этой книге.

  Глава 2 это введение в программирование на Scheme для начинающих Scheme-программистов, которая проведёт читателя через
  серию примеров, начиная с простейших выражений Scheme и продолжая всё более сложными примерами. Каждая секция второй
  главы представляет читателю маленький набор связанных функций языка, а в конце каждой секции содержится набор упражнений
  для дальнейшей практики. Читатель извлечёт значительно больше пользы из главы, если параллельно с чтением, будет сидеть
  за клавиатурой и набирать примеры и упражнения.

  Глава 3 так же содержит введение, но покрывает более сложные функции и принципы языка. Упражнения из этой главы могут
  быть интересны даже тем читателям, которые уже имеют некоторый опыт в Scheme.

  Главаы с 4 по 11 представляют из себя справочную часть книги. Здесь представлена каждая примитивная процедура и
  синтаксическая форма Scheme, которые, в свою очередь, сгруппированы в короткие секции связанных процедур и форм. Глава 4
  описывает операции объявления и присвоения процедур и переменных. Глава 5 - операции управления ходом выполнения
  программы. Глава 6 - операции над объектами различных типов (в т.ч. списки, числа, строки). Глава 7 - операции
  ввода-вывода. Глава 8 - расширение синтаксиса. Глава 9 - объявление типа данных 'запись'(record). Глава 10 - библиотеки
  и высокоуровневые (top-level) программы. Глава 11 - выражения и продолжения.

  Глава 12 содержит коллекцию примеров процедур, библиотек и программ, каждая с коротким обзором, примеры их
  использования, их реализация с краткими пояснениями и ряд упражнений для дальнейшей самостоятельной работы. Каждая из
  этих программ демонстрирует определённый функционал, а вместе они описывают стиль программирования, принятый в Scheme.

  Вслед за главой 12 идут библиографические ссылки, ответы на некоторые упражнения, полное описание формального синтаксиса
  программ и данных Scheme, включающее полный перечень синтаксических форм и процедур, а так же предметный
  указатель. Полный перечень форм и процедур полезен прежде всего как первое место, куда может заглянуть программист,
  неуверенный в структуре синтаксической формы или ожидаемых примитивной процедурой аргументах. Номера страниц,
  представленные в перечне форм и процедур, а так же номера страниц, выделенные курсивом, в предметном указателе,
  указывают местоположение в тексте, где было приведено описание данной процедуры или формы.

  В виду того, что справочная часть книги содержит такие аспекты языка, которые небыли представлены во введении, а так же
  ряд интересных, коротких примеров, для большинства читателей будет полезнее прочесть большую часть материала, чтобы
  познакомиться поближе с каждой возможностью языка и как это реализуется на других языках. Глава 6 является довольно
  длинной, так что она может быть пропущена при первом прочтении - обращайтесь к ней по мере необходимости, когда увидите
  ссылки на неё в тексте.

  Онлайн версия книги доступна по адресу http://www.scheme.com/tspl/ (русский перевод доступен по адресу
  http://github.com/noobsenslaver/scheme_book/releases). В полном перечне форм и в предметном указателе так же указаны
  номера страниц для печатной версии книги, так что ими можно пользоваться для облегчения поиска обладателям печатных
  версий книги.

  Касаемо иллюстраций: обложка и иллюстрация в начале каждой главы это алгоритмические композиции фонов линий, созданные
  художником Жаном-Пьером Эбертом, основанные на идее, вдохновленной трудами Джона Кейджа. Фон каждой линии вычисляется
  путём сопоставления некоего количества сеток параллельных линий. Каждая сетка регулярна, но линии нет. Например, линии
  имеют разную длину, что образует неровные края. Их тон и толщина немного отличаются. Они могут быть похожи, но не
  равны. Они пересекают друг друга под неким углом. Когда это угол мал, возникает интерференция. Линии сначала погружаются
  в различные скалярные поля, которые возмущают их исходную прямую форму, а потом проецируются на плоскость бумаги. Маски
  вводят отверстия в некоторых слоях. Для иллюстрации обложки сетки окрашены в разные оттенки.

  Все эти изображения созданы одной программой на Scheme, которая принимает большинство решений на вероятностной
  основе. Художник контролирует только размер холста, соотношение сторон, общую палитру цветов и уровни вероятности и
  нечеткости. Задача художника состоит в том, чтобы ввести достаточно шансов в нужном месте, чтобы результаты были
  одновременно удивительными, интересными и удовлетворяли эстетическому чувству художника. Это игра неопределенности,
  хаоса и гармонии.

  Благодарности: Многие люди так или иначе способствовали подготовке одного или нескольких изданий этой книги, в том числе
  Брюс Смит, Евгений Кольбекер, Маттиас Феллесинен, Дэн Фридман, Брюс Дуба, Фил Дыбвиг, Гай Стил, Боб Хиб, Крис Хейнс,
  Дэйв Плайед, Джоан Карри, Фрэнк Сильберманн, Павел Кертис, Джон Уайт, Карл Бруггман, Сэм Даниэль, Оскар Уодделл , Майк
  Эшли, Джон Лалонд, Джон Цукерман, Джон Симмонс, Боб Приор, Боб Бургер и Азиз Гулум. Многие другие предложили небольшие
  исправления и предложения. Оскар Уодделл помог создать систему набора, используемую для форматирования печатных и
  онлайн-версий этой книги. Небольшое количество текста и примеров было заимствовано из ~Revised6 отчёта~ и адаптировано
  для данной книги, за что благодарю авторов этого отчёта и многих других, кто способствовал его написанию. И наконец,
  самую большую благодарность я выражаю моей жене Сьюзан Дыбвиг, в первую очередь за то, что она предложила написать эту
  книгу, а так же за её неоценимую помощь в создании и публикации этого и предыдущих изданий.

#+LATEX: \newpage
[[./images/ch1.png]]

** Введение.

   Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
   типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
   данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
   имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
   языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
   графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
   реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
   изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
   природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
   полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.

   Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
   Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
   между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
   'Revised Reports' для Scheme. Последний, 'Revised6 Report' [fn:24], акцентирует внимание на переносимости, вводя ряд
   стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.

   Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
   реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
   языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
   проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
   информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.

   Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
   и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.

   Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
   пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
   от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
   списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
   освобождения памяти.

   Независимо от представления, /все/ данные являются объектами первого класса. Все они хранятся независимо и могут
   свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
   образования новых объектов.

   Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
   выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
   остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.

   Scheme относится к языкам с /вызовом-по-значению/ , но для, по меньшей мере,  мутабельных объектов (объекты, которые
   могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
   сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
   что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
   процедуры.

   В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
   ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
   составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
   надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
   реализацию и увеличивая надёжность.

   Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
   любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
   переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
   формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
   предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
   процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
   Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.

   В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
   Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
   кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
   т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
   пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
   блоке могут /затенять/ связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
   котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
   лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
   поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
   компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
   с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
   определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
   пока программа не выполнится.

   В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
   локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена в
   пределах другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет
   конца блока. В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может
   быть произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже
   когда внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо
   самого кода, хранит в себе лексический контекст (окружение).

   Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
   такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
   другим объектом.

   Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
   процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
   становятся элегантнее или эффективнее. Особый вид рекурсии, называемый /хвостовая рекурсия/, используется для
   выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
   другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
   самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
   (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
   Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
   обычным набором итерационных конструкций.

   Scheme поддерживает определение произвольных управляющих структур с помощью /продолжений/ . /Продолжение/ , это
   процедура, которая заключает в себе остальную часть программы в заданной точке. /Продолжение/ может быть получено в
   любой момент во время выполнения программы. Так же, как и с другими процедурами, /продолжение/ является объектом
   первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
   продолжает выполнение с той точки, где это /продолжение/ было создано. /Продолжения/ позволяют реализовать сложные
   механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.

   Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
   написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
   существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
   высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
   реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
   процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
   выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
   языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
   выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
   синтаксических выражений и объявлений процедур.

   Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
   объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
   многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
   60 [fn:21]. Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
   структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
   лексической областью действия.

   Common Lisp [fn:27] и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
   другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
   процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
   с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
   объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
   объектов первого класса. И хотя Common Lisp не поддерживает /продолжения/ или требует правильного обращения с
   хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
   похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
   универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).

   Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
   используемых в этой книге.

*** Синтаксис

    Программы на Scheme состоят из ключевых слов, переменных, структурирующих форм, константных данных (числа, буквы,
    строки, цитируемые векторы, цитируемые списки, цитируемые символы и т.д.), пробелов и комментариев.

    Ключевые слова, переменные и символы собирательно именуются идентификаторами. Идентификаторы могут быть образованы из
    букв, чисел и некоторых специальных символов, включающих ~?~, ~!~, ~.~, ~+~, ~-~, ~*~, ~/~, ~<~, ~=~, ~>~, ~:~, ~$~,
    ~%~, ~^~, ~&~, ~_~, ~~~, и ~@~, так же ряда дополнительных символов из Unicode. Идентификаторы не могут начинаться со
    знака @, а так же со знаков, с которых может начинаться число, таких как ~+~, ~-~, ~.~, исключение ~-~ знаки ~+~, ~-~
    и некоторые другие, которые могут быть идентификаторами сами по себе, а так же идентификаторы, начинающиеся с
    ~->~. Например, ~hi~, ~Hello~, ~n~, ~x~, ~x3~, ~x+2~, и ~?$&*!!!~ - корректные идентификаторы. Идентификаторы
    отделяются пробелами, комментарием, скобками, фигурными скобками, двойными кавычками и знаком решётки. Разделитель,
    или любая другая буква Unicode, могут быть включены в любое место в имени идентификатора путём экранирования в виде
    ~\xsv~, где sv - скалярное значение символа в шестнадцатеричном представлении.

    На длину идентификаторов не накладывается никаких ограничений, программист использовать столько символов в имени,
    сколько посчитает нужным. Однако, длинные идентификаторы не заменят комментариев, в то же время, их частое
    использование может сделать код трудным для форматирования и чтения. Хорошее правило, это использовать короткие имена
    идентификаторов в тех случаях, когда область видимости идентификатора мала, и длинные тогда, когда область видимости
    велика.

    Идентификаторы могут содержать любую комбинацию символов верхнего или нижнего регистров, регистр учитывается т.е. два
    идентификатора считаются различными, даже если они отличаются только регистром. Например, ~abcde~, ~Abcde~, ~AbCdE~ и
    ~ABCDE~ - все различные идентификаторы. Это нововведение, по сравнению с предыдущими отчётами по стандарту языка.

    Структурированные формы и списки констант заключаются в скобки, например ~(a b c)~ или ~(* (- x 2) y)~. Пустой список
    записывается как ~()~. Другие парные наборы скобок, такие как ~[~ ~]~, могут быть использованы вместо круглых скобок
    и часто используются для выделения подвыражений определенных стандартных синтаксических форм для удобочитаемости, как
    в примерах в этой книге. Векторы записываются таким же образом, как и списки, за исключением того, что они начинаются
    с ~#(~ и заканчиваются ~)~, например ~#(это вектор содержащий символы)~. Байт-векторы записываются как
    последовательность беззнаковых байтов (обычные целочисленные значения в диапазоне от 0 до 255), заключенных в ~#vu8(~
    и ~)~, например ~#vu8(3 250 45 73)~.

    Строки заключаются в двойные кавычки, например "Это строка" . Буквы предваряются ~#\~, например ~#\a~. Когда речь
    идёт о строках или буквах - регистр имеет значение, так же как и в случае с идентификаторами. Числа могут быть
    записаны в виде целочисленного значения (integer), например ~-123~, рационального числа, например ~1/2~, числа с
    плавающей точкой или в научной форме, например ~1.3~ или ~1e23~, как комплексное число, в прямоугольной или полярной
    системах координат например ~1.3-2.7i~ или ~-1.2@73~. В случае чисел регистр не имеет значения. Булевы значения,
    представляющие ложь и истину, обозначаются ~#f~ и ~#t~ соответственно. В Scheme, условные выражения обычно считают
    ~#f~ ложью, а любой другой объект истиной, так что ~3~, ~0~, ~()~, "false" или ~nil~ - всё это считается истиной.

    Детальное описание синтаксиса каждого константного типа данных дано в отдельной секции в главе 6 и в формальном
    описании синтаксиса, приведённом в конце книги.

    Выражения в Scheme могут занимать несколько строк, для этого не требуются специальные терминирующие
    символы. Учитывая, что количество пробельных символов и переводов строки между выражениями не имеет синтаксического
    значения, эту возможность следует использовать, чтобы программы на Scheme были выровнены таким образом, чтобы
    правильно отображать структуру кода и делать его настолько читаемым, насколько это возможно. Комментарии могут быть
    размещены в каждой строке программы, между символом ~;~ и концом строки. Комментарий, поясняющий конкретное выражение
    Scheme, обычно размещается в предыдущей строке, с тем же уровнем отступа. Комментарии, поясняющие процедуру или
    группу процедур, обычно размещаются перед процедурой, без отступа.

    Так же поддерживаются следующие два вида комментариев: блочные и комментарии по данным (datum). Блочные комментарии
    обосабливаются парой ~#|~ и ~|~, и могут быть вложенными. Комментарии данных начинаются с префикса ~#;~ , за которым
    следует печатная версия объекта данных. Комментарии по данным обычно используются, чтобы закомментировать конкретное
    объявление или выражение. Например, ~(список из трёх #;(а не четырёх) элементов)~. Комментарии по данным могут так же
    быть вложенными, например ~#;#;(a)(b)~, но это не имеет какого то особого значения, в сравнении, если бы
    комментировался каждый элемент по отдельности.

    Некоторые значения в Scheme, такие как процедуры или порты, не имеют стандартизированного печатного представления и
    по этому не могут быть представлены константой при печати. В этой книге используется обозначение ~#<пояснение>~,
    когда мы хотим оказать возвращаемый результат какой либо операции, возвращающей одно из таких значений, например
    ~#<procedure>~ или ~#<port>~.

*** Соглашения в именовании

    Соглашения по именованию, принятые в Scheme, разработаны так, чтобы обеспечивать высокий уровень системности и
    регулярности. Ниже приведён список таких соглашений:

    + Имена предикатов заканчиваются символом вопроса (?). Предикаты, это процедуры, возвращающие истину или ложь, такие
      как ~eq?~, ~zero?~ и ~string=?~. Обычные для чисел операции сравнения, такие как ~=~, ~<~, ~>~, ~<=~, и ~>=~
      являются исключением из правил.
    + Предикаты типов, например ~pair?~, составляются из имени типа, в данном случае /pair/ и знака вопроса.
    + Имена большинства процедур предикатов для букв, строк и векторов начинаются с префикса ~char-~, ~string-~,
      ~vector-~, например ~string-append~. (Имена некоторых процедур для списков начинаются с ~list-~, но большинство
      нет)
    + Имена процедур, которые преобразуют объект одного типа в объект другого типа, записываются как ~type1->type2~,
      например ~vector->list~.
    + Имена процедур и синтаксических форм, производящих побочные эффекты, оканчиваются знаком восклицательного знака
      (~!~). Например ~set!~ и ~vector-set!~. Процедуры, производящие операции ввода-вывода, формально так же считаются
      процедурами с побочными эффектами, однако они попадают под исключение из правил.
    + Программистам следует следовать этим соглашениям по именованию там, где это возможно.

*** Типографические и нотационные соглашения

    Про стандартные процедуры или синтаксические формы, единственная цель которых выполнение побочных эффектов, сказано,
    что возвращаемый ими результат не определён. Это значит, что конкретная реализация свободна возвращать любое
    количество значений, каждое из которых может быть любым объектом Scheme. Не рассчитывайте на то, что эти возвращаемые
    значения одинаковы для всех реализаций, одинаковые для версий одной и той же реализации, или даже одинаковы между
    двумя вызовами одной и той же процедуры или синтаксической формы. Некоторые реализации Scheme используют специальные
    объекты для обозначения неопределённого значения. Печать этого объекта часто подавляется интерактивными системами
    Scheme, поэтому значения выражений, возвращающих неопределённые значения, не печатаются.

    В то время, как большинство стандартных процедур возвращает одно значение, язык поддерживает процедуры, которые
    возвращают ноль, одно, более одного, или переменное количество значений, используя механизм, описанный в главе
    5.8. Некоторые стандартные выражения могут вычисляться в множество значений, если одно из подвыражений вычисляется в
    множество значений т.е. когда вызывается процедура, возвращающая несколько значений. Когда такое случается, выражению
    предписано возвращать /значения/, а не /значение/ его подвыражения. То же касается стандартных процедур, принимающих
    аргументом функцию - им предписывается возвращать множественное значение в том случае, если процедура-аргумент,
    влияющая на результат, возвращает множественное значение.

    В этой книге используются слова 'должен' и 'следует', чтобы описать программные требования, такие как требование,
    чтобы передаваемый индекс был меньше, чем длина вектора, при вызове ~vector-ref~. Если использовано слово 'должен', это
    значит, что реализация будет отслеживать выполнение этих требований т.е. будет выброшено исключение, обычно с типом
    условия ~&assertion~. Если используется слово 'следует', исключение может быть выброшено, а может не быть, если нет -
    поведение программы не определено. Фраза 'нарушение синтаксиса' используется, чтобы описать ситуацию, когда программа
    сформирована неправильно. Нарушения синтаксиса обнаруживаются в основном при выполнении программы. Когда нарушение
    синтаксиса обнаружено, выбрасывается исключение типа ~&syntax~ и программа прекращает работу.

    Типографические соглашения, используемые в этой книге весьма просты. Все объекты напечатаны таким же образом, как они
    выглядели бы, если бы их набрали на клавиатуре. Это касается ключевых слов синтаксиса, переменных, константных
    объектов, выражений Scheme, и примеров программ. Выделение /курсивом/ используется для обозначения синтаксических
    переменных в пояснениях синтаксических форм, аргументов и процедур. Так же курсивом выделены технических термины,
    используемые впервые. Обычно, имена и синтаксические формы находятся в нижнем регистре, даже если они начинают новое
    предложение.  То же касается и синтаксических переменных, выделенных курсивом.

    В описании синтаксических форм и процедур, один или несколько прототипов шаблонов показывают синтаксическую форму или
    формы или корректное количество аргументов для применения процедуры. Ключевое слово или имя процедуры выделяются
    машинописным шрифтом, так же как и круглые скобки. Остальные части синтаксиса или аргументы выделяются курсивом,
    используя имя, обозначающее тип выражения или аргумента, ожидаемого синтаксической формой или процедурой. Окружности
    используются для обозначения нуля или более вхождений подвыражения или аргумента. Например, ~(or expr ...)~
    описывает синтаксическую форму ~or~, которая имеет ноль или более подвыражений, и ~(member obj list)~ описывает
    процедуру ~member~, которая ожидает два аргумента - объект и список.

    Нарушением синтаксиса считается случай, когда структура синтаксической формы не совпадает с её прототипом. Обычно,
    выбрасывается исключение типа ~&assertion~, если количество аргументов, переданных в стандартную процедуру не
    совпадает с тем, которое ожидается к получению. Исключение с типом условия ~&assertion~ также выбрасывается, если
    стандартная процедура получает аргумент, который не подразумевается в его названии, или не удовлетворяет другим
    критериям, указанным в описании процедуры. Например, прототип для ~vector-set!~ таков:

#+begin_src scheme
    (vector-set! vector n obj)
#+end_src

    и описание говорится, что ~n~ должен быть неотрицательным целым числом, строго меньшим, чем длина вектора. Таким
    образом, ~vector-set!~ должен получить три аргумента, первый из которых должен быть вектором, второй должен быть
    неотрицательным целым числом, меньше длины вектора, и третьим может быть любой объект Scheme. В противном случае,
    будет выброшено исключение с типом условий ~&assertion~.

    В большинстве случаев тип ожидаемого аргумента очевиден, как в случае в ~vector~, ~obj~ или ~binary-input-port~. В
    остальных же случаях, по большей части использующихся в описании числовых операций, используются сокращения, такие
    как /int/ для целочисленных, /exint/ (от exact integer) для строгого указания целочисленного типа и /fx/ для типа
    /fixnum/. Эти сокращения поясняются в начале разделов, где мы их впервые коснёмся.

#+LATEX: \newpage
[[./images/ch2.png]]

** Начало

   Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
   параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

   После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
   Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
   данных и управляющие конструкции.

*** Взаимодействие с интерактивной оболочкой Scheme

    Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
    разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
    "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
    или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
    выполнения на экран.

    Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
    выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
    работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
    и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
    в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
    реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
    качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
    программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
    для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
    образом, как если бы они были набраны на клавиатуре интерактивно.

    Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
    значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
    позволяет сконцентрироваться на написании программы.

    Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
    можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После ⇒ следует значение
    выражения, что следует читать как "имеет следующее значение". Знак ⇒ применим для определений и в тех случаях, когда
    значение выражения неопределено.

    Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
    потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
    строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
    выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
    она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

    Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
    будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
    набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
    значение вычисления любой константы - сама константа.

#+begin_src scheme
    "Hi Mom!" ⇒ "Hi Mom!"
#+end_src

    Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
    однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+begin_src scheme
    "hello" ⇒ "hello"
    42 ⇒ 42
    22/7 ⇒ 22/7
    3.141592653 ⇒ 3.141592653
    + ⇒ #<procedure>
    (+ 76 31) ⇒ 107
    (* -12 10) ⇒ -120
    '(a b c d) ⇒ (a b c d)
#+end_src

    Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
    одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
    попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
    ожидать её даже после окончания ввода.

    Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
    дождаться пояснений, найдя их далее в главе.

#+begin_src scheme
    (car '(a b c)) ⇒ a
    (cdr '(a b c)) ⇒ (b c)
    (cons 'a '(b c)) ⇒ (a b c)
    (cons (car '(a b c))
          (cdr '(d e f))) ⇒ (a e f)
#+end_src

    Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
    выражение по парным двойным кавычкам и скобкам.

    Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
    (define square
      (lambda (n)
        (* n n)))
#+end_src

    Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
    процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
    связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
    выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
    предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
    операций, вроде ~*~.

    Опробуем наш ~square~ в деле:

#+begin_src scheme
    (square 5) ⇒ 25
    (square -200) ⇒ 40000
    (square 0.5) ⇒ 0.25
    (square -1/2) ⇒ 1/4
#+end_src

    Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
    "reciprocal.ss."

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
    вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
    (load "reciprocal.ss")
#+end_src

    Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+begin_src scheme
    (reciprocal 10) ⇒ 1/10
    (reciprocal 1/10) ⇒ 10
    (reciprocal 0) ⇒ "oops!"
    (reciprocal (reciprocal 1/10)) ⇒ 1/10
#+end_src

*** Простейшие выражения

    Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
    списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
    примеров со строками и числами.

    Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
    ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+begin_src scheme
    123456789987654321 ⇒ 123456789987654321
    3/4 ⇒ 3/4
    2.718281828 ⇒ 2.718281828
    2.2+1.1i ⇒ 2.2+1.1i
#+end_src

    Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
    целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
    используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

    Scheme предоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
    поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
    обозначают применение процедуры к набору аргументов.

#+begin_src scheme
    (+ 1/2 1/2) ⇒ 1
    (- 1.5 1/2) ⇒ 1.0

    (* 3 1/2) ⇒ 3/2
    (/ 1.5 3/4) ⇒ 2.0
#+end_src

    Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
    процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
    постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
    относительно приоритета или ассоциативности операторов.

    Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
    образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
    формул.

#+begin_src scheme
    (+ (+ 2 2) (+ 2 2)) ⇒ 8
    (- 2 (* 4 1/3)) ⇒ 2/3
    (* 2 (* 2 (* 2 (* 2 2)))) ⇒ 32
    (/ (* 6/7 7/2) (- 4.5 1.5)) ⇒ 1.0
#+end_src

    Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
    мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
    лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

    Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
    содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
    является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
    обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
    не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
    строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
    элементов, каждый из которых это список из двух элементов.

    Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
    Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
    ~(procedure arg ...)~?

    В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
    применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
    Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
    потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
    список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
    применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+begin_src scheme
    (quote (1 2 3 4 5)) ⇒ (1 2 3 4 5)
    (quote ("да" "это" "всё" "ещё" "список")) ⇒ ("да" "это" "всё" "ещё" "список")
    (quote (+ 3 4)) ⇒ (+ 3 4)
#+end_src

    С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
    ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
    третьего.

    Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
    обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
    аббривеатурой для ~quote~.

#+begin_src scheme
    '(1 2 3 4) ⇒ (1 2 3 4)
    '((1 2) (3 4)) ⇒ ((1 2) (3 4))
    '(/ (* 2 -1) 3) ⇒ (/ (* 2 -1) 3)
#+end_src

    Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
    будет заключён в выражение ~quote~.

    Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
    принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
    процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
    принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

    Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+begin_src scheme
    (quote hello) ⇒ hello
#+end_src

    Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hello~ как
    переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
    выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
    об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
    думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
    списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
    идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
    используются для представления переменных в описании символьных уравнений или программ, символы могут также
    использоваться, например, как слова в описании предложений естественного языка.

    Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
    символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
    написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
    в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
    самых значительных особенностей Scheme.

    Числа и строки также могут цитироваться:

#+begin_src scheme
    '2 ⇒ 2
    '2/3 ⇒ 2/3
    (quote "Hi Mom!") ⇒ "Hi Mom!"
#+end_src

    Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

    Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
    значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
    оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
    на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+begin_src scheme
    (car '(a b c)) ⇒ a
    (cdr '(a b c)) ⇒ (b c)
    (cdr '(a)) ⇒ ()

    (car (cdr '(a b c))) ⇒ b
    (cdr (cdr '(a b c))) ⇒ (c)

    (car '((a b) (c d))) ⇒ (a b)
    (cdr '((a b) (c d))) ⇒ ((c d))
#+end_src

    Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
    /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

    Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
    ~cons~ вернёт список.

#+begin_src scheme
    (cons 'a '()) ⇒ (a)
    (cons 'a '(b c)) ⇒ (a b c)
    (cons 'a (cons 'b (cons 'c '()))) ⇒ (a b c)
    (cons '(a b) '(c d)) ⇒ ((a b) c d)

    (car (cons 'a '(b c))) ⇒ a
    (cdr (cons 'a '(b c))) ⇒ (b c)
    (cons (car '(a b c))
          (cdr '(d e f))) ⇒ (a e f)
    (cons (car '(a b c))
          (cdr '(a b c))) ⇒ (a b c)
#+end_src

    "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
    путём добавления элемента в начало списка называется /consing/.

    Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
    пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
    следующая пара в последовательности.

#+ATTR_LATEX: :width 200px
[[./images/1.png]]

    /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
    /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
    /правильным/ становится любой список, /cdr/ которого /правильный/ список.

    Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
    списка.

#+begin_src scheme
    (cons 'a 'b) ⇒ (a . b)
    (cdr '(a . b)) ⇒ b
    (cons 'a '(b . c)) ⇒ (a b . c)
#+end_src

    Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
    чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
    /правильные/ списки без точек.

#+begin_src scheme
    '(a . (b . (c . ()))) ⇒ (a b c)
#+end_src

    Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
    строит /правильные/ списки.

#+begin_src scheme
    (list 'a 'b 'c) ⇒ (a b c)
    (list 'a) ⇒ (a)
    (list) ⇒ ()
#+end_src

    Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
    чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

**** Упражнение 2.2.1

     Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
     1. ~1.2 × (2 - 1/3) + -8.7~
     2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
     3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
     4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~

**** Упражнение 2.2.2

     Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
     возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.

**** Упражнение 2.2.3

     Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
     ответы:
     1. ~(cons 'car 'cdr)~
     2. ~(list 'this '(is silly))~
     3. ~(cons 'is '(this silly?))~
     4. ~(quote (+ 2 3))~
     5. ~(cons '+ '(2 3))~
     6. ~(car '(+ 2 3))~
     7. ~(cdr '(+ 2 3))~
     8. ~cons~
     9. ~(quote cons)~
     10. ~(quote (quote cons))~
     11. ~(car (quote (quote cons)))~
     12. ~(+ 2 3)~
     13. ~(+ '2 '3)~
     14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
     15. ~((car (list + - * /)) 2 3)~

**** Упражнение 2.2.4

     ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
     которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.

**** Упражнение 2.2.5

     Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:

#+ATTR_LATEX: :width 200px
[[./images/2.png]]

**** Упражнение 2.2.6

     Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
     ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~

**** Упражнение 2.2.7

     Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
     b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
     выражения ~((a b) (c d))~.

**** Упражнение 2.2.8

     Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
     объяснение?

*** Выполнение Scheme выражений

    Давайте вернёмся к обсуждению, как всётаки Scheme выполняет набранные Вами выражения. Мы уже установили правила для
    константных  объектов, таких как строки и числа: эти объекты являются значениями сами по себе. Вы возможно уже
    выработали у себя в голове некоторые правила для вычисления применения процедур вида ~(procedure arg1
    ... argN)~. Здесь, ~procedure~ это выражение, представляющее Scheme процедуру, а ~arg1 ... argN~ выражения,
    представляющие её аргументы. Один из возможных вариантов её применения следующий:

    + Определить значение ~procedure~.
    + Определить значение ~arg1~.
    + ...
    + Определить значение ~argN~.
    + Применить значение ~procedure~ к значениям ~arg1 ... argN~.

    Для примера, рассмотрим применение простой процедуры ~(+ 3 4)~. Значение ~+~ это процедура сложения, значение ~3~
    это число ~3~, значение ~4~ это число ~4~. Применение процедуры сложения к ~3~ и ~4~ даёт ~7~, так что мы получаем
    значение ~7~.

    Применяя данный алгоритм на каждом уровне, мы можем найти значения вложенного выражения ~(* (+ 3 4) 2)~. Значение
    ~*~ это процедура умножения, значение ~(+ 3 4)~, как мы выяснили выше, это ~7~, а значение ~2~ это ~2~. Перемножив
    ~7~ и ~2~ мы получаем ~14~, так что наш ответ ~14~.

    Это правило работает для применения процедуры, но не работает для /цитированного/ выражения, потому что подвыражения
    примененияя процедуры вычисляются, в то время как подвыражения /цитированного/ выражения нет. Вычисление
    /цитированного/ выражения более похоже на вычисление константного объекта. Значение /цитированного/ выражения ~(quote
    object)~ это просто ~object~.

    Константные объекты, применения процедур и /цитированные/ выражения это только три из множества синтаксических форм,
    предоставляемых Scheme. К счастью, лишь немногие из оставшихся синтаксических форм неприменно должны быть понимаемы
    Scheme программистом. Они называются /основными синтаксическими формами/. Остальные синтаксические формы это
    синтаксические выражения, преимущественное, выраженные в терминах основных синтаксических форм. Мы обсудим
    оставшиеся синтаксические формы и некоторые синтаксические выражение ниже в этой главе. Секция 3.1 подытоживает
    обзор основных синтаксических форм и даёт введение в механизм расширения синтаксиса.

    Прежде чем мы перейдём к новым синтаксическим формам и процедурам, будет не лишним сказать пару слов о вычислении
    применения процедур. Во-первых, описанный выше процесс слишком строг, поскольку он требует вычисления подвыражений
    слева направо, это значит, что значение ~procedure~ будет вычислено до вычисления ~arg1~, ~arg1~ до ~arg2~ и
    т.д. Это вовсе не обязательно. /Вычислитель/ Scheme свободен вычислять выражения в любом порядке - слева направо,
    справо налево, или в любой другой последовательности. На деле, подвыражения могут вычисляться в различном порядке в
    различных случаях, даже в рамках одной и той же реализации.

    Во-вторых ~procedure~ вычисляется таким же образом, как и ~arg1 ... argN~. Хотя процедура часто является переменной,
    которая указывает на конкретную процедуру, это не обязательно. Упражнение 2.2.3 предложит Вам определить значение
    выражения ~((car (list + - * /)) 2 3)~. Здесь процедура это ~(car (list + - * /))~. Значение ~(car (list + - * /))~
    это процедура сложения, как если бы была просто записана переменная +.

**** Exercise 2.3.1

     Опишите шаги, необходимые для вычисления выражения ниже:

#+begin_src scheme
     ((car (cdr (list + - * /))) 17 5)
#+end_src

*** Переменые и ~let~ выражения

    Пусть ~expr~ это Scheme выражение, содержащее переменную ~var~. Допустим также, что нам хотелось бы, чтобы
    переменная ~var~ содержала бы значение ~val~, когда мы вычисляем значение ~expr~. Например, мы хотим, чтобы ~x~ имел
    значение ~2~, когда вычисляется выражение ~(+ x 3)~. Или, мы хотим, чтобы ~y~ имел значение ~3~, при вычислении
    выражения ~(+ 2 y)~. Примеры ниже показывают, как добиться такого поведения при помощи синтаксической формы ~let~:

#+begin_src scheme
    (let ((x 2))
      (+ x 3)) ⇒ 5

    (let ((y 3))
      (+ 2 y)) ⇒ 5

    (let ((x 2) (y 3))
      (+ x y)) ⇒ 5
#+end_src

    Синтаксическая форма ~let~ включает в себя список пар /переменная->выражение/, а так же список выражений,
    использующих эти переменные, называемый телом (/body/) ~let~. В общем виде выражение ~let~ имеет следующую форму:

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    Таким образом, с помощью ~let~, мы говорим, что переменные связываются со своими значениями, и далее мы можем
    ссылаться на них в теле выражения.

    ~let~ выражения применяются очень часто и служат средством упрощения выражений, которые содержат несколько
    идентичных подвыражений. Вынесение этого подвыражения в секцию связывания переменных гарантирует, что выражение
    будет вычислено лишь единожды.

#+begin_src scheme
    (+ (* 4 4) (* 4 4)) ⇒ 32

    (let ((a (* 4 4))) (+ a a)) ⇒ 32
#+end_src

    В секции связывания переменных часто вместо круглых скобок применяют квадратные, чтобы визуально отделить эту
    область от остального тела:

#+begin_src scheme
    (let ([list1 '(a b c)] [list2 '(d e f)])
      (cons (cons (car list1)
                  (car list2))
            (cons (car (cdr list1))
                  (car (cdr list2))))) ⇒ ((a . d) b . e)
#+end_src

    Scheme интерпретирует формы, заключённые в квадратные скобки так, как будто они заключены в круглые скобки, но
    нельзя их смешивать - открывающей круглой скобке должна соответствовать закрывающая круглая скобка, а открывающей
    квадратной - квадратная. Мы используем квадратные скобки для ~let~ (и как вы скоро увидите, так же ещё для некоторых
    стандартных синтаксических форм), чтобы улучшить читаемость кода, особенно когда мы могли бы иметь две или более
    последовательные открывающие круглые скобки.

    Поскольку, при применении процедуры, вычисление выражения, стоящего в первой позиции, происходит таким же образом,
    как и любого другого выражения, здесь так же может быть использована /let-связанная/ переменная:

#+begin_src scheme
    (let ([f +])
      (f 2 3)) ⇒ 5

    (let ([f +] [x 2])
      (f x 3)) ⇒ 5

    (let ([f +] [x 2] [y 3])
      (f x y)) ⇒ 5
#+end_src

    Переменные, связанные с помощью ~let~ видны только в пределах /тела/:

#+begin_src scheme
    (let ([+ *])
      (+ 2 3)) ⇒ 6

    (+ 2 3) ⇒ 5
#+end_src

    И это очень хорошо, что оно работает именно так, потому что мы не хотели бы, чтобы значение + было методом умножения
    всюду.

    Так же выражения ~let~ могут быть вложенными:

#+begin_src scheme
    (let ([a 4] [b -3])
      (let ([a-squared (* a a)]
            [b-squared (* b b)])
        (+ a-squared b-squared))) ⇒ 25
#+end_src

    Когда во вложенном ~let~ выражении производят связывание той же переменной, что и во внешнем, только связывание,
    выполненное последним, на более глубоком уровне, считается действующим в пределах тела внутреннего ~let~-выражения:

#+begin_src scheme
    (let ([x 1])
      (let ([x (+ x 1)])
        (+ x x))) ⇒ 4
#+end_src

    Здесь внешнее ~let~ выражение связывает ~x~ и 1 в пределах своего тела, место которого занимает второе ~let~
    выражение. Внутреннее ~let~ выражение связывает ~x~ со значением ~(+ x 1)~ в рамках своего тела, которое
    представлено выражением ~(+ x x)~. Каково значение выражения ~(+ x 1)~? Поскольку ~(+ x 1)~ появляется в теле
    внешнего ~let~, но не в теле внутреннего ~let~, значение ~x~ должно быть 1, и, следовательно, значение ~(+ x 1)~
    равно 2. А что насчёт ~(+ x x)~? Оно появляется в теле обоих выражений ~let~. Видно только внутреннее связывание для
    ~x~, поэтому ~x~ равно 2, а ~(+ x x)~ равно 4.

    Про внутреннее связывание для ~x~ говорят, что оно /затеняет/ внешнее связывание. let-связанная переменная видна
    везде внутри тела ее выражения ~let~, кроме случаев, когда она затенена. Область, в которой действует связывание
    переменной, называется /областью видимости/ (scope). Область видимости первого ~x~ в приведенном выше примере - это
    тело внешнего выражения ~let~ минус тело внутреннего выражения ~let~, где он затеняется вторым ~x~. Эта форма
    определения области видимости называется /лексической областью видимости/, поскольку область видимости каждого
    связывания может быть определена путем простого текстового анализа программы.

    Затенения можно избежать, дав различные имена переменным. Выражение выше может быть переписано так, что во
    внутреннем ~let~ выражении будет производиться связывание значения с именем ~new-x~:

#+begin_src scheme
    (let ([x 1])
      (let ([new-x (+ x 1)])
        (+ new-x new-x))) ⇒ 4
#+end_src

    Хотя выбор разных имен иногда может предотвратить путаницу, затенение может помочь предотвратить случайное
    использование "старого" значения. Например, в исходной версии предыдущего примера мы не могли бы ошибочно сослаться
    на внешний ~x~ в теле внутреннего ~let~.

**** Упражнение 2.4.1

     Перепишите выражения ниже, используя ~let~, чтобы вынести общие подвыражения и улучшить структуру кода. Не
     используйте математических упрощений.

     + ~(+ (- (* 3 a) b) (+ (* 3 a) b))~
     + ~(cons (car (list a b c)) (cdr (list a b c)))~

**** Упражнение 2.4.2

     Определите значение вычисления следующего выражение. Поясните, как вы получили это значение.

#+begin_src scheme
     (let ([x 9])
       (* x
          (let ([x (/ x 3)])
            (+ x x))))
#+end_src

**** Упражнение 2.4.3

     Перепишите следующие выражения, чтобы дать уникальные имена каждой отдельной let-связанной переменной, чтобы ни
     одна из переменных не была затенена. Убедитесь, что значение вашего выражения совпадает со значением исходного
     выражения.

     +
#+begin_src scheme
     (let ([x 'a] [y 'b])
       (list (let ([x 'c]) (cons x y))
             (let ([y 'd]) (cons x y))))
#+end_src

     +
#+begin_src scheme
     (let ([x '((a b) c)])
       (cons (let ([x (cdr x)])
               (car x))
             (let ([x (car x)])
               (cons (let ([x (cdr x)])
                       (car x))
                     (cons (let ([x (car x)])
                             x)
                           (cdr x))))))
#+end_src

*** Лямбда выражения

    В выражении ~(let ([x (* 3 4)]) (+ x x))~ переменная ~x~ связана со значением ~(* 3 4)~. Что будет, если мы захотим
    получить значение выражения ~(+ x x)~ где  ~x~ связана со значением ~(/ 99 11)~? А где ~x~ связана со значением
    ~(- 2 7)~? В каждом случае нам потребуется новое ~let~-выражение. И чем сложнее становится тело ~let~, тем менее
    удобно становится повторять его.

    Вместо этого мы можем использовать синтаксическую форму ~lambda~ для создания новой процедуры, которая имеет ~x~ в
    качестве входного параметра и имеет такое же тело, как у ~let~-выражения.

#+begin_src scheme
    (lambda (x) (+ x x)) ⇒ #<procedure>
#+end_src

    Общая форма лямбда-выражения:

#+begin_src scheme
    (lambda (var ...) body1 body2 ...)
#+end_src

    Переменные ~var ...~ это формальные параметры процедуры, а последовательность выражений ~body1 body2 ...~ это её
    тело. (В действительности, по-настоящему общая форма это нечто более обобщённое, чем это, как вы увидите позже).

    Процедура - это такой же объект, как число, строка, символ или пара. У неё нет какого-либо вменяемого печатного
    представления, по крайней мере в Scheme, тем не менее, в этой книге мы будем использовать обозначение ~#<procedure>~
    чтобы показать, что значение выражения это процедура.

    Простейшая операция, которую можно совершить над процедурой - это применить её к одному или более значений:

#+begin_src scheme
    ((lambda (x) (+ x x)) (* 3 4)) ⇒ 24
#+end_src

    Здесь нет никакого отличия от какого-то другого способа применения процедуры. Процедура это результат вычисления
    выражения ~(lambda (x) (+ x x))~ и единственный агрумент это значение выражения ~(* 3 4)~, или 12. Значения
    аргументов, или параметры, связываются с формальными параметрами в пределах тела лямбда-выражения таким же образом,
    как и let-связывание связывает переменные с их значениями. В этом случае, ~x~ связывается с 12, а значение ~(+ x x)~
    равно 24. Таким образом, результат применения процедуры к значению 12 равен 24.

    Посколько процедуры это объекты, мы можем установить процедуру как значение переменной и использовать эту процедуру
    в дальнейшем не раз.

#+begin_src scheme
    (let ([double (lambda (x) (+ x x))])
      (list (double (* 3 4))
            (double (/ 99 11))
            (double (- 2 7)))) ⇒ (24 18 -10)
#+end_src

    Здесь мы установили связывание между ~double~ и процедурой, а затем использовали эту процедуру, чтобы удвоить три
    различных значения.

    Наша процедура ожидает, что её фактическим параметром будет число, поскольку он передаётся фактическим параметром в
    ~+~. В общем же случае, фактическим параметром может быть объект любого сорта. Рассмотрим, для примера, простейшую
    процедуру, которая использует ~cons~ вместо ~+~:

#+begin_src scheme
    (let ([double-cons (lambda (x) (cons x x))])
      (double-cons 'a)) ⇒ (a . a)
#+end_src

    Отмечая сходство между ~double~ и ~double-cons~, вы не должны удивляться, узнав, что они могут быть объединены в
    одну процедуру путем добавления дополнительного аргумента.

#+begin_src scheme
    (let ([double-any (lambda (f x) (f x x))])
      (list (double-any + 13)
            (double-any cons 'a))) ⇒ (26 (a . a))
#+end_src

    Здесь демонстрируется, что процедуры могут принимать более одного аргумента и эти аргументы, передаваемые в
    процедуру, сами могу быть процедурами.

    Как и с ~let~-выражениями, лямбда-выражения становятся несколько интереснее, когда они вложены в другие
    лямбда- или let-выражения.

#+begin_src scheme
    (let ([x 'a])
      (let ([f (lambda (y) (list x y))])
        (f 'b))) ⇒ (a b)
#+end_src

    Вхождение ~x~ в лямбда-выражение ссылается на ~x~ за пределами лямбды, который был связан внешним
    let-выражением. Говорят, что переменная ~x~ в лямбда-выражении свободна или является свободной переменной
    лямбда-выражения. Переменная ~y~ не является свободной переменной в лямбда-выражении, поскольку она была связана в
    лямбда-выражении. Переменная, которая становится свободной в лямбда-выражении должна уже быть связана, например,
    окружающим лямбда- или let-выражением, кроме случая, когда переменная связывается вне выражения, который мы обсудим
    в следующем разделе.

    Что происходит, когда процедура применяется где-то вне области привязок для переменных, которые встречаются в
    процедуре свободно, как в следующем выражении?

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (f 'i 'am)) ⇒ (sam i am)
#+end_src

    Ответ заключается в том, что те же привязки, которые действовали при создании процедуры, снова применяются при
    применении процедуры. Это верно, даже если другая привязка для ~x~ видна там, где применяется процедура.

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (let ([x 'not-sam])
        (f 'i 'am))) ⇒ (sam i am)
#+end_src

    В обоих случаях, значение ~x~ за пределами процедуры названой ~f~ это ~sam~.

    Примечательно, что let-выражение это ни что иное, как прямое применение лямбда-выражения с целью задать аргументы
    выражения. Например, два выражения ниже эквивалентны:

#+begin_src scheme
    (let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)
#+end_src

    В действительности, let-выражение это синтаксическое выражение, определённое в терминах лямбда-выражения и
    применения процедуры, которые оба являются базовыми синтаксическими формами. В общем случае, любое выражение вида

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    эквивалентно следующему

#+begin_src scheme
    ((lambda (var ...) body1 body2 ...)
     expr ...)
#+end_src

    В секции 3.1 будут более подробно обсуждаться базовые формы и расширения синтаксиса.

    Как упоминалось выше, общая форма лямбда-выражения несколько сложнее, чем форма, рассмотренная нами ранее, в том,
    что формальное объявление параметра, ~(var ...)~, не обязано быть правильным списом, или даже списком
    вообще. Формальное объявление параметра может быть любой из трёх форм ниже:

    + правильный список переменных ~(var1 ... varN)~, как мы видели только что
    + одна переменная ~varR~
    + неправильный список переменных, ~(var1 ... varN . varR)~.

    В первом случае должно быть передано ровно ~N~ параметров, и каждая переменная связана с соответствующим
    переданным параметром. Во втором, любое количество переданных параметров валидно, все переданные параметры
    собираются в один список и единственная переменная связывается с этим списком. Третий случай это гибрид первых
    двух. По меньшей мере ~N~ параметров должно быть передано. Переменные ~var1 ... varN~ связываются с соответствующими
    переданными параметрами, а переменная ~varR~ связывается со списком, содержащим остальные переданные параметры. Во
    втором и третьем случаях, параметр ~varR~ иногда обозначают как "rest" (англ. остальные), потому что он содержит
    оставшиеся переданные параметры, помимо тех, которые индивидуально названы.

    Давайте рассмотрим несколько примеров, чтобы прояснить более общий синтаксис лямбда-выражений:

#+begin_src scheme
    (let ([f (lambda x x)])
      (f 1 2 3 4)) ⇒ (1 2 3 4)

    (let ([f (lambda x x)])
      (f)) ⇒ ()

    (let ([g (lambda (x . y) (list x y))])
      (g 1 2 3 4)) ⇒ (1 (2 3 4))

    (let ([h (lambda (x y . z) (list x y z))])
      (h 'a 'b 'c 'd)) ⇒ (a b (c d))
#+end_src

    В первых двух примерах, процедура, названная ~f~ принимает любое количество аргументов. Эти аргументы автоматически
    групируются в список, с которым связывается переменная ~x~, значение ~f~ это этот список. В первом примере,
    аргументы 1, 2, 3, 4, так что ответ ~(1 2 3 4)~. Во втором примере нет аргументов, так что ответ это пустой список
    ~()~. Значение процедуры названой ~g~, в третьем примере, это список, чей первый элемент это первый аргумент, а
    второй элемент это список, содержащий остальные аргументы. Процедура под именем ~h~ похожа, но здесь второй аргумент
    отделён. Если процедура ~f~ принимает любое количество агрументов, ~g~ должен иметь по меньшей мере один, то ~h~
    должен получать не меньше двух аргументов.

**** Упражнение 2.5.1

     Определите значения выражений ниже.

     +
#+begin_src scheme
     (let ([f (lambda (x) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda x x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) y)])
       (f 'a))
#+end_src

**** Упраженение 2.5.2

     Как может выглядеть определение примитивной процедуры ~list~?

**** Упражнение 2.5.3

     Найдите все свободные переменные в лямбда-выражениях ниже. Переменные, указывающие на примитивные процедуры, такие
     как ~+~ и ~cons~ не в счёт.

     +
#+begin_src scheme
     (lambda (f x) (f x))
#+end_src

     +
#+begin_src scheme
     (lambda (x) (+ x x))
#+end_src

     +
#+begin_src scheme
     (lambda (x y) (f x y))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (cons x (f x y)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([z (cons x y)])
         (x y z)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([y (cons x y)])
         (x y z)))
#+end_src

*** Определения верхнего уровня

    Переменные, связанные с помощью ~let~ и ~lambda~ не видны за пределами тел этих выражений. Допустим, у вас есть
    некий объект или процедура, который должен быть доступи отовсюду, например, как ~+~ или ~cons~. Вам нужно
    определение верхнего уровня, которое может быть установлено с помощью ~define~. Определения верхнего уровня,
    поддерживаемые большенством интерактивных систем Scheme, доступны в любом введённом вами выражении, за исключением
    случаев, когда оно затенено другим локальным связыванием.

    Давайте установим определение верхнего уровня для процедуры ~double-any~ из последней секции:

#+begin_src scheme
    (define double-any
      (lambda (f x)
        (f x x)))
#+end_src

    Теперь переменная ~double-any~ имеет тот же статус, что и ~cons~ или любая другая примитивная процедура. Мы можем
    использовать ~double-any~ так, как если бы это была примитивная процедура.

#+begin_src scheme
    (double-any + 10) ⇒ 20
    (double-any cons 'a) ⇒ (a . a)
#+end_src

    Определение верхнего уровня может быть установлено для любого объекта, не только процедур.

#+begin_src scheme
    (define sandwich "peanut-butter-and-jelly")

    sandwich ⇒ "peanut-butter-and-jelly"
#+end_src

    Однако чаще всего определения верхнего уровня используются для процедур.

    Как было отмечено выше, определения верхнего уровня могут быть затенены связываниями в ~let~ или ~lambda~.

#+begin_src scheme
    (define xyz '(x y z))
    (let ([xyz '(z y x)])
      xyz) ⇒ (z y x)
#+end_src

    Переменные, объявленные на верхнем уровне действуют почти так-же, как если бы они были связаны при помощи
    let-выражения, охватывающего весь ваш код.

    Учитывая только простые инструменты, о которых вы читали до этого момента, уже можно определить некоторые
    примитивные процедуры, предоставляемые Scheme и описанные далее в этой книге. Если вы прошли упражнения из прошлой
    главы, вы должны уже знать, как определить функцию ~list~.

#+begin_src scheme
    (define list (lambda x x))
#+end_src

    Также, Scheme предоставляет сокращения ~cadr~ и ~cddr~ для сочетаний ~car~ и ~cdr~ с ~cdr~. Так, ~(cadr list)~
    равнозначно ~(car (cdr list))~, а ~(cddr list)~ это ~(cdr (cdr list))~. Эти функции легко определяются, как описано
    ниже.

#+begin_src scheme
    (define cadr
      (lambda (x)
        (car (cdr x))))

    (define cddr
      (lambda (x)
        (cdr (cdr x))))

    (cadr '(a b c)) ⇒ b
    (cddr '(a b c)) ⇒ (c)
#+end_src

    Любое определение ~(define var expr)~, где ~expr~ это лямбда, может быть записано в сокращённой форме, которая
    скрывает ~lambda~. Явный синтаксис зависит от формата спецификатора формального параметра лямбда-выражения,
    т.е. будь то правильный список переменных, единственная переменная или неправильный список переменных. Определение
    формы

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN)
      e1 e2 ...)
#+end_src

    в то время как

#+begin_src scheme
    (define var0
      (lambda varR
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 . varR)
      e1 e2 ...)
#+end_src

    и

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN . varR)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN . varR)
      e1 e2 ...)
#+end_src

    Например, определения ~cadr~ и ~list~ могут быть записаны следующим образом

#+begin_src scheme
    (define (cadr x)
      (car (cdr x)))

    (define (list . x) x)

#+end_src

    В этой книге данный альтернативный синтаксис используется редко. Несмотря на короткую запись, это приводит к
    сокрытию того факта, что процедура не имеет такой тесной связи с переменными или именами, как во многих других
    языках. Этот синтаксис часто называют несколько уничижительно, как «defun» для define, после формы defun,
    введённой языками Lisp, в которой процедуры более тесно связаны с их именами.

    Определения верхнего уровня облегчают нам эксперименты с процедурой в интерактивном режиме, поскольку нам не нужно
    повторно вводить процедуру каждый раз, когда она используется.

    Давайте попробуем определить несколько более сложный вариант ~double-any~, который превращает «обычную» процедуру с
    двумя аргументами в «дублирующую» процедуру с одним аргументом.

#+begin_src scheme
    (define doubler
      (lambda (f)
        (lambda (x) (f x x))))
#+end_src

    ~doubler~ принимает один аргумент, ~f~, который должен быть процедурой, принимающей два аргумента. Процедура,
    возвращаемая ~doubler~ принимает один аргумент, который используется как оба аргумента при применении ~f~. Мы можем
    определить с помощью ~doubler~ процедуры ~double~ и ~double-cons~ из прошлой главы:

#+begin_src scheme
    (define double (doubler +))
    (double 13/2) ⇒ 13

    (define double-cons (doubler cons))
    (double-cons 'a) ⇒ (a . a)
#+end_src

    Также мы можем определить ~double-any~ с помощью ~doubler~.

#+begin_src scheme
    (define double-any
      (lambda (f x)
        ((doubler f) x)))
#+end_src

    В ~double~ и ~double-cons~, ~f~ преобретает собственное значение т.е. ~+~ или ~cons~, даже если процедуры явно
    применяются вне области действия ~f~.

    Что произойдёт, если вы попробуете использовать пременную, не связанную ~let~ или ~lambda~, а так же не имеющую
    определения на верхнем уровне? Попробуйт использовать переменную ~i-am-not-defined~ чтобы увидеть, что произойдёт.

#+begin_src scheme
    (i-am-not-defined 3)
#+end_src

    Большенство реализаций Scheme выведет сообщение, уведомляющее о том, что произошло исключение из за использования
    несвязанной или неопределённой переменной.

    Однако система не должна жаловаться на появление неопределенной переменной в лямбда-выражении до тех пор, пока не
    будет применена результирующая процедура. Следующее не должно вызывать исключения, хотя мы еще не установили
    определение верхнего уровня для ~proc2~.

#+begin_src scheme
    (define proc1
      (lambda (x y)
        (proc2 y x)))
#+end_src

    Если вы попробуете применить ~proc1~ до определения ~proc2~, вы должны получить сообщение об исключении из за
    неопределённости переменной. Давайте дадим ~proc2~ определение верхнего уровня и опробуем ~proc1~.

#+begin_src scheme
    (define proc2 cons)
    (proc1 'a 'b) ⇒ (b . a)
#+end_src

    Когда вы определяете ~proc1~ система принимает ваше обещание определить ~proc2~ и не жалуется до тех пор, пока вы не
    используете ~proc1~, так и не определив ~proc2~. Это позволяет вам определять процедуры в любом удобном для вас
    порядке. Это особенно удобно, когда ты пытаешься организовать файл, полный определений процедур, таким образом,
    чтобы сделать его более читаемым. Это так же нужно, когда две процедуры, определённых на верхнем уровне, зависят
    друг от друга, вы увидите такие примеры далее.

**** Упражнение 2.6.1

     Что произойдёт, если вы наберёте

#+begin_src scheme
     (double-any double-any double-any)
#+end_src

     давая определение ~double-any~ в начале этого раздела?

**** Упражнение 2.6.2

     Более элегантный (а также возможно менее эффективный) способ определения ~cadr~ и ~cddr~, чем данный в этой главе,
     это определить процедуру, которая объединяет две процедуры, чтобы создать третью. Создайте процедуру ~compose~,
     вида ~(compose p1 p2)~, которая будет создавать композицию процедур ~p1~ и ~p2~ (предполагается, что они ожидают по
     одному аргументу). Применение этой процедуры, ~(compose p1 p2)~, должно возвращать новую процедуру от одного
     аргумента, которая применяет ~p1~ к результату применения ~p2~ к аргументу. Используйте эту процедуру, чтобы
     определить ~cadr~ и ~cddr~.

**** Упражнение 2.6.3

     Scheme также предоставляет процедуры ~caar~, ~cdar~, ~caaar~, ~caadr~ и т.д., все компинации до четырёх /a/
     (обозначающих ~car~) или /d/ (обозначающих ~cdr~) между /c/ и /r/ (см. Главу 6.3). Определите каждую из них с
     помощью процедуры ~compose~ из предыдущего упражнения.

*** Conditional Expressions

    До сих пор мы рассматривали выражения, которые выполняют свою задачу безоговорочно. Предположим, что мы хотим
    написать процедуру ~abs~. Если аргумент ~x~ отрицательный, ~abs~ возвращает ~-x~; в противном случае возвращает
    ~х~. Самый простой способ написать ~abs~ - это определить, является ли аргумент отрицательным и, если это так,
    инвертировать его, используя синтаксическую форму ~if~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (< n 0)
            (- 0 n)
            n)))

    (abs 77) ⇒ 77
    (abs -77) ⇒ 77
#+end_src

    Выражение ~if~ имеет форму ~(if тест следствие альтернатива)~, где ~следствие~ это выражение, которое будет
    вычислено, если ~тест~ будет истиной (true), а ~альтернатива~, соответственно, выражение, которое будет выполнено в
    обратном случае т.е. если ~тест~ будет ложью (false). В выражении выше, тест это ~(< n 0)~, следствие ~(- 0 n)~, а
    альтернатива это ~n~.

    Процедура ~abs~ может быть написана множеством других способов. Любое из следующего является корректным определением
    ~abs~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (>= n 0)
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (not (< n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (or (> n 0) (= n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (= n 0)
            0
            (if (< n 0)
                (- 0 n)
                n))))

    (define abs
      (lambda (n)
        ((if (>= n 0) + -)
         0
         n)))
#+end_src

    Первое из этих определений спрашивает, является ли ~n~ больше или равно нулю, инвертируя тест. Второе спрашивает, если
    ~n~ не меньше нуля, используя процедуру ~not~ с ~<~. Третье спрашивает, является ли ~n~ больше нуля или ~n~ равно нулю,
    используя синтаксическую форму ~or~. Четвертое рассматривает ноль отдельно, хотя в этом нет никакой пользы. Пятое
    несколько хитрее; ~n~ либо прибавляется, либо вычитается из нуля, в зависимости от того, больше или равно ~n~ чем
    ноль.

    Почему ~if~ это синтаксическая форма, а не процедура? Чтобы ответить на этот вопрос, давайте вернемся к определению
    обратной величины из первого раздела этой главы.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Второй аргумент процедуры деления не должен быть нулевым, поскольку результат математически не определен. Наше
    определение обратной величины позволяет избежать этой проблемы путем проверки на ноль перед делением. Если бы ~if~
    была процедурой, её аргументы (включая ~(/ 1 n)~) были бы вычислены прежде, чем у нее была возможность выбора между
    следствием и альтернативой. Как и цитирование (~quote~), которое не вычисляет своё единственное подвыражение, ~if~
    не вычисляет все его подвыражения и поэтому не может быть процедурой.

    Синтаксическая форма ~or~ действует аналогично ~if~. Общая форма выражения ~or~ является ~(or expr ...)~. Если нет
    подвыражений, то есть выражение просто ~(or)~, значение ложно. В противном случае каждое выражение вычисляется по
    очереди, пока либо (а) одно из выражений не станет истинным, либо (б) больше не останется выражений. В случае (а)
    значение истинно; в случае (б) значение ложно.

    Чтобы быть более точным, в случае (a) значение выражения ~or~ является значением последнего вычисленного
    подвыражения. Это уточнение необходимо, потому что существует много возможных истинных значений. Обычно результатом
    тестового выражения является один из двух объектов ~#t~ для обозначения истины или ~#f~ для лжи.

#+begin_src scheme
    (< -1 0) ⇒ #t
    (> -1 0) ⇒ #f
#+end_src

    Каждый объект Scheme, любой, является либо истиной либо ложью, для условных выражений, но не для процедур. Только
    ~#f~ считается ложью, любой другой объект считается истиной.

#+begin_src scheme
    (if #t 'true 'false) ⇒ true
    (if #f 'true 'false) ⇒ false
    (if '() 'true 'false) ⇒ true
    (if 1 'true 'false) ⇒ true
    (if '(a b c) 'true 'false) ⇒ true

    (not #t) ⇒ #f
    (not "false") ⇒ #f
    (not #f) ⇒ #t

    (or) ⇒ #f
    (or #f) ⇒ #f
    (or #f #t) ⇒ #t
    (or #f 'a #f) ⇒ a
#+end_src

    Синтаксическая форма ~and~ похожа на ~or~ или, но выражение ~and~ является истинным, если все его подвыражения
    истинны, и ложным в противном случае. В случае, когда нет никаких подвыражений, то есть выражение просто ~(and)~,
    значение равно ~true~. В противном случае подвыражения вычисляются по очереди до тех пор, пока либо не останется
    подвыражений, либо значение подвыражения будет ложным. Результатом выполнения ~and~ является значение последнего
    вычисленного подвыражения.

    Используя ~and~ мы можем определить ~reciprocal~ несколько иначе:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (and (not (= n 0))
             (/ 1 n))))

    (reciprocal 3) ⇒ 1/3
    (reciprocal 0.5) ⇒ 2.0
    (reciprocal 0) ⇒ #f
#+end_src

    В этой версии значение равно ~#f~, если ~n~ равно нулю, и ~1/n~ в противном случае.

    Процедуры ~=~, ~<~, ~>~, ~<=~, и ~>=~ называются предикатами. Предикаты это процедуры, которые отвечают на
    специальный вопрос о своём аргументе и возвращают одно из двух значений, ~#t~ или ~#f~. Имена большинства предикатов
    заканчиваются знаком вопроса (?). Простейшие численные процедуры, перечисленные выше, исключение из правил. Конечно
    же не все предикаты требуют в качестве аргументов числа. Предикат ~null?~ возвращает истину, если его аргумент
    пустой список ~()~, иначе ложь.

#+begin_src scheme
    (null? '()) ⇒ #t
    (null? 'abc) ⇒ #f
    (null? '(x y z)) ⇒ #f
    (null? (cdddr '(x y z))) ⇒ #t
#+end_src

    Процедуре ~cdr~ нельзя передавать ничего, кроме пары, иначе это приведёт к исключению. В Common Lisp, однако,
    результат ~(cdr '())~ определен как ~()~. Следующая процедура, ~lisp-cdr~, определена с использованием ~null?~,
    чтобы вернуть ~()~, если её аргумент был ~()~.

#+begin_src scheme
    (define lisp-cdr
      (lambda (x)
        (if (null? x)
            '()
            (cdr x))))

    (lisp-cdr '(a b c)) ⇒ (b c)
    (lisp-cdr '(c)) ⇒ ()
    (lisp-cdr '()) ⇒ ()
#+end_src

    Еще один полезный предикат - ~eqv?~, который ожидает два аргумента. Если два аргумента эквивалентны, ~eqv?~
    возвращает истину. Иначе ~eqv?~ возвращает ложь.

#+begin_src scheme
    (eqv? 'a 'a) ⇒ #t
    (eqv? 'a 'b) ⇒ #f
    (eqv? #f #f) ⇒ #t
    (eqv? #t #t) ⇒ #t
    (eqv? #f #t) ⇒ #f
    (eqv? 3 3) ⇒ #t
    (eqv? 3 2) ⇒ #f
    (let ([x "Hi Mom!"])
      (eqv? x x)) ⇒ #t
    (let ([x (cons 'a 'b)])
      (eqv? x x)) ⇒ #t
    (eqv? (cons 'a 'b) (cons 'a 'b)) ⇒ #f
#+end_src

    Как видите, ~eqv?~ возвращает истину, если аргументы - это один и тот же символ, логическое значение, число, пара
    или строка. Две пары не считаются эквивалентными с точки зрения ~eqv?~, если они были созданы различными вызовами
    ~cons~, даже если их содержимое одинаково. Подробные правила эквивалентности для ~eqv?~ приведены в разделе 6.2.

    Scheme также предоставляет набор предикатов типа, которые возвращают истину или ложь в зависимости от типа объекта,
    например, ~pair?~, ~symbol?~, ~number?~, и ~string?~. Предикат ~pair?~, например, возвращает истину только в случае,
    если его аргумент - пара.

#+begin_src scheme
    (pair? '(a . c)) ⇒ #t
    (pair? '(a b c)) ⇒ #t
    (pair? '()) ⇒ #f
    (pair? 'abc) ⇒ #f
    (pair? "Hi Mom!") ⇒ #f
    (pair? 1234567890) ⇒ #f
#+end_src

    Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
    example, the following version of reciprocal checks first to see that its argument is a number before testing against
    zero or performing the division.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            "oops!")))

    (reciprocal 2/3) ⇒ 3/2
    (reciprocal 'a) ⇒ "oops!"
#+end_src

    Между прочим, код, использующий ~reciprocal~ должен проверять, что было возвращено процедурой - число или
    строка. Чтобы освободить пользователя процедуры от этого обязательства, обычно предпочтительно сообщить об ошибке,
    используя ~assertion-violation~ (науршение соглашения) следующим образом:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            (assertion-violation 'reciprocal
              "improper argument"
              n))))

    (reciprocal .25) ⇒ 4.0
    (reciprocal 0) ⇒ exception in reciprocal: improper argument 0
    (reciprocal 'a) ⇒ exception in reciprocal: improper argument a
#+end_src

    Первый аргумент ~assertion-violation~ это символом, показывающий, откуда исходит сообщение, второй является строкой,
    описывающей ошибку, а третий и последующие аргументы являются «раздражителями», которые будут включены в сообщение
    об ошибке.

    Давайте рассмотрим ещё одно условное выражение, ~cond~, которое часто оказывается более полезно, чем ~if~. ~cond~
    похож на ~if~ с той разницей, что он позволяет указывать множество пар тест -> выражение. Рассмотрим следующее
    определение процедуры ~sign~, которая возвращает -1, если ей передали негативный аргумент, +1 если позитивный, иначе
    ноль.

#+begin_src scheme
    (define sign
      (lambda (n)
        (if (< n 0)
            -1
            (if (> n 0)
                +1
                0))))

    (sign -88.3) ⇒ -1
    (sign 0) ⇒ 0
    (sign 333333333333) ⇒ 1
    (* (sign -88.3) (abs -88.3)) ⇒ -88.3
#+end_src

    Эти два ~if~ выражения могут быть заменены одним ~cond~ следующим образом:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [else 0])))
#+end_src

    Выражение ~cond~ обычно имеет следующую форму:

#+begin_src scheme
    (cond (test expr) ... (else expr))
#+end_src

    Конечно же клауза ~else~ может быть опущена. Это следует делать только в том случае, если невозможно, чтобы все
    тесты провалились, как в новой версии ~sign~ ниже:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [(= n 0) 0])))
#+end_src

    В этом определении ~sign~ не зависит от порядка в котором тесты будут проводиться, потому что только один из тестов
    может быть истиной, для любого ~n~. Следующая процедура рассчитывает налог для указанного дохода в прогрессивной
    налоговой системе с контрольными точками для 10000, 20000, 30000 долларов.

#+begin_src scheme
    (define income-tax
      (lambda (income)
        (cond
          [(<= income 10000) (* income .05)]
          [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
          [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
          [else (+ (* (- income 30000) .21) 2600.00)])))

    (income-tax 5000) ⇒ 250.0
    (income-tax 15000) ⇒ 900.0
    (income-tax 25000) ⇒ 1950.0
    (income-tax 50000) ⇒ 6800.0
#+end_src

    В этом примере важен порядок выполнения тестов - слева направо (сверху вниз).

**** Exercise 2.7.1

     Определите предикат ~atom?~, который возвращает истину, если его аргумент не пара и ложь в обратном случае.

**** Exercise 2.7.2

     Процедура ~length~ возвращает длину своего аргумента, который должен быть списком. Например, ~(length '(a b c))~
     это 3. Используя ~length~, определите процедуру ~shorter~, возвращающую кратчайший из двух списков в
     аргументах. Пусть она возвращает первый список, если длины равны.

#+begin_src scheme
     (shorter '(a b) '(c d e)) ⇒ (a b)
     (shorter '(a b) '(c d)) ⇒ (a b)
     (shorter '(a b) '(c)) ⇒ (c)
#+end_src

*** Simple Recursion

    We have seen how we can control whether or not expressions are evaluated with if, and, or, and cond. We can also
    perform an expression more than once by creating a procedure containing the expression and invoking the procedure
    more than once. What if we need to perform some expression repeatedly, say for all the elements of a list or all the
    numbers from one to ten? We can do so via recursion. Recursion is a simple concept: the application of a procedure
    from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive
    power far beyond ordinary looping constructs.

    A recursive procedure is a procedure that applies itself. Perhaps the simplest recursive procedure is the following,
    which we will call goodbye.

#+begin_src scheme
    (define goodbye
      (lambda ()
        (goodbye)))

    (goodbye) ⇒
#+end_src

    This procedure takes no arguments and simply applies itself immediately. There is no value after the ⇒
    because goodbye never returns.

    Obviously, to make practical use out of a recursive procedure, we must have some way to terminate the recursion. Most
    recursive procedures should have at least two basic elements, a base case and a recursion step. The base case
    terminates the recursion, giving the value of the procedure for some base argument. The recursion step gives the
    value in terms of the value of the procedure applied to a different argument. In order for the recursion to
    terminate, the different argument must be closer to the base argument in some way.

    Let's consider the problem of finding the length of a proper list recursively. We need a base case and a recursion
    step. The logical base argument for recursion on lists is nearly always the empty list. The length of the empty list
    is zero, so the base case should give the value zero for the empty list. In order to become closer to the empty list,
    the natural recursion step involves the cdr of the argument. A nonempty list is one element longer than its cdr, so
    the recursion step gives the value as one more than the length of the cdr of the list.

#+begin_src scheme
    (define length
      (lambda (ls)
        (if (null? ls)
            0
            (+ (length (cdr ls)) 1))))

    (length '()) ⇒ 0
    (length '(a)) ⇒ 1
    (length '(a b)) ⇒ 2
#+end_src

    The if expression asks if the list is empty. If so, the value is zero. This is the base case. If not, the value is
    one more than the length of the cdr of the list. This is the recursion step.

    Many Scheme implementations allow you to trace the execution of a procedure to see how it operates. In Chez Scheme,
    for example, one way to trace a procedure is to type (trace name), where name is the name of a procedure you have
    defined at top level. If you trace length as defined above and pass it the argument '(a b c d), you should see
    something like this:

#+BEGIN_EXAMPLE
    |(length (a b c d))
    | (length (b c d))
    | |(length (c d))
    | | (length (d))
    | | |(length ())
    | | |0
    | | 1
    | |2
    | 3
    |4
#+END_EXAMPLE

    The indentation shows the nesting level of the recursion; the vertical lines associate applications visually with
    their values. Notice that on each application of length the list gets smaller until it finally reaches (). The value
    at () is 0, and each outer level adds 1 to arrive at the final value.

    Let's write a procedure, list-copy, that returns a copy of its argument, which must be a list. That is, list-copy
    returns a new list consisting of the elements (but not the pairs) of the old list. Making a copy might be useful if
    either the original list or the copy might be altered via set-car! or set-cdr!, which we discuss later.

#+begin_src scheme
    (list-copy '()) ⇒ ()
    (list-copy '(a b c)) ⇒ (a b c)
#+end_src

    See if you can define list-copy before studying the definition below.

#+begin_src scheme
    (define list-copy
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (car ls)
                  (list-copy (cdr ls))))))
#+end_src

    The definition of list-copy is similar to the definition of length. The test in the base case is the same, (null?
    ls). The value in the base case is (), however, not 0, because we are building up a list, not a number. The recursive
    call is the same, but instead of adding one, list-copy conses the car of the list onto the value of the recursive
    call.

    There is no reason why there cannot be more than one base case. The procedure memv takes two arguments, an object and
    a list. It returns the first sublist, or tail, of the list whose car is equal to the object, or #f if the object is
    not found in the list. The value of memv may be used as a list or as a truth value in a conditional expression.

#+begin_src scheme
    (define memv
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eqv? (car ls) x) ls]
          [else (memv x (cdr ls))])))

    (memv 'a '(a b b d)) ⇒ (a b b d)
    (memv 'b '(a b b d)) ⇒ (b b d)
    (memv 'c '(a b b d)) ⇒ #f
    (memv 'd '(a b b d)) ⇒ (d)
    (if (memv 'b '(a b b d))
        "yes"
        "no") ⇒ "yes"
#+end_src

    Here there are two conditions to check, hence the use of cond. The first cond clause checks for the base value of ();
    no object is a member of (), so the answer is #f. The second clause asks if the car of the list is the object, in
    which case the list is returned, being the first tail whose car contains the object. The recursion step just
    continues down the list.

    There may also be more than one recursion case. Like memv, the procedure remv defined below takes two arguments, an
    object and a list. It returns a new list with all occurrences of the object removed from the list.

#+begin_src scheme
    (define remv
      (lambda (x ls)
        (cond
          [(null? ls) '()]
          [(eqv? (car ls) x) (remv x (cdr ls))]
          [else (cons (car ls) (remv x (cdr ls)))])))

    (remv 'a '(a b b d)) ⇒ (b b d)
    (remv 'b '(a b b d)) ⇒ (a d)
    (remv 'c '(a b b d)) ⇒ (a b b d)
    (remv 'd '(a b b d)) ⇒ (a b b)
#+end_src

    This definition is similar to the definition of memv above, except remv does not quit once it finds the element in
    the car of the list. Rather, it continues, simply ignoring the element. If the element is not found in the car of the
    list, remv does the same thing as list-copy above: it conses the car of the list onto the recursive value.

    Up to now, the recursion has been only on the cdr of a list. It is sometimes useful, however, for a procedure to
    recur on the car as well as the cdr of the list. The procedure tree-copy defined below treats the structure of pairs
    as a tree rather than as a list, with the left subtree being the car of the pair and the right subtree being the cdr
    of the pair. It performs a similar operation to list-copy, building new pairs while leaving the elements (leaves)
    alone.

#+begin_src scheme
    (define tree-copy
      (lambda (tr)
        (if (not (pair? tr))
            tr
            (cons (tree-copy (car tr))
                  (tree-copy (cdr tr))))))

    (tree-copy '((a . b) . c)) ⇒ ((a . b) . c)
#+end_src

    The natural base argument for a tree structure is anything that is not a pair, since the recursion traverses pairs
    rather than lists. The recursive step in this case is doubly recursive, finding the value recursively for the car as
    well as the cdr of the argument.

    At this point, readers who are familiar with other languages that provide special iteration constructs, e.g., while
    or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary;
    iteration in Scheme is expressed more clearly and succinctly via recursion. Recursion is more general and eliminates
    the need for the variable assignments required by many other languages' iteration constructs, resulting in code that
    is more reliable and easier to follow. Some recursion is essentially iteration and executes as such; Section 3.2 has
    more to say about this. Often, there is no need to make a distinction, however. Concentrate instead on writing clear,
    concise, and correct programs.

    Before we leave the topic of recursion, let's consider a special form of repetition called mapping. Consider the
    following procedure, abs-all, that takes a list of numbers as input and returns a list of their absolute values.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (abs (car ls))
                  (abs-all (cdr ls))))))

    (abs-all '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    This procedure forms a new list from the input list by applying the procedure abs to each element. We say that
    abs-all maps abs over the input list to produce the output list. Mapping a procedure over a list is a fairly common
    thing to do, so Scheme provides the procedure map, which maps its first argument, a procedure, over its second, a
    list. We can use map to define abs-all.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (map abs ls)))
#+end_src

    We really do not need abs-all, however, since the corresponding direct application of map is just as short and
    perhaps clearer.

#+begin_src scheme
    (map abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    Of course, we can use lambda to create the procedure argument to map, e.g., to square the elements of a list of
    numbers.

#+begin_src scheme
    (map (lambda (x) (* x x))
         '(1 -3 -5 7)) ⇒ (1 9 25 49)
#+end_src

    We can map a multiple-argument procedure over multiple lists, as in the following example.

#+begin_src scheme
    (map cons '(a b c) '(1 2 3)) ⇒ ((a . 1) (b . 2) (c . 3))
#+end_src

    The lists must be of the same length, and the procedure should accept as many arguments as there are lists. Each
    element of the output list is the result of applying the procedure to corresponding members of the input list.

    Looking at the first definition of abs-all above, you should be able to derive, before studying it, the following
    definition of map1, a restricted version of map that maps a one-argument procedure over a single list.

#+begin_src scheme
    (define map1
      (lambda (p ls)
        (if (null? ls)
            '()
            (cons (p (car ls))
                  (map1 p (cdr ls))))))

    (map1 abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)
#+end_src

    All we have done is to replace the call to abs in abs-all with a call to the new parameter p. A definition of the
    more general map is given in Section 5.4.

**** Exercise 2.8.1

     Describe what would happen if you switched the order of the arguments to cons in the definition of tree-copy.

**** Exercise 2.8.2

     Consult Section 6.3 for the description of append and define a two-argument version of it. What would happen if you
     switched the order of the arguments in the call to append within your definition of append?

**** Exercise 2.8.3

     Define the procedure make-list, which takes a nonnegative integer n and an object and returns a new list, n long,
     each element of which is the object.

#+begin_src scheme
     (make-list 7 '()) ⇒ (() () () () () () ())
#+end_src

     [Hint: The base test should be (= n 0), and the recursion step should involve (- n 1). Whereas () is the natural base
     case for recursion on lists, 0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
     1 is the natural way to bring a nonnegative integer closer to 0.]

**** Exercise 2.8.4

     The procedures list-ref and list-tail return the nth element and nth tail of a list ls.

#+begin_src scheme
     (list-ref '(1 2 3 4) 0) ⇒ 1
     (list-tail '(1 2 3 4) 0) ⇒ (1 2 3 4)
     (list-ref '(a short (nested) list) 2) ⇒ (nested)
     (list-tail '(a short (nested) list) 2) ⇒ ((nested) list)
#+end_src

     Define both procedures.

**** Exercise 2.8.5

     Exercise 2.7.2 had you use length in the definition of shorter, which returns the shorter of its two list arguments,
     or the first if the two have the same length. Write shorter without using length. [Hint: Define a recursive helper,
     shorter?, and use it in place of the length comparison.]

**** Exercise 2.8.6

     All of the recursive procedures shown so far have been directly recursive. That is, each procedure directly applies
     itself to a new argument. It is also possible to write two procedures that use each other, resulting in indirect
     recursion. Define the procedures odd? and even?, each in terms of the other. [Hint: What should each return when its
     argument is 0?]

#+begin_src scheme
     (even? 17) ⇒ #f
     (odd? 17) ⇒ #t
#+end_src

**** Exercise 2.8.7

     Use map to define a procedure, transpose, that takes a list of pairs and returns a pair of lists as follows.

#+begin_src scheme
     (transpose '((a . 1) (b . 2) (c . 3))) ⇒ ((a b c) 1 2 3)
#+end_src

     [Hint: ((a b c) 1 2 3) is the same as ((a b c) . (1 2 3)).]

*** Assignment

    Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound
    variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the
    values of existing bindings. Assignments are performed with set!.

#+begin_src scheme
    (define abcde '(a b c d e))
    abcde ⇒ (a b c d e)
    (set! abcde (cdr abcde))
    abcde ⇒ (b c d e)
    (let ([abcde '(a b c d e)])
      (set! abcde (reverse abcde))
      abcde) ⇒ (e d c b a)
#+end_src

    Many languages require the use of assignments to initialize local variables, separate from the declaration or binding
    of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the
    separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to
    initialize them, a common source of errors in most languages.

    In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and
    inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One
    common practice in some languages is to sequence expression evaluation with a series of assignments, as in the
    following procedure that finds the roots of a quadratic equation.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
          (cons root1 root2))))
#+end_src

    The roots are computed according to the well-known quadratic formula,

#+ATTR_LATEX: :width 60px
[[./images/4.png]]

    which yields the solutions to the equation 0 = ax2 + bx + c. The let expression in this definition is employed solely
    to establish the variable bindings, corresponding to the declarations required in other languages. The first three
    assignment expressions compute subpieces of the formula, namely -b,

#+ATTR_LATEX: :width 60px
[[./images/5.png]]

    and 2a. The last two assignment
    expressions compute the two roots in terms of the subpieces. A pair of the two roots is the value of
    quadratic-formula. For example, the two roots of 2x2 - 4x - 6 are x = 3 and x = -1.

#+begin_src scheme
    (quadratic-formula 2 -4 -6) ⇒ (3 . -1)
#+end_src

    The definition above works, but it can be written more clearly without the assignments, as shown below.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([minusb (- 0 b)]
              [radical (sqrt (- (* b b) (* 4 (* a c))))]
              [divisor (* 2 a)])
          (let ([root1 (/ (+ minusb radical) divisor)]
                [root2 (/ (- minusb radical) divisor)])
            (cons root1 root2)))))
#+end_src

    In this version, the set! expressions are gone, and we are left with essentially the same algorithm. By employing two
    let expressions, however, the definition makes clear the dependency of root1 and root2 on the values of minusb,
    radical, and divisor. Equally important, the let expressions make clear the lack of dependencies among minusb,
    radical, and divisor and between root1 and root2.

    Assignments do have some uses in Scheme, otherwise the language would not support them. Consider the following
    version of cons that counts the number of times it is called, storing the count in a variable named cons-count. It
    uses set! to increment the count; there is no way to achieve the same behavior without assignments.

#+begin_src scheme
    (define kons-count 0)
    (define kons
      (lambda (x y)
        (set! kons-count (+ kons-count 1))
        (cons x y)))
#+end_src

#+begin_src scheme
    (kons 'a '(b c)) ⇒ (a b c)
    kons-count ⇒ 1
    (kons 'a (kons 'b (kons 'c '()))) ⇒ (a b c)
    kons-count ⇒ 4
#+end_src

    Assignments are commonly used to implement procedures that must maintain some internal state. For example, suppose we
    would like to define a procedure that returns 0 the first time it is called, 1 the second time, 2 the third time, and
    so on indefinitely. We could write something similar to the definition of cons-count above:

#+begin_src scheme
    (define next 0)
    (define count
      (lambda ()
        (let ([v next])
          (set! next (+ next 1))
          v)))

    (count) ⇒ 0
    (count) ⇒ 1
#+end_src

    This solution is somewhat undesirable in that the variable next is visible at top level even though it need not
    be. Since it is visible at top level, any code in the system can change its value, perhaps inadvertently affecting
    the behavior of count in a subtle way. We can solve this problem by let-binding next outside of the lambda
    expression:

#+begin_src scheme
    (define count
      (let ([next 0])
        (lambda ()
          (let ([v next])
            (set! next (+ next 1))
            v))))
#+end_src

    The latter solution also generalizes easily to provide multiple counters, each with its own local counter. The
    procedure make-counter, defined below, returns a new counting procedure each time it is called.

#+begin_src scheme
    (define make-counter
      (lambda ()
        (let ([next 0])
          (lambda ()
            (let ([v next])
              (set! next (+ next 1))
              v)))))
#+end_src

    Since next is bound inside of make-counter but outside of the procedure returned by make-counter, each procedure it
    returns maintains its own unique counter.

#+begin_src scheme
    (define count1 (make-counter))
    (define count2 (make-counter))

    (count1) ⇒ 0
    (count2) ⇒ 0
    (count1) ⇒ 1
    (count1) ⇒ 2
    (count2) ⇒ 1
#+end_src

    If a state variable must be shared by more than one procedure defined at top level, but we do not want the state
    variable to be visible at top level, we can use let to bind the variable and set! to make the procedures visible at
    top level.

#+begin_src scheme
    (define shhh #f)
    (define tell #f)
    (let ([secret 0])
      (set! shhh
        (lambda (message)
          (set! secret message)))
      (set! tell
        (lambda ()
          secret)))

    (shhh "sally likes harry")
    (tell) ⇒ "sally likes harry"
    secret ⇒ exception: variable secret is not bound
#+end_src

    Variables must be defined before they can be assigned, so we define shhh and tell to be #f initially. (Any initial
    value would do.) We'll see this structure again in Section 3.5 and a better way to structure code like this as a
    library in Section 3.6.

    Local state is sometimes useful for caching computed values or allowing a computation to be evaluated lazily, i.e.,
    only once and only on demand. The procedure lazy below accepts a thunk, or zero-argument procedure, as an
    argument. Thunks are often used to "freeze" computations that must be delayed for some reason, which is exactly what
    we need to do in this situation. When passed a thunk t, lazy returns a new thunk that, when invoked, returns the
    value of invoking t. Once computed, the value is saved in a local variable so that the computation need not be
    performed again. A boolean flag is used to record whether t has been invoked and its value saved.

#+begin_src scheme
    (define lazy
      (lambda (t)
        (let ([val #f] [flag #f])
          (lambda ()
            (if (not flag)
                (begin (set! val (t))
                       (set! flag #t)))
            val))))
#+end_src

    The syntactic form begin, used here for the first time, evaluates its subexpressions in sequence from left to right
    and returns the value of the last subexpression, like the body of a let or lambda expression. We also see that the
    alternative subexpression of an if expression can be omitted. This should be done only when the value of the if is
    discarded, as it is in this case.

    Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the
    evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than
    once.

    The operation of lazy can best be illustrated by printing a message from within a thunk passed to lazy.

#+begin_src scheme
    (define p
      (lazy (lambda ()
              (display "Ouch!")
              (newline)
              "got me")))
#+end_src

    The first time p is invoked, the message Ouch! is printed and the string "got me" is returned. Thereafter, "got me"
    is returned but the message is not printed. The procedures display and newline are the first examples of explicit
    input/output we have seen; display prints the string without quotation marks, and newline prints a newline
    character.

    To further illustrate the use of set!, let's consider the implementation of stack objects whose internal workings are
    not visible on the outside. A stack object accepts one of four messages: empty?, which returns #t if the stack is
    empty; push!, which adds an object to the top of the stack; top, which returns the object on the top of the stack;
    and pop!, which removes the object on top of the stack. The procedure make-stack given below creates a new stack each
    time it is called in a manner similar to make-counter.

#+begin_src scheme
    (define make-stack
      (lambda ()
        (let ([ls '()])
          (lambda (msg . args)
            (cond
              [(eqv? msg 'empty?) (null? ls)]
              [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
              [(eqv? msg 'top) (car ls)]
              [(eqv? msg 'pop!) (set! ls (cdr ls))]
              [else "oops"])))))
#+end_src

    Each stack is stored as a list bound to the variable ls; set! is used to change this binding for push! and
    pop!. Notice that the argument list of the inner lambda expression uses the improper list syntax to bind args to a
    list of all arguments but the first. This is useful here because in the case of empty?, top, and pop! there is only
    one argument (the message), but in the case of push! there are two (the message and the object to push onto the
    stack).

#+begin_src scheme
    (define stack1 (make-stack))
    (define stack2 (make-stack))
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #t)

    (stack1 'push! 'a)
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #t)

    (stack1 'push! 'b)
    (stack2 'push! 'c)
    (stack1 'top) ⇒ b
    (stack2 'top) ⇒ c

    (stack1 'pop!)
    (stack1 'top) ⇒ a
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #f)

    (stack1 'pop!)
    (list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #f)
#+end_src

    As with the counters created by make-counter, the state maintained by each stack object is directly accessible only
    within the object. Each reference or change to this state is made explicitly by the object itself. One important
    benefit is that we can change the internal structure of the stack, perhaps to use a vector (see Section 6.9) instead
    of a list to hold the elements, without changing its external behavior. Because the behavior of the object is known
    abstractly (not operationally), it is known as an abstract object. See Section 12.8 for more about creating abstract
    objects.

    In addition to changing the values of variables, we can also change the values of the car and cdr fields of a pair,
    using the procedures set-car! and set-cdr!.

#+begin_src scheme
    (define p (list 1 2 3))
    (set-car! (cdr p) 'two)
    p ⇒ (1 two 3)
    (set-cdr! p '())
    p ⇒ (1)
#+end_src

    We can use these operators to define a queue data type, which is like a stack except that new elements are added at
    one end and extracted from the other. The following queue implementation uses a tconc structure. A tconc consists of
    a nonempty list and a header. The header is a pair whose car points to the first pair (head) of the list and whose
    cdr points to the last pair (end) of the list.

#+ATTR_LATEX: :width 200px
[[./images/6.png]]

    The last element of the list is a placeholder and not considered part of the queue.

    Four operations on queues are defined below: make-queue, which constructs a queue; putq!, which adds an element to
    the end of a queue; getq, which retrieves the element at the front of a queue; and delq!, which removes the element
    at the front of a queue.

#+begin_src scheme
    (define make-queue
      (lambda ()
        (let ([end (cons 'ignored '())])
          (cons end end))))

    (define putq!
      (lambda (q v)
        (let ([end (cons 'ignored '())])
          (set-car! (cdr q) v)
          (set-cdr! (cdr q) end)
          (set-cdr! q end))))

    (define getq
      (lambda (q)
        (car (car q))))

    (define delq!
      (lambda (q)
        (set-car! q (cdr (car q)))))
#+end_src

    All are simple operations except for putq!, which modifies the end pair to contain the new value and adds a new end
    pair.

#+begin_src scheme
    (define myq (make-queue))

    (putq! myq 'a)
    (putq! myq 'b)
    (getq myq) ⇒ a
    (delq! myq)
    (getq myq) ⇒ b
    (delq! myq)
    (putq! myq 'c)
    (putq! myq 'd)
    (getq myq) ⇒ c
    (delq! myq)
    (getq myq) ⇒ d
#+end_src

**** Exercise 2.9.1

     Modify make-counter to take two arguments: an initial value for the counter to use in place of 0 and an amount to
     increment the counter by each time.

**** Exercise 2.9.2

     Look up the description of case in Section 5.3. Replace the cond expression in make-stack with an equivalent case
     expression. Add mt? as a second name for the empty? message.

**** Exercise 2.9.3

     Modify the stack object to allow the two messages ref and set!. (stack 'ref i) should return the ith element from the
     top of the stack; (stack 'ref 0) should be equivalent to (stack 'top). (stack 'set! i v) should change the ith
     element from the top of the stack to v.

#+begin_src scheme
     (define stack (make-stack))

     (stack 'push! 'a)
     (stack 'push! 'b)
     (stack 'push! 'c)

     (stack 'ref 0) ⇒ c
     (stack 'ref 2) ⇒ a
     (stack 'set! 1 'd)
     (stack 'ref 1) ⇒ d
     (stack 'top) ⇒ c
     (stack 'pop!)
     (stack 'top) ⇒ d
#+end_src

     [Hint: Use list-ref to implement ref and list-tail with set-car! to implement set!.]

**** Exercise 2.9.4

     Scheme supports vectors as well as lists. Like lists, vectors are aggregate objects that contain other
     objects. Unlike lists, vectors have a fixed size and are laid out in one flat block of memory, typically with a
     header containing the length of the vector, as in the ten-element vector below.

#+ATTR_LATEX: :width 200px
[[./images/7.png]]

     This makes vectors more suitable for applications needing fast access to any element of the aggregate but less
     suitable for applications needing data structures that grow and shrink as needed.

     Look up the basic vector operations in Section 6.9 and reimplement the stack object to use a vector instead of a list
     to hold the stack contents. Include the ref and set! messages of Exercise 2.9.3. Have the new make-stack accept a
     size argument n and make the vector length n, but do not otherwise change the external (abstract) interface.

**** Exercise 2.9.5

     Define a predicate, emptyq?, for determining if a queue is empty. Modify getq and delq! to raise an exception when an
     empty queue is found, using assertion-violation.

**** Exercise 2.9.6

     In the queue implementation, the last pair in the encapsulated list is a placeholder, i.e., it never holds anything
     useful. Recode the queue operators to avoid this wasted pair. Make sure that the series of queue operations given
     earlier works with the new implementation. Which implementation do you prefer?

**** Exercise 2.9.7

     Using set-cdr!, it is possible to create cyclic lists. For example, the following expression evaluates to a list
     whose car is the symbol a and whose cdr is the list itself.

#+begin_src scheme
     (let ([ls (cons 'a '())])
       (set-cdr! ls ls)
       ls)
#+end_src

     What happens when you enter the above expression during an interactive Scheme session? What will the implementation
     of length on page 42 do when given a cyclic list? What does the built-in length primitive do?

**** Exercise 2.9.8

     Define the predicate list?, which returns #t if its argument is a proper list and #f otherwise (see Section 6.3). It
     should return #f for cyclic lists as well as for lists terminated by objects other than ().

#+begin_src scheme
     (list? '()) ⇒ #t
     (list? '(1 2 3)) ⇒ #t
     (list? '(a . b)) ⇒ #f
     (list? (let ([ls (cons 'a '())])
              (set-cdr! ls ls)
              ls)) ⇒ #f
#+end_src

     First write a simplified version of list? that does not handle cyclic lists, then extend this to handle cyclic lists
     correctly. Revise your definition until you are satisfied that it is as clear and concise as possible. [Hint: Use the
     following "hare and tortoise" algorithm to detect cycles. Define a recursive help procedure of two arguments, the
     hare and the tortoise. Start both the hare and the tortoise at the beginning of the list. Have the hare advance by
     two cdrs each time the tortoise advances by one cdr. If the hare catches the tortoise, there must be a cycle.]


#+LATEX: \newpage
[[./images/ch3.png]]

** Going Further
   The preceding chapter prepared you to write Scheme programs using a small set of the most useful primitive syntactic
   forms and procedures. This chapter introduces a number of additional features and programming techniques that will
   allow you to write more sophisticated and efficient programs.

*** Syntactic Extension
    As we saw in Section 2.5, the let syntactic form is merely a syntactic extension defined in terms of a lambda
    expression and a procedure application, both core syntactic forms. At this point, you might be wondering which
    syntactic forms are core forms and which are syntactic extensions, and how new syntactic extensions may be
    defined. This section provides some answers to these questions.

    In truth, it is not necessary for us to draw a distinction between core forms and syntactic extensions, since once
    defined, a syntactic extension has exactly the same status as a core form. Drawing a distinction, however, makes
    understanding the language easier, since it allows us to focus attention on the core forms and to understand all
    others in terms of them.

    It is necessary for a Scheme implementation to distinguish between core forms and syntactic extensions. A Scheme
    implementation expands syntactic extensions into core forms as the first step of compilation or interpretation,
    allowing the rest of the compiler or interpreter to focus only on the core forms. The set of core forms remaining
    after expansion to be handled directly by the compiler or interpreter is implementation-dependent, however, and may
    be different from the set of forms described as core here.

    The exact set of syntactic forms making up the core of the language is thus subject to debate, although it must be
    possible to derive all other forms from any set of forms declared to be core forms. The set described here is among
    the simplest for which this constraint is satisfied.

    The core syntactic forms include top-level define forms, constants, variables, procedure applications, quote
    expressions, lambda expressions, if expressions, and set! expressions. The grammar below describes the core syntax of
    Scheme in terms of these definitions and expressions. In the grammar, vertical bars ( | ) separate alternatives, and a
    form followed by an asterisk ( * ) represents zero or more occurrences of the form. <variable> is any Scheme
    identifier. <datum> is any Scheme object, such as a number, list, symbol, or vector. <boolean> is either #t or #f,
    <number> is any number, <character> is any character, and <string> is any string. We have already seen examples of
    numbers, strings, lists, symbols, and booleans. See Chapter 6 or the formal syntax description starting on page 455 for
    more on the object-level syntax of these and other objects.

#+BEGIN_EXAMPLE
    <program>             → <form>*
    <form>                → <definition> | <expression>
    <definition>          → <variable definition> | (begin <definition>*)
    <variable definition> → (define <variable> <expression>)
    <expression>          → <constant>
                          | <variable>
                          | (quote <datum>)
                          | (lambda <formals> <expression> <expression>*)
                          | (if <expression> <expression> <expression>)
                          | (set! <variable> <expression>)
                          | <application>
    <constant>            → <boolean> | <number> | <character> | <string>
    <formals>             → <variable>
                          | (<variable>*)
                          | (<variable> <variable>* . <variable>)
    <application>         → (<expression> <expression>*)
#+END_EXAMPLE

    The grammar is ambiguous in that the syntax for procedure applications conflicts with the syntaxes for quote, lambda,
    if, and set! expressions. In order to qualify as a procedure application, the first <expression> must not be one of
    these keywords, unless the keyword has been redefined or locally bound.

    The "defun" syntax for define given in Section 2.6 is not included in the core, since definitions in that form are
    straightforwardly translated into the simpler define syntax. Similarly, the core syntax for if does not permit the
    alternative to be omitted, as did one example in Section 2.9. An if expression lacking an alternative can be
    translated into the core syntax for if merely by replacing the missing subexpression with an arbitrary constant, such
    as #f.

    A begin that contains only definitions is considered to be a definition in the grammar; this is permitted in order to
    allow syntactic extensions to expand into more than one definition. begin expressions, i.e., begin forms containing
    expressions, are not considered core forms. A begin expression of the form

#+begin_src scheme
    (begin e1 e2 ...)
#+end_src

    is equivalent to the lambda application

#+begin_src scheme
    ((lambda () e1 e2 ...))
#+end_src

    and hence need not be considered core.

    Now that we have established a set of core syntactic forms, let's turn to a discussion of syntactic
    extensions. Syntactic extensions are so called because they extend the syntax of Scheme beyond the core syntax. All
    syntactic extensions in a Scheme program must ultimately be derived from the core forms. One syntactic extension,
    however, may be defined in terms of another syntactic extension, as long as the latter is in some sense "closer" to
    the core syntax. Syntactic forms may appear anywhere an expression or definition is expected, as long as the extended
    form expands into a definition or expression as appropriate.

    Syntactic extensions are defined with define-syntax. define-syntax is similar to define, except that define-syntax
    associates a syntactic transformation procedure, or transformer, with a keyword (such as let), rather than
    associating a value with a variable. Here is how we might define let with define-syntax.

#+begin_src scheme
    (define-syntax let
      (syntax-rules ()
        [(_ ((x e) ...) b1 b2 ...)
         ((lambda (x ...) b1 b2 ...) e ...)]))
#+end_src

    The identifier appearing after define-syntax is the name, or keyword, of the syntactic extension being defined, in
    this case let. The syntax-rules form is an expression that evaluates to a transformer. The item following
    syntax-rules is a list of auxiliary keywords and is nearly always (). An example of an auxiliary keyword is the else
    of cond. (Other examples requiring the use of auxiliary keywords are given in Chapter 8.) Following the list of
    auxiliary keywords is a sequence of one or more rules, or pattern/template pairs. Only one rule appears in our
    definition of let. The pattern part of a rule specifies the form that the input must take, and the template specifies
    to what the input should be transformed.

    The pattern should always be a structured expression whose first element is an underscore ( _ ). (As we will see in
    Chapter 8, the use of _ is only a convention, but it is a good one to follow.) If more than one rule is present, the
    appropriate one is chosen by matching the patterns, in order, against the input during expansion. It is a syntax
    violation if none of the patterns match the input.

    Identifiers other than an underscore or ellipsis appearing within a pattern are pattern variables, unless they are
    listed as auxiliary keywords. Pattern variables match any substructure and are bound to that substructure within the
    corresponding template. The notation pat ... in the pattern allows for zero or more expressions matching the ellipsis
    prototype pat in the input. Similarly, the notation expr ... in the template produces zero or more expressions from
    the ellipsis prototype expr in the output. The number of pats in the input determines the number of exprs in the
    output; in order for this to work, any ellipsis prototype in the template must contain at least one pattern variable
    from an ellipsis prototype in the pattern.

    The single rule in our definition of let should be fairly self-explanatory, but a few points are worth
    mentioning. First, the syntax of let requires that the body contain at least one form; hence, we have specified b1 b2
    ... instead of b ..., which might seem more natural. On the other hand, let does not require that there be at least
    one variable/value pair, so we were able to use, simply, (x e) .... Second, the pattern variables x and e, though
    together within the same prototype in the pattern, are separated in the template; any sort of rearrangement or
    recombination is possible. Finally, the three pattern variables x, e, and b2 that appear in ellipsis prototypes in
    the pattern also appear in ellipsis prototypes in the template. This is not a coincidence; it is a requirement. In
    general, if a pattern variable appears within an ellipsis prototype in the pattern, it cannot appear outside an
    ellipsis prototype in the template.

    The definition of and below is somewhat more complex than the one for ~let~.

#+begin_src scheme
    (define-syntax and
      (syntax-rules ()
        [(_) #t]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (if e1 (and e2 e3 ...) #f)]))
#+end_src

    This definition is recursive and involves more than one rule. Recall that (and) evaluates to #t; the first rule takes
    care of this case. The second and third rules specify the base case and recursion steps of the recursion and together
    translate and expressions with two or more subexpressions into nested if expressions. For example, (and a b c)
    expands first into

#+begin_src scheme
    (if a (and b c) #f)
#+end_src

    then

#+begin_src scheme
    (if a (if b (and c) #f) #f)
#+end_src

    and finally

#+begin_src scheme
    (if a (if b c #f) #f)
#+end_src

    With this expansion, if a and b evaluate to a true value, then the value is the value of c, otherwise #f, as desired.

    The version of and below is simpler but, unfortunately, incorrect.

#+begin_src scheme
    (define-syntax and ; incorrect!
      (syntax-rules ()
        [(_) #t]
        [(_ e1 e2 ...)
         (if e1 (and e2 ...) #f)]))
#+end_src

    The expression

#+begin_src scheme
    (and (not (= x 0)) (/ 1 x))
#+end_src

    should return the value of (/ 1 x) when x is not zero. With the incorrect version of and, the expression expands as
    follows.

#+begin_src scheme
    (if (not (= x 0)) (and (/ 1 x)) #f) →
    (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) →
    (if (not (= x 0)) (if (/ 1 x) #t #f) #f)
#+end_src

    The final answer if x is not zero is #t, not the value of (/ 1 x).

    The definition of or below is similar to the one for and except that a temporary variable must be introduced for each
    intermediate value so that we can both test the value and return it if it is a true value. (A temporary variable is not
    needed for and since there is only one false value, #f.)

#+begin_src scheme
    (define-syntax or
      (syntax-rules ()
        [(_) #f]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (let ([t e1])
           (if t t (or e2 e3 ...)))]))
#+end_src

    Like variables bound by lambda or let, identifiers introduced by a template are lexically scoped, i.e., visible only
    within expressions introduced by the template. Thus, even if one of the expressions e2 e3 ... contains a reference to
    t, the introduced binding for t does not "capture" those references. This is typically accomplished via automatic
    renaming of introduced identifiers.

    As with the simpler version of and given above, the simpler version of or below is incorrect.

#+begin_src scheme
    (define-syntax or ; incorrect!
      (syntax-rules ()
        [(_) #f]
        [(_ e1 e2 ...)
         (let ([t e1])
           (if t t (or e2 ...)))]))
#+end_src

    The reason is more subtle, however, and is the subject of Exercise 3.2.6.

**** Exercise 3.1.1

     Write out the expansion steps necessary to expand

#+begin_src scheme
     (let ([x (memv 'a ls)])
       (and x (memv 'b x)))
#+end_src

    into core forms.

**** Exercise 3.1.2

     Write out the expansion steps necessary to expand

#+begin_src scheme
     (or (memv x '(a b c)) (list x))
#+end_src

     into core forms.

**** Exercise 3.1.3

     ~let*~ is similar to let but evaluates its bindings in sequence. Each of the right-hand-side expressions is within
     the scope of the earlier bindings.

#+begin_src scheme
     (let* ([a 5] [b (+ a a)] [c (+ a b)])
       (list a b c)) → (5 10 15)
#+end_src

     ~let*~ can be implemented as nested let expressions. For example, the ~let*~ expression above is equivalent to the
     nested let expressions below.

#+begin_src scheme
     (let ([a 5])
       (let ([b (+ a a)])
         (let ([c (+ a b)])
           (list a b c)))) → (5 10 15)
#+end_src

     Define ~let*~ with define-syntax.

**** Exercise 3.1.4

     As we saw in Section 2.9, it is legal to omit the third, or alternative, subexpression of an if expression. Doing
     so, however, often leads to confusion. Scheme provides two syntactic forms, when and unless, that may be used in
     place of such "one-armed" if expressions.

#+begin_src scheme
     (when test expr1 expr2 ...)
     (unless test expr1 expr2 ...)
#+end_src

     With both forms, test is evaluated first. For when, if test evaluates to true, the remaining forms are evaluated in
     sequence as if enclosed in an implicit begin expression. If test evaluates to false, the remaining forms are not
     evaluated, and the result is unspecified. unless is similar except that the remaining forms are evaluated only if
     test evaluates to false.

#+begin_src scheme
     (let ([x 3])
       (unless (= x 0) (set! x (+ x 1)))
       (when (= x 4) (set! x (* x 2)))
       x) → 8
#+end_src

     Define when as a syntactic extension in terms of if and begin, and define unless in terms of when.

*** More Recursion
    In Section 2.8, we saw how to define recursive procedures using top-level definitions. Before that, we saw how to
    create local bindings for procedures using let. It is natural to wonder whether a let-bound procedure can be
    recursive. The answer is no, at least not in a straightforward way. If you try to evaluate the expression

#+begin_src scheme
    (let ([sum (lambda (ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5)))
#+end_src

    it will probably raise an exception with a message to the effect that sum is undefined. This is because the variable
    sum is visible only within the body of the let expression and not within the lambda expression whose value is bound
    to sum. We can get around this problem by passing the procedure sum to itself as follows.

#+begin_src scheme
    (let ([sum (lambda (sum ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum sum (cdr ls)))))])
      (sum sum '(1 2 3 4 5))) → 15
#+end_src

    This works and is a clever solution, but there is an easier way, using letrec. Like let, the letrec syntactic form
    includes a set of variable-value pairs, along with a sequence of expressions referred to as the body of the letrec.

#+begin_src scheme
    (letrec ((var expr) ...) body1 body2 ...)
#+end_src

    Unlike let, the variables var ... are visible not only within the body of the letrec but also within expr .... Thus,
    we can rewrite the expression above as follows.

#+begin_src scheme
    (letrec ([sum (lambda (ls)
                    (if (null? ls)
                        0
                        (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5))) → 15
#+end_src

    Using ~letrec~, we can also define mutually recursive procedures, such as the procedures ~even?~ and ~odd?~ that were
    the subject of Exercise 2.8.6.

#+begin_src scheme
    (letrec ([even?
              (lambda (x)
                (or (= x 0)
                    (odd? (- x 1))))]
             [odd?
              (lambda (x)
                (and (not (= x 0))
                     (even? (- x 1))))])
      (list (even? 20) (odd? 20))) → (#t #f)
#+end_src

    In a letrec expression, expr ... are most often lambda expressions, though this need not be the case. One restriction
    on the expressions must be obeyed, however. It must be possible to evaluate each expr without evaluating any of the
    variables var .... This restriction is always satisfied if the expressions are all lambda expressions, since even
    though the variables may appear within the lambda expressions, they cannot be evaluated until the resulting
    procedures are invoked in the body of the letrec. The following letrec expression obeys this restriction.

#+begin_src scheme
    (letrec ([f (lambda () (+ x 2))]
             [x 1])
      (f)) → 3
#+end_src

    while the following does not.

#+begin_src scheme
    (letrec ([y (+ x 2)]
             [x 1])
      y)
#+end_src

    In this case, an exception is raised indicating that x is not defined where it is referenced.

    We can use letrec to hide the definitions of "help" procedures so that they do not clutter the top-level
    namespace. This is demonstrated by the definition of list? below, which follows the "hare and tortoise" algorithm
    outlined in Exercise 2.9.8.

#+begin_src scheme
    (define list?
      (lambda (x)
        (letrec ([race
                  (lambda (h t)
                    (if (pair? h)
                        (let ([h (cdr h)])
                          (if (pair? h)
                              (and (not (eq? h t))
                                   (race (cdr h) (cdr t)))
                              (null? h)))
                        (null? h)))])
          (race x x))))
#+end_src

    When a recursive procedure is called in only one place outside the procedure, as in the example above, it is often
    clearer to use a named let expression. Named let expressions take the following form.

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    Named let is similar to unnamed let in that it binds the variables var ... to the values of expr ... within the body
    body1 body2 .... As with unnamed let, the variables are visible only within the body and not within expr .... In
    addition, the variable name is bound within the body to a procedure that may be called to recur; the arguments to the
    procedure become the new values for the variables var ....

    The definition of ~list?~ has been rewritten below to use named ~let~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (let race ([h x] [t x])
          (if (pair? h)
              (let ([h (cdr h)])
                (if (pair? h)
                    (and (not (eq? h t))
                         (race (cdr h) (cdr t)))
                    (null? h)))
              (null? h)))))
#+end_src

    Just as let can be expressed as a simple direct application of a lambda expression to arguments, named let can be
    expressed as the application of a recursive procedure to arguments. A named let of the form

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    can be rewritten in terms of letrec as follows.

#+begin_src scheme
    ((letrec ((name (lambda (var ...) body1 body2 ...)))
       name)
     expr ...)
#+end_src

    Alternatively, it can be rewritten as

#+begin_src scheme
    (letrec ((name (lambda (var ...) body1 body2 ...)))
      (name expr ...))
#+end_src

    provided that the variable name does not appear free within expr ....

    As we discussed in Section 2.8, some recursion is essentially iteration and executes as such. When a procedure call
    is in tail position (see below) with respect to a lambda expression, it is considered to be a tail call, and Scheme
    systems must treat it properly, as a "goto" or jump. When a procedure tail-calls itself or calls itself indirectly
    through a series of tail calls, the result is tail recursion. Because tail calls are treated as jumps, tail recursion
    can be used for indefinite iteration in place of the more restrictive iteration constructs provided by other
    programming languages, without fear of overflowing any sort of recursion stack.

    A call is in tail position with respect to a lambda expression if its value is returned directly from the lambda
    expression, i.e., if nothing is left to do after the call but to return from the lambda expression. For example, a
    call is in tail position if it is the last expression in the body of a lambda expression, the consequent or
    alternative part of an if expression in tail position, the last subexpression of an and or or expression in tail
    position, the last expression in the body of a let or letrec in tail position, etc. Each of the calls to f in the
    expressions below are tail calls, but the calls to g are not.

#+begin_src scheme
    (lambda () (f (g)))
    (lambda () (if (g) (f) (f)))
    (lambda () (let ([x 4]) (f)))
    (lambda () (or (g) (f)))
#+end_src

    In each case, the values of the calls to f are returned directly, whereas the calls to g are not.

    Recursion in general and named let in particular provide a natural way to implement many algorithms, whether
    iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct
    mechanisms.

    The following two definitions of factorial use named let expressions to compute the factorial, n!, of a nonnegative
    integer n. The first employs the recursive definition n! = n × (n - 1)!, where 0! is defined to be 1.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n])
          (if (= i 0)
              1
              (* i (fact (- i 1)))))))

    (factorial 0) → 1
    (factorial 1) → 1
    (factorial 2) → 2
    (factorial 3) → 6
    (factorial 10) → 3628800
#+end_src

    The second is an iterative version that employs the iterative definition ~n! = n × (n - 1) × (n - 2) × ... × 1~,
    using an accumulator, a, to hold the intermediate products.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n] [a 1])
          (if (= i 0)
              a
              (fact (- i 1) (* a i))))))
#+end_src

    A similar problem is to compute the nth Fibonacci number for a given n. The Fibonacci numbers are an infinite
    sequence of integers, 0, 1, 1, 2, 3, 5, 8, etc., in which each number is the sum of the two preceding numbers in the
    sequence. A procedure to compute the nth Fibonacci number is most naturally defined recursively as follows.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (let fib ([i n])
          (cond
            [(= i 0) 0]
            [(= i 1) 1]
            [else (+ (fib (- i 1)) (fib (- i 2)))]))))

    (fibonacci 0) → 0
    (fibonacci 1) → 1
    (fibonacci 2) → 1
    (fibonacci 3) → 2
    (fibonacci 4) → 3
    (fibonacci 5) → 5
    (fibonacci 6) → 8
    (fibonacci 20) → 6765
    (fibonacci 30) → 832040
#+end_src

    This solution requires the computation of the two preceding Fibonacci numbers at each step and hence is doubly
    recursive. For example, to compute (fibonacci 4) requires the computation of both (fib 3) and (fib 2), to compute
    (fib 3) requires computing both (fib 2) and (fib 1), and to compute (fib 2) requires computing both (fib 1) and (fib
    0). This is very inefficient, and it becomes more inefficient as n grows. A more efficient solution is to adapt the
    accumulator solution of the factorial example above to use two accumulators, a1 for the current Fibonacci number and
    a2 for the preceding one.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (if (= n 0)
            0
            (let fib ([i n] [a1 1] [a2 0])
              (if (= i 1)
                  a1
                  (fib (- i 1) (+ a1 a2) a1))))))
#+end_src

    Here, zero is treated as a special case, since there is no preceding value. This allows us to use the single base
    case (= i 1). The time it takes to compute the nth Fibonacci number using this iterative solution grows linearly with
    n, which makes a significant difference when compared to the doubly recursive version. To get a feel for the
    difference, try computing (fibonacci 35) and (fibonacci 40) using both definitions to see how long each takes.

    We can also get a feel for the difference by looking at a trace for each on small inputs. The first trace below shows
    the calls to fib in the non-tail-recursive version of fibonacci, with input 5.

#+BEGIN_EXAMPLE
    |(fib 5)
    | (fib 4)
    | |(fib 3)
    | | (fib 2)
    | | |(fib 1)
    | | |1
    | | |(fib 0)
    | | |0
    | | 1
    | | (fib 1)
    | | 1
    | |2
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | 3
    | (fib 3)
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | |(fib 1)
    | |1
    | 2
    |5
#+END_EXAMPLE

    Notice how there are several calls to fib with arguments 2, 1, and 0. The second trace shows the calls to fib in the
    tail-recursive version, again with input 5.

#+BEGIN_EXAMPLE
    |(fib 5 1 0)
    |(fib 4 1 1)
    |(fib 3 2 1)
    |(fib 2 3 2)
    |(fib 1 5 3)
    |5
#+END_EXAMPLE

    Clearly, there is quite a difference.

    The named let examples shown so far are either tail-recursive or not tail-recursive. It often happens that one
    recursive call within the same expression is tail-recursive while another is not. The definition of factor below
    computes the prime factors of its nonnegative integer argument. The first call to f is not tail-recursive, but the
    second one is.

#+begin_src scheme
    (define factor
      (lambda (n)
        (let f ([n n] [i 2])
          (cond
            [(>= i n) (list n)]
            [(integer? (/ n i))
             (cons i (f (/ n i) i))]
            [else (f n (+ i 1))]))))
#+end_src

#+begin_src scheme
    (factor 0) → (0)
    (factor 1) → (1)
    (factor 12) → (2 2 3)
    (factor 3628800) → (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
    (factor 9239) → (9239)
#+end_src

    A trace of the calls to f, produced in Chez Scheme by replacing let with trace-let, in the evaluation of (factor 120)
    below highlights the difference between the nontail calls and the tail calls.

#+BEGIN_EXAMPLE
    |(f 120 2)
    | (f 60 2)
    | |(f 30 2)
    | | (f 15 2)
    | | (f 15 3)
    | | |(f 5 3)
    | | |(f 5 4)
    | | |(f 5 5)
    | | |(5)
    | | (3 5)
    | |(2 3 5)
    | (2 2 3 5)
    |(2 2 2 3 5)
#+END_EXAMPLE

    A nontail call to f is shown indented relative to its caller, since the caller is still active, whereas tail calls
    appear at the same level of indentation.

**** Exercise 3.2.1

     Which of the recursive procedures defined in Section 3.2 are tail-recursive, and which are not?

**** Exercise 3.2.2

     Rewrite factor using letrec to bind f in place of named let. Which version do you prefer?

**** Exercise 3.2.3

     Can the letrec expression below be rewritten using named let? If not, why not? If so, do it.

#+begin_src scheme
     (letrec ([even?
               (lambda (x)
                 (or (= x 0)
                     (odd? (- x 1))))]
              [odd?
               (lambda (x)
                 (and (not (= x 0))
                      (even? (- x 1))))])
       (even? 20))
#+end_src

**** Exercise 3.2.4

     Rewrite both definitions of fibonacci given in this section to count the number of recursive calls to fib, using a
     counter similar to the one used in the cons-count example of Section 2.9. Count the number of recursive calls made in
     each case for several input values. What do you notice?

**** Exercise 3.2.5

     Augment the definition of let given in Section 3.1 to handle named let as well as unnamed let, using two rules.

**** Exercise 3.2.6

     The following definition of or is simpler than the one given in Section 3.1.

#+begin_src scheme
     (define-syntax or ; incorrect!
       (syntax-rules ()
         [(_) #f]
         [(_ e1 e2 ...)
          (let ([t e1])
            (if t t (or e2 ...)))]))
#+end_src

     Say why it is not correct. [Hint: Think about what would happen if this version of or were used in the even? and
     odd? example given on page 66 for very large inputs.]

**** Exercise 3.2.7

     The definition of factor is not the most efficient possible. First, no factors of n besides n itself can possibly be
     found beyond →. Second, the division (/ n i) is performed twice when a factor is found. Third, after 2, no even
     factors can possibly be found. Recode factor to correct all three problems. Which is the most important problem to
     solve? Are there any additional improvements you can make?

*** Continuations

    During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate
    and (2) what to do with the value. Consider the evaluation of (null? x) within the expression below.

#+begin_src scheme
    (if (null? x) (quote ()) (cdr x))
#+end_src

    The implementation must first evaluate (null? x) and, based on its value, evaluate either (quote ()) or (cdr
    x). "What to evaluate" is (null? x), and "what to do with the value" is to make the decision which of (quote ()) and
    (cdr x) to evaluate and to do so. We call "what to do with the value" the continuation of a computation.

    Thus, at any point during the evaluation of any expression, there is a continuation ready to complete, or at least
    continue, the computation from that point. Let's assume that x has the value (a b c). We can isolate six
    continuations during the evaluation of (if (null? x) (quote ()) (cdr x)), the continuations waiting for

    1. the value of (if (null? x) (quote ()) (cdr x)),
    2. the value of (null? x),
    3. the value of null?,
    4. the value of x,
    5. the value of cdr, and
    6. the value of x (again).

    The continuation of ~(cdr x)~ is not listed because it is the same as the one waiting for ~(if (null? x) (quote ())
    (cdr x))~.

    Scheme allows the continuation of any expression to be captured with the procedure call/cc. call/cc must be passed a
    procedure p of one argument. call/cc constructs a concrete representation of the current continuation and passes it
    to p. The continuation itself is represented by a procedure k. Each time k is applied to a value, it returns the
    value to the continuation of the call/cc application. This value becomes, in essence, the value of the application of
    call/cc.

    If p returns without invoking k, the value returned by the procedure becomes the value of the application of call/cc.

    Consider the simple examples below.

#+begin_src scheme
    (call/cc
      (lambda (k)
        (* 5 4))) → 20

    (call/cc
      (lambda (k)
        (* 5 (k 4)))) → 4

    (+ 2
       (call/cc
         (lambda (k)
           (* 5 (k 4))))) → 6
#+end_src

    In the first example, the continuation is captured and bound to k, but k is never used, so the value is simply the
    product of 5 and 4. In the second, the continuation is invoked before the multiplication, so the value is the value
    passed to the continuation, 4. In the third, the continuation includes the addition by 2; thus, the value is the
    value passed to the continuation, 4, plus 2.

    Here is a less trivial example, showing the use of call/cc to provide a nonlocal exit from a recursion.

#+begin_src scheme
    (define product
      (lambda (ls)
        (call/cc
          (lambda (break)
            (let f ([ls ls])
              (cond
                [(null? ls) 1]
                [(= (car ls) 0) (break 0)]
                [else (* (car ls) (f (cdr ls)))]))))))

    (product '(1 2 3 4 5)) → 120
    (product '(7 3 8 0 1 9 5)) → 0
#+end_src

    The nonlocal exit allows product to return immediately, without performing the pending multiplications, when a zero
    value is detected.

    Each of the continuation invocations above returns to the continuation while control remains within the procedure
    passed to call/cc. The following example uses the continuation after this procedure has already returned.

#+begin_src scheme
    (let ([x (call/cc (lambda (k) k))])
      (x (lambda (ignore) "hi"))) → "hi"
#+end_src

    The continuation captured by this invocation of call/cc may be described as "Take the value, bind it to x, and apply
    the value of x to the value of (lambda (ignore) "hi")." Since (lambda (k) k) returns its argument, x is bound to the
    continuation itself; this continuation is applied to the procedure resulting from the evaluation of (lambda (ignore)
    "hi"). This has the effect of binding x (again!) to this procedure and applying the procedure to itself. The
    procedure ignores its argument and returns "hi".

    The following variation of the example above is probably the most confusing Scheme program of its size; it might be
    easy to guess what it returns, but it takes some thought to figure out why.

#+begin_src scheme
    (((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") → "HEY!"
#+end_src

    The value of the call/cc is its own continuation, as in the preceding example. This is applied to the identity
    procedure (lambda (x) x), so the call/cc returns a second time with this value. Then, the identity procedure is
    applied to itself, yielding the identity procedure. This is finally applied to "HEY!", yielding "HEY!".

    Continuations used in this manner are not always so puzzling. Consider the following definition of factorial that
    saves the continuation at the base of the recursion before returning 1, by assigning the top-level variable retry.

#+begin_src scheme
    (define retry #f)

    (define factorial
      (lambda (x)
        (if (= x 0)
            (call/cc (lambda (k) (set! retry k) 1))
            (* x (factorial (- x 1))))))
#+end_src

    With this definition, factorial works as we expect factorial to work, except it has the side effect of assigning
    retry.

#+begin_src scheme
    (factorial 4) → 24
    (retry 1) → 24
    (retry 2) → 48
#+end_src

    The continuation bound to retry might be described as "Multiply the value by 1, then multiply this result by 2, then
    multiply this result by 3, then multiply this result by 4." If we pass the continuation a different value, i.e., not
    1, we will cause the base value to be something other than 1 and hence change the end result.

#+begin_src scheme
    (retry 2) → 48
    (retry 5) → 120
#+end_src

    This mechanism could be the basis for a breakpoint package implemented with call/cc; each time a breakpoint is
    encountered, the continuation of the breakpoint is saved so that the computation may be restarted from the breakpoint
    (more than once, if desired).

    Continuations may be used to implement various forms of multitasking. The simple "light-weight process" mechanism
    defined below allows multiple computations to be interleaved. Since it is nonpreemptive, it requires that each
    process voluntarily "pause" from time to time in order to allow the others to run.

#+begin_src scheme
    (define lwp-list '())
    (define lwp
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))

    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))

    (define pause
      (lambda ()
        (call/cc
          (lambda (k)
            (lwp (lambda () (k #f)))
            (start)))))
#+end_src

    The following light-weight processes cooperate to print an infinite sequence of lines containing "hey!".

#+begin_src scheme
    (lwp (lambda () (let f () (pause) (display "h") (f))))
    (lwp (lambda () (let f () (pause) (display "e") (f))))
    (lwp (lambda () (let f () (pause) (display "y") (f))))
    (lwp (lambda () (let f () (pause) (display "!") (f))))
    (lwp (lambda () (let f () (pause) (newline) (f))))
    (start) → hey!
              hey!
              hey!
              hey!
              ...
#+end_src

    See Section 12.11 for an implementation of engines, which support preemptive multitasking, with call/cc.

**** Exercise 3.3.1

     Use call/cc to write a program that loops indefinitely, printing a sequence of numbers beginning at zero. Do not use
     any recursive procedures, and do not use any assignments.

**** Exercise 3.3.2

     Rewrite product without call/cc, retaining the feature that no multiplications are performed if any of the list
     elements are zero.

**** Exercise 3.3.3

     What would happen if a process created by lwp as defined above were to terminate, i.e., simply return without
     calling pause? Define a quit procedure that allows a process to terminate without otherwise affecting the lwp
     system. Be sure to handle the case in which the only remaining process terminates.

**** Exercise 3.3.4

     Each time lwp is called, the list of processes is copied because lwp uses append to add its argument to the end of
     the process list. Modify the original lwp code to use the queue data type developed in Section 2.9 to avoid this
     problem.

**** Exercise 3.3.5

     The light-weight process mechanism allows new processes to be created dynamically, although the example given in
     this section does not do so. Design an application that requires new processes to be created dynamically and
     implement it using the light-weight process mechanism.

*** Continuation Passing Style

    As we discussed in the preceding section, a continuation waits for the value of each expression. In particular, a
    continuation is associated with each procedure call. When one procedure invokes another via a nontail call, the
    called procedure receives an implicit continuation that is responsible for completing what is left of the calling
    procedure's body plus returning to the calling procedure's continuation. If the call is a tail call, the called
    procedure simply receives the continuation of the calling procedure.

    We can make the continuations explicit by encapsulating "what to do" in an explicit procedural argument passed along
    on each call. For example, the continuation of the call to f in

#+begin_src scheme
    (letrec ([f (lambda (x) (cons 'a x))]
             [g (lambda (x) (cons 'b (f x)))]
             [h (lambda (x) (g (cons 'c x)))])
      (cons 'd (h '()))) → (d b a c)
#+end_src

    conses the symbol b onto the value returned to it, then returns the result of this cons to the continuation of the
    call to g. This continuation is the same as the continuation of the call to h, which conses the symbol d onto the
    value returned to it. We can rewrite this in continuation-passing style, or CPS, by replacing these implicit
    continuations with explicit procedures.

#+begin_src scheme
    (letrec ([f (lambda (x k) (k (cons 'a x)))]
             [g (lambda (x k)
                  (f x (lambda (v) (k (cons 'b v)))))]
             [h (lambda (x k) (g (cons 'c x) k))])
      (h '() (lambda (v) (cons 'd v))))
#+end_src

    Like the implicit continuation of h and g in the preceding example, the explicit continuation passed to h and on to
    g,

#+begin_src scheme
    (lambda (v) (cons 'd v))
#+end_src

    conses the symbol d onto the value passed to it. Similarly, the continuation passed to f,

#+begin_src scheme
    (lambda (v) (k (cons 'b v)))
#+end_src

    conses b onto the value passed to it, then passes this on to the continuation of g.

    Expressions written in CPS are more complicated, of course, but this style of programming has some useful
    applications. CPS allows a procedure to pass more than one result to its continuation, because the procedure that
    implements the continuation can take any number of arguments.

#+begin_src scheme
    (define car&cdr
      (lambda (p k)
        (k (car p) (cdr p))))

    (car&cdr '(a b c)
      (lambda (x y)
        (list y x))) → ((b c) a)
    (car&cdr '(a b c) cons) → (a b c)
    (car&cdr '(a b c a d) memv) → (a d)
#+end_src

    (This can be done with multiple values as well; see Section 5.8.) CPS also allows a procedure to take separate
    "success" and "failure" continuations, which may accept different numbers of arguments. An example is integer-divide
    below, which passes the quotient and remainder of its first two arguments to its third, unless the second argument
    (the divisor) is zero, in which case it passes an error message to its fourth argument.

#+begin_src scheme
    (define integer-divide
      (lambda (x y success failure)
        (if (= y 0)
            (failure "divide by zero")
            (let ([q (quotient x y)])
              (success q (- x (* q y)))))))

    (integer-divide 10 3 list (lambda (x) x)) → (3 1)
    (integer-divide 10 0 list (lambda (x) x)) → "divide by zero"
#+end_src

    The procedure quotient, employed by integer-divide, returns the quotient of its two arguments, truncated toward
    zero.

    Explicit success and failure continuations can sometimes help to avoid the extra communication necessary to separate
    successful execution of a procedure from unsuccessful execution. Furthermore, it is possible to have multiple success
    or failure continuations for different flavors of success or failure, each possibly taking different numbers and
    types of arguments. See Sections 12.10 and 12.11 for extended examples that employ continuation-passing style.

    At this point you might be wondering about the relationship between CPS and the continuations captured via
    call/cc. It turns out that any program that uses call/cc can be rewritten in CPS without call/cc, but a total rewrite
    of the program (sometimes including even system-defined primitives) might be necessary. Try to convert the product
    example on page 75 into CPS before looking at the version below.

#+begin_src scheme
    (define product
      (lambda (ls k)
        (let ([break k])
          (let f ([ls ls] [k k])
            (cond
              [(null? ls) (k 1)]
              [(= (car ls) 0) (break 0)]
              [else (f (cdr ls)
                       (lambda (x)
                         (k (* (car ls) x))))])))))

    (product '(1 2 3 4 5) (lambda (x) x)) → 120
    (product '(7 3 8 0 1 9 5) (lambda (x) x)) → 0
#+end_src

**** Exercise 3.4.1

     Rewrite the reciprocal example first given in Section 2.1 to accept both success and failure continuations, like
     integer-divide above.

**** Exercise 3.4.2

     Rewrite the retry example from page 75 to use CPS.

**** Exercise 3.4.3

     Rewrite the following expression in CPS to avoid using call/cc.

#+begin_src scheme
     (define reciprocals
       (lambda (ls)
         (call/cc
           (lambda (k)
             (map (lambda (x)
                    (if (= x 0)
                        (k "zero found")
                        (/ 1 x)))
                  ls)))))

     (reciprocals '(2 1/3 5 1/4)) → (1/2 3 1/5 4)
     (reciprocals '(2 1/3 0 5 1/4)) → "zero found"
#+end_src

*** Internal Definitions

    In Section 2.6, we discussed top-level definitions. Definitions may also appear at the front of a lambda, let, or
    letrec body, in which case the bindings they create are local to the body.

#+begin_src scheme
    (define f (lambda (x) (* x x)))
    (let ([x 3])
      (define f (lambda (y) (+ y x)))
      (f 4)) → 7
    (f 4) → 16
#+end_src

    Procedures bound by internal definitions can be mutually recursive, as with letrec. For example, we can rewrite the
    even? and odd? example from Section 3.2 using internal definitions as follows.

#+begin_src scheme
    (let ()
      (define even?
        (lambda (x)
          (or (= x 0)
              (odd? (- x 1)))))
      (define odd?
        (lambda (x)
          (and (not (= x 0))
               (even? (- x 1)))))
      (even? 20)) → #t
#+end_src

    Similarly, we can replace the use of letrec to bind race with an internal definition of race in our first definition
    of list?.

#+begin_src scheme
    (define list?
      (lambda (x)
        (define race
          (lambda (h t)
            (if (pair? h)
                (let ([h (cdr h)])
                  (if (pair? h)
                      (and (not (eq? h t))
                           (race (cdr h) (cdr t)))
                      (null? h)))
                (null? h))))
        (race x x)))
#+end_src

    In fact, internal variable definitions and letrec are practically interchangeable. The only difference, other than
    the obvious difference in syntax, is that variable definitions are guaranteed to be evaluated from left to right,
    while the bindings of a letrec may be evaluated in any order. So we cannot quite replace a lambda, let, or letrec
    body containing internal definitions with a letrec expression. We can, however, use letrec*, which, like let*,
    guarantees left-to-right evaluation order. A body of the form

#+begin_src scheme
    (define var expr0)
    ...
    expr1
    expr2
    ...
#+end_src

    is equivalent to a letrec* expression binding the defined variables to the associated values in a body comprising the
    expressions.

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    Conversely, a letrec* of the form

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    can be replaced with a let expression containing internal definitions and the expressions from the body as follows.

#+begin_src scheme
    (let ()
      (define var expr0)
      ...
      expr1
      expr2
      ...
    )
#+end_src

    The seeming lack of symmetry between these transformations is due to the fact that letrec* expressions can appear
    anywhere an expression is valid, whereas internal definitions can appear only at the front of a body. Thus, in
    replacing a letrec* with internal definitions, we must generally introduce a let expression to hold the definitions.

    Another difference between internal definitions and letrec or letrec* is that syntax definitions may appear among the
    internal definitions, while letrec and letrec* bind only variables.

#+begin_src scheme
    (let ([x 3])
      (define-syntax set-x!
        (syntax-rules ()
          [(_ e) (set! x e)]))
      (set-x! (+ x x))
      x) → 6
#+end_src

    The scope of a syntactic extension established by an internal syntax definition, as with an internal variable
    definition, is limited to the body in which the syntax definition appears.

    Internal definitions may be used in conjunction with top-level definitions and assignments to help modularize
    programs. Each module of a program should make visible only those bindings that are needed by other modules, while
    hiding other bindings that would otherwise clutter the top-level namespace and possibly result in unintended use or
    redefinition of those bindings. A common way of structuring a module is shown below.

#+begin_src scheme
    (define export-var #f)
     ...
    (let ()
      (define var expr)
       ...
      init-expr
       ...
      (set! export-var export-val)
       ...
    )
#+end_src

    The first set of definitions establish top-level bindings for the variables we desire to export (make visible
    globally). The second set of definitions establish local bindings visible only within the module. The expressions
    init-expr ... perform any initialization that must occur after the local bindings have been established. Finally, the
    set! expressions assign the exported variables to the appropriate values.

    An advantage of this form of modularization is that the bracketing let expression may be removed or "commented out"
    during program development, making the internal definitions top-level to facilitate interactive testing. This form of
    modularization also has several disadvantages, as we discuss in the next section.

    The following module exports a single variable, calc, which is bound to a procedure that implements a simple
    four-function calculator.

#+begin_src scheme
    (define calc #f)
    (let ()
      (define do-calc
        (lambda (ek expr)
          (cond
            [(number? expr) expr]
            [(and (list? expr) (= (length expr) 3))
             (let ([op (car expr)] [args (cdr expr)])
               (case op
                 [(add) (apply-op ek + args)]
                 [(sub) (apply-op ek - args)]
                 [(mul) (apply-op ek * args)]
                 [(div) (apply-op ek / args)]
                 [else (complain ek "invalid operator" op)]))]
            [else (complain ek "invalid expression" expr)])))
      (define apply-op
        (lambda (ek op args)
          (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
      (define complain
        (lambda (ek msg expr)
          (ek (list msg expr))))
      (set! calc
        (lambda (expr)
          ; grab an error continuation ek
          (call/cc
            (lambda (ek)
              (do-calc ek expr))))))

    (calc '(add (mul 3 2) -4)) → 2
    (calc '(div 1/2 1/6)) → 3
    (calc '(add (mul 3 2) (div 4))) → ("invalid expression" (div 4))
    (calc '(mul (add 1 -2) (pow 2 7))) → ("invalid operator" pow)
#+end_src

    This example uses a case expression to determine which operator to apply. case is similar to cond except that the
    test is always the same: (memv val (key ...)), where val is the value of the first case subform and (key ...) is the
    list of items at the front of each case clause. The case expression in the example above could be rewritten using
    cond as follows.

#+begin_src scheme
    (let ([temp op])
      (cond
        [(memv temp '(add)) (apply-op ek + args)]
        [(memv temp '(sub)) (apply-op ek - args)]
        [(memv temp '(mul)) (apply-op ek * args)]
        [(memv temp '(div)) (apply-op ek / args)]
        [else (complain ek "invalid operator" op)]))
#+end_src

**** Exercise 3.5.1

     Redefine complain in the calc example as an equivalent syntactic extension.

**** Exercise 3.5.2

     In the calc example, the error continuation ek is passed along on each call to apply-op, complain, and do-calc. Move
     the definitions of apply-op, complain, and do-calc inward as far as necessary to eliminate the ek argument from the
     definitions and applications of these procedures.

**** Exercise 3.5.3

     Eliminate the call/cc from calc and rewrite complain to raise an exception using assertion-violation.

**** Exercise 3.5.4

     Extend calc to handle unary minus expressions, e.g.,

     (calc '(minus (add 2 3))) → -5

     and other operators of your choice.

*** Libraries

    At the end of the preceding section, we discussed a form of modularization that involves assigning a set of top-level
    variables from within a let while keeping unpublished helpers local to the let. This form of modularization has
    several drawbacks:

    * It is unportable, because the behavior and even existence of an interactive top level is not guaranteed by the
      Revised6 Report.
    * It requires assignments, which make the code appear somewhat awkward and may inhibit compiler analyses and
      optimizations.
    * It does not support the publication of keyword bindings, since there is no analogue to set! for keywords.

    An alternative that does not share these drawbacks is to create a library. A library exports a set of identifiers,
    each defined within the library or imported from some other library. An exported identifier need not be bound as a
    variable; it may be bound as a keyword instead.

    The following library exports two identifiers: the variable gpa->grade and the keyword gpa. The variable gpa->grade
    is bound to a procedure that takes a grade-point average (GPA), represented as a number, and returns the
    corresponding letter grade, based on a four-point scale. The keyword gpa names a syntactic extension whose subforms
    must all be letter grades and whose value is the GPA computed from those letter grades.

#+begin_src scheme
    (library (grades)
      (export gpa->grade gpa)
      (import (rnrs))

      (define in-range?
        (lambda (x n y)
          (and (>= n x) (< n y))))

      (define-syntax range-case
        (syntax-rules (- else)
          [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...
               [else ee1 ee2 ...]))]
          [(_ expr ((x - y) e1 e2 ...) ...)
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...))]))

      (define letter->number
        (lambda (x)
          (case x
            [(a)  4.0]
            [(b)  3.0]
            [(c)  2.0]
            [(d)  1.0]
            [(f)  0.0]
            [else (assertion-violation 'grade "invalid letter grade" x)])))

      (define gpa->grade
        (lambda (x)
          (range-case x
            [(0.0 - 0.5) 'f]
            [(0.5 - 1.5) 'd]
            [(1.5 - 2.5) 'c]
            [(2.5 - 3.5) 'b]
            [else 'a])))

      (define-syntax gpa
        (syntax-rules ()
          [(_ g1 g2 ...)
           (let ([ls (map letter->number '(g1 g2 ...))])
             (/ (apply + ls) (length ls)))])))
#+end_src

    The name of the library is (grades). This may seem like a funny kind of name, but all library names are
    parenthesized. The library imports from the standard (rnrs) library, which contains most of the primitive and keyword
    bindings we have used in this chapter and the last, and everything we need to implement gpa->grade and gpa.

    Along with gpa->grade and gpa, several other syntactic extensions and procedures are defined within the library, but
    none of the others are exported. The ones that aren't exported are simply helpers for the ones that are. Everything
    used within the library should be familiar, except for the apply procedure, which is described on page 107.

    If your Scheme implementation supports import in the interactive top level, you can test the two exports as shown
    below.

#+begin_src scheme
    (import (grades))
    (gpa c a c b b) → 2.8
    (gpa->grade 2.8) → b
#+end_src

    Chapter 10 describes libraries in more detail and provides additional examples of their use.

**** Exercise 3.6.1

     Modify gpa to handle "x" grades, which do not count in the grade-point average. Be careful to handle gracefully the
     situation where each grade is x.

#+begin_src scheme
     (import (grades))
     (gpa a x b c) → 3.0
#+end_src

**** Exercise 3.6.2

     Export from (grades) a new syntactic form, distribution, that takes a set of grades, like gpa, but returns a list of
     the form ((n g) ...), where n is the number of times g appears in the set, with one entry for each g. Have
     distribution call an unexported procedure to do the actual work.

#+begin_src scheme
     (import (grades))
     (distribution a b a c c c a f b a) → ((4 a) (2 b) (3 c) (0 d) (1 f))
#+end_src

**** Exercise 3.6.3

     Now read about output operations in Section 7.8 and define a new export, histogram, as a procedure that takes a
     textual output port and a distribution, such as might be produced by distribution, and prints a histogram in the
     style illustrated by the example below.

#+begin_src scheme
     (import (grades))
     (histogram
       (current-output-port)
       (distribution a b a c c a c a f b a))
#+end_src

     prints:

#+BEGIN_EXAMPLE
   a: *****
   b: **
   c: ***
   d:
   f: *
#+END_EXAMPLE


#+LATEX: \newpage
[[./images/ch4.png]]

** Procedures and Variable Bindings
*** Variable References
*** Lambda
*** Case-Lambda
*** Local Binding
*** Multiple Values
*** Variable Definitions
*** Assignment



#+LATEX: \newpage
[[./images/ch5.png]]

** Control Operations
*** Procedure Application
*** Sequencing
*** Conditionals
*** Recursion and Iteration
*** Mapping and Folding
*** Continuations
*** Delayed Evaluation
*** Multiple Values
*** Eval

#+LATEX: \newpage
[[./images/ch6.png]]

** Operations on Objects
*** Constants and Quotation
*** Generic Equivalence and Type Predicates
*** Lists and Pairs
*** Numbers
*** Fixnums
*** Flonums
*** Characters
*** Strings
*** Vectors
*** Bytevectors
*** Symbols
*** Booleans
*** Hashtables
*** Enumerations

#+LATEX: \newpage
[[./images/ch7.png]]

** Input and Output
*** Transcoders
*** Opening Files
*** Standard Ports
*** String and Bytevector Ports
*** Opening Custom Ports
*** Port Operations
*** Input Operations
*** Output Operations
*** Convenience I/O
*** Filesystem Operations
*** Bytevector/String Conversions

#+LATEX: \newpage
[[./images/ch8.png]]

** Syntactic Extension
*** Keyword Bindings
*** Syntax-Rules Transformers
*** Syntax-Case Transformers
*** Examples

#+LATEX: \newpage
[[./images/ch9.png]]

** Records
*** Defining Records
*** Procedural Interface
*** Inspection

#+LATEX: \newpage
[[./images/ch10.png]]

** Libraries and Top-Level Programs
*** Standard Libraries
*** Defining New Libraries
*** Top-Level Programs
*** Examples

#+LATEX: \newpage
[[./images/ch11.png]]

** Exceptions and Conditions
*** Raising and Handling Exceptions
*** Defining Condition Types
*** Standard Condition Types

#+LATEX: \newpage
[[./images/ch12.png]]

** Extended Examples
*** Matrix and Vector Multiplication
*** Sorting
*** A Set Constructor
*** Word Frequency Counting
*** Scheme Printer
*** Formatted Output
*** A Meta-Circular Interpreter for Scheme
*** Defining Abstract Objects
*** Fast Fourier Transform
*** A Unification Algorithm
*** Multitasking with Engines

#+LATEX: \newpage
** Ответы к заданиям

#+LATEX: \newpage
* Формальный синтаксис

#+LATEX: \newpage
* Таблица синтаксических форм

#+LATEX: \newpage
* Предметный указатель


#+LATEX: \newpage
* Footnotes

[fn:1] Michael Adams and R. Kent Dybvig. Efficient nondestructive equality checking for trees and graphs. In Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming, 179-188, September 2008.

[fn:2] J. Michael Ashley and R. Kent Dybvig. An efficient implementation of multiple return values in Scheme. In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, 140-149, June 1994.

[fn:3] Alan Bawden. Quasiquotation in lisp. In Partial Evaluation and Semantic-Based Program Manipulation, 88-99, 1999.

[fn:4] William Briggs and Van Emden Henson. The DFT: An Owner's Manual for the Discrete Fourier Transform. Society for Industrial and Applied Mathematics, Philadelphia, PA, 1995.

[fn:5] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, 108-116, May 1996.

[fn:6] William F. Clocksin and Christopher S. Mellish. Programming in Prolog, second edition. Springer-Verlag, Berlin, 1984.

[fn:7] Sam M. Daniel. Efficient recursive FFT implementation in Prolog. In Proceedings of the Second International Conference on the Practical Application of Prolog, 175-185, 1994.

[fn:8] Mark Davis. Unicode Standard Annex #29: Text boundaries, 2006. http://www.unicode.org/reports/tr29/.

[fn:9] R. Kent Dybvig. Chez Scheme User's Guide: Version 8. Cadence Research Systems, 2009. http://www.scheme.com/csug8/.

[fn:10] R. Kent Dybvig and Robert Hieb. Engines from continuations. Computer Languages, 14(2):109-123, 1989.

[fn:11] R. Kent Dybvig and Robert Hieb. A new approach to procedures with variable arity. Lisp and Symbolic Computation, 3(3):229-244, September 1990.

[fn:12] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295-326, 1993.

[fn:13] Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth edition. MIT Press, Cambridge, MA, 1996.

[fn:14] Daniel P. Friedman, Christopher T. Haynes, and Eugene E. Kohlbecker. Programming with continuations. In P. Pepper, editor, Program Transformation and Programming Environments, 263-274. Springer-Verlag, New York, 1984.

[fn:15] Christopher T. Haynes and Daniel P. Friedman. Abstracting timed preemption with engines. Computer Languages, 12(2):109-121, 1987.

[fn:16] Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. Obtaining coroutines with continuations. Computer Languages, 11(3/4):143-153, 1986.

[fn:17] Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of first-class continuations. In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, 66-77, June 1990.

[fn:18] IEEE Computer Society. IEEE Standard for the Scheme Programming Language, May 1991. IEEE Std 1178-1990.

[fn:19] Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language, second edition. Prentice Hall, Englewood Cliffs, NJ, 1988.

[fn:20] P. Leach, M. Mealling, and R. Salz. A Universally Unique IDentifier (UUID) URN namespace, July 2005. RFC 4122. http://www.ietf.org/rfc/rfc4122.txt.

[fn:21] Peter Naur et al. Revised report on the algorithmic language ALGOL 60. Communications of the ACM, 6(1):1-17, January 1963.

[fn:22] David A. Plaisted. Constructs for sets, quantifiers, and rewrite rules in Lisp. Technical Report UIUCDCS-R-84-1176, University of Illinois at Urbana-Champaign Department of Computer Science, June 1984.

[fn:23] J. A. Robinson. A machine-oriented logic based on the resolution principle. Journal of the ACM, 12(1):23-41, 1965.

[fn:24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme, September 2007. http://www.r6rs.org/.

[fn:25] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---non-normative appendices, September 2007. http://www.r6rs.org/.

[fn:26] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---standard libraries, September 2007. http://www.r6rs.org/.

[fn:27] Guy L. Steele Jr. Common Lisp, the Language, second edition. Digital Press, Bedford, Massachusetts, 1990.

[fn:28] Guy L. Steele Jr. and Gerald J. Sussman. The revised report on Scheme, a dialect of Lisp. MIT AI Memo 452, Massachusetts Institute of Technology, January 1978.

[fn:29] Gerald J. Sussman and Guy L. Steele Jr. Scheme: An interpreter for extended lambda calculus. Higher-Order and Symbolic Computation, 11(4):405-439, 1998. Reprinted from the AI Memo 349, MIT (1975), with a foreword.

[fn:30] The Unicode Consortium. The Unicode Standard, Version 5.0, fifth edition. Addison-Wesley Professional, Boston, MA, 2006.

[fn:31] Oscar Waddell, Dipanwita Sarkar, and R. Kent Dybvig. Fixing letrec: A faithful yet efficient implementation of Scheme's recursive binding construct. Higher-Order and Symbolic Computation, 18(3/4):299-326, 2005.

[fn:32] Mitchell Wand. Continuation-based multiprocessing. Higher-Order and Symbolic Computation, 12(3):285-299, 1999. Reprinted from the proceedings of the 1980 Lisp Conference, with a foreword.
