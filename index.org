# -*- org-image-actual-width: 'true; -*-
# -*- fill-column: 120; -*-

#+STARTUP: nofninline
#+STARTUP: showall

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [11pt,fleqn, oneside]
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER: \usepackage[T1,T2A]{fontenc}
#+LATEX_HEADER: \usepackage[unicode]{hyperref}
#+LATEX_HEADER: \usepackage[english,russian]{babel}
#+LANGUAGE: RU
#+OPTIONS: toc:nil title:nil

#+TITLE: Язык программирования Scheme, 4-е издание
#+AUTHOR: R. Kent Dybvig

#+NAME: cover
#+ATTR_ORG: :width 300
[[./images/cover.png]]

#+LATEX: \newpage
#+LATEX: \tableofcontents

#+LATEX: \newpage

* Предисловие

  Язык Scheme увидел свет в 1975 году, благодаря стараниям Джеральда Дж.Суссмана и Гая Л.Стили младшего [fn:28],[fn:29], и
  был первым диалектом лиспа, полностью поддерживающим лексические области видимости, процедуры первого класса, и
  продолжения. В первоначальном виде это был очень простой язык, предназначенный, главным образом, для исследований и
  обучения, поддерживающий только небольшой набор предопределённых синтаксических форм и процедур. Сейчас Scheme -
  полноправный язык общего назначения, хотя он до сих пор черпает свою силу из небольшого набора ключевых идей. Ранние
  реализации языка были основаны на интерпретации и не отличались производительностью, однако сейчас существуют реализации
  Scheme, которые могут похвастаться сложными компиляторами, генерирующими код на ровне с кодом, генерируемым лучшими
  оптимизирующими компиляторами низкоуровневых языков, таких как C и Fortran.

  Данная книга нацелена на то, чтобы предоставить введение в язык программирования Scheme, но не в программирование в
  целом. Ожидается, что читатель уже имеет некоторый опыт в программировании и владеет терминами, обычно применяемыми в
  программировании. Читателю, не имеющему представления о Scheme и Lisp, следует сначала обратиться к ~The Little
  Schemer~ [fn:13], чтобы познакомиться с обработкой списков и рекурсией. Новичкам в программировании следует обратиться к
  литературе для новичков.

  Scheme был стандартизован как формально, так и неформально. IEEE стандарт ~Scheme Programming Language~ [fn:18]
  описывает формальный ANSI/IEEE стандарт для Scheme, однако он датирован 1991 годом. Связанная серия докладов 'Отчёты по
  пересмотру алгоритмического языка Scheme' ('Revised Reports on the Algorithmic Language Scheme') документируют
  развивающийся неофициальный стандарт, поддерживаемый большинством реализаций языка. Текущая версия отчёта из этой
  серии - 'Revised6 Report on the Algorithmic Language Scheme' [fn:24] была опубликована в 2007 году.

  Данная книга рассматривает версию языка, описываемую шестой версией (Revised6) отчёта. Она не нацелена на то, чтобы
  заменить данный отчёт, а скорее, предоставить более понятное введение и предметный указатель для языка, с более
  подробными разъяснениями и примерами, большего нацеленного на пользователей языка, а не разработчиков компиляторов для
  него. Описание возможностей, присущих конкретной реализации, отсутствует.

  В частности, возможности, специфичные для авторских реализаций ~Chez Scheme~ и ~Petite Chez Scheme~ описаны отдельно в
  Chez Scheme User's Guide [fn:9]. С другой стороны, не одна книга по Scheme не будет полной без описания интерактивной
  оболочки, поскольку почти каждая реализация Scheme поддерживает интерактивное использование системы в той или иной
  форме, не смотря на то, что данное поведение не стандартизировано Revised6 отчётом. Таким образом, в главах 2 и 3
  предполагается, что у читателя имеется реализация Scheme, которая поддерживает интерактивную оболочку, причем поведение
  соответствует описанию среды верхнего уровня в предыдущих отчетах и стандарту IEEE/ANSI.

  В тексте книги вы найдёте большое количество примеров маленького и среднего размера, а также отдельную главу,
  посвященную рассмотрению нескольких больших примеров. Большинство из них показывают, как могут быть реализованы
  стандартные синтаксические формы и процедуры Scheme, остальные - реализацию полезных расширений. Все эти примеры могут
  быть набраны непосредственно с клавиатуры в рамках сессии интерактивной оболочке.

  Книга разбита на 12 основных глав, плюс приложения. Глава 1 рассматривает те свойства и возможности языка Scheme,
  которые делают его полезным и приятным в использовании. В этой главе так же описаны типографические и нотационные
  соглашения, применяемые в этой книге.

  Глава 2 это введение в программирование на Scheme для начинающих Scheme-программистов, которая проведёт читателя через
  серию примеров, начиная с простейших выражений Scheme и продолжая всё более сложными примерами. Каждая секция второй
  главы представляет читателю маленький набор связанных функций языка, а в конце каждой секции содержится набор упражнений
  для дальнейшей практики. Читатель извлечёт значительно больше пользы из главы, если параллельно с чтением, будет сидеть
  за клавиатурой и набирать примеры и упражнения.

  Глава 3 так же содержит введение, но покрывает более сложные функции и принципы языка. Упражнения из этой главы могут
  быть интересны даже тем читателям, которые уже имеют некоторый опыт в Scheme.

  Главаы с 4 по 11 представляют из себя справочную часть книги. Здесь представлена каждая примитивная процедура и
  синтаксическая форма Scheme, которые, в свою очередь, сгруппированы в короткие секции связанных процедур и форм. Глава 4
  описывает операции объявления и присвоения процедур и переменных. Глава 5 - операции управления ходом выполнения
  программы. Глава 6 - операции над объектами различных типов (в т.ч. списки, числа, строки). Глава 7 - операции
  ввода-вывода. Глава 8 - расширение синтаксиса. Глава 9 - объявление типа данных 'запись'(record). Глава 10 - библиотеки
  и высокоуровневые (top-level) программы. Глава 11 - выражения и продолжения.

  Глава 12 содержит коллекцию примеров процедур, библиотек и программ, каждая с коротким обзором, примеры их
  использования, их реализация с краткими пояснениями и ряд упражнений для дальнейшей самостоятельной работы. Каждая из
  этих программ демонстрирует определённый функционал, а вместе они описывают стиль программирования, принятый в Scheme.

  Вслед за главой 12 идут библиографические ссылки, ответы на некоторые упражнения, полное описание формального синтаксиса
  программ и данных Scheme, включающее полный перечень синтаксических форм и процедур, а так же предметный
  указатель. Полный перечень форм и процедур полезен прежде всего как первое место, куда может заглянуть программист,
  неуверенный в структуре синтаксической формы или ожидаемых примитивной процедурой аргументах. Номера страниц,
  представленные в перечне форм и процедур, а так же номера страниц, выделенные курсивом, в предметном указателе,
  указывают местоположение в тексте, где было приведено описание данной процедуры или формы.

  В виду того, что справочная часть книги содержит такие аспекты языка, которые небыли представлены во введении, а так же
  ряд интересных, коротких примеров, для большинства читателей будет полезнее прочесть большую часть материала, чтобы
  познакомиться поближе с каждой возможностью языка и как это реализуется на других языках. Глава 6 является довольно
  длинной, так что она может быть пропущена при первом прочтении - обращайтесь к ней по мере необходимости, когда увидите
  ссылки на неё в тексте.

  Онлайн версия книги доступна по адресу http://www.scheme.com/tspl/ (русский перевод доступен по адресу
  http://github.com/noobsenslaver/scheme_book/releases). В полном перечне форм и в предметном указателе так же указаны
  номера страниц для печатной версии книги, так что ими можно пользоваться для облегчения поиска обладателям печатных
  версий книги.

  Касаемо иллюстраций: обложка и иллюстрация в начале каждой главы это алгоритмические композиции фонов линий, созданные
  художником Жаном-Пьером Эбертом, основанные на идее, вдохновленной трудами Джона Кейджа. Фон каждой линии вычисляется
  путём сопоставления некоего количества сеток параллельных линий. Каждая сетка регулярна, но линии нет. Например, линии
  имеют разную длину, что образует неровные края. Их тон и толщина немного отличаются. Они могут быть похожи, но не
  равны. Они пересекают друг друга под неким углом. Когда это угол мал, возникает интерференция. Линии сначала погружаются
  в различные скалярные поля, которые возмущают их исходную прямую форму, а потом проецируются на плоскость бумаги. Маски
  вводят отверстия в некоторых слоях. Для иллюстрации обложки сетки окрашены в разные оттенки.

  Все эти изображения созданы одной программой на Scheme, которая принимает большинство решений на вероятностной
  основе. Художник контролирует только размер холста, соотношение сторон, общую палитру цветов и уровни вероятности и
  нечеткости. Задача художника состоит в том, чтобы ввести достаточно шансов в нужном месте, чтобы результаты были
  одновременно удивительными, интересными и удовлетворяли эстетическому чувству художника. Это игра неопределенности,
  хаоса и гармонии.

  Благодарности: Многие люди так или иначе способствовали подготовке одного или нескольких изданий этой книги, в том числе
  Брюс Смит, Евгений Кольбекер, Маттиас Феллесинен, Дэн Фридман, Брюс Дуба, Фил Дыбвиг, Гай Стил, Боб Хиб, Крис Хейнс,
  Дэйв Плайед, Джоан Карри, Фрэнк Сильберманн, Павел Кертис, Джон Уайт, Карл Бруггман, Сэм Даниэль, Оскар Уодделл , Майк
  Эшли, Джон Лалонд, Джон Цукерман, Джон Симмонс, Боб Приор, Боб Бургер и Азиз Гулум. Многие другие предложили небольшие
  исправления и предложения. Оскар Уодделл помог создать систему набора, используемую для форматирования печатных и
  онлайн-версий этой книги. Небольшое количество текста и примеров было заимствовано из ~Revised6 отчёта~ и адаптировано
  для данной книги, за что благодарю авторов этого отчёта и многих других, кто способствовал его написанию. И наконец,
  самую большую благодарность я выражаю моей жене Сьюзан Дыбвиг, в первую очередь за то, что она предложила написать эту
  книгу, а так же за её неоценимую помощь в создании и публикации этого и предыдущих изданий.

#+LATEX: \newpage
[[./images/ch1.png]]

** Введение.

   Scheme - это язык программирования общего назначения. Он является высокоуровневым, поддерживает операции над сложными
   типами данных, такими как строки, списки и векторы, а так же операции над традиционными типами
   данных, такими как числа и символы. Хотя Scheme часто ассоциируется с символьными (symbolic) приложениями, он так же
   имеет богатый набор типов данных и гибких управляющих структур, что делает его поистине гибким, разносторонним
   языком. Scheme использовался для написания текстовых редакторов, оптимизирующих компиляторов, операционных систем,
   графических пакетов, экспертных систем, числовых приложений, пакетов для финансового анализа, систем виртуальной
   реальности и практически в любой другой области, которую вы только сможете придумать. Scheme довольно простой язык для
   изучения, потому что он основан на небольшом количестве синтаксических форм и симантических идей, а интерактивная
   природа большинства реализаций способствует экспериментам с языком. В то же время довольно сложно изучить Scheme
   полностью - обретение способности использовать весь потенциал языка требует тщательного изучения и практики.

   Программы, написанные на Scheme, обладают высокой переносимостью между различными машинами (в рамках одной реализации
   Scheme), потому что все машинозависимые части обычно полностью сокрыты от программиста. Часто программы переносимы и
   между различными реализациями Scheme благодаря усилиям группы создателей языка, которые опубликовали серию отчётов
   'Revised Reports' для Scheme. Последний, 'Revised6 Report' [fn:24], акцентирует внимание на переносимости, вводя ряд
   стандартных библиотек и стандартный механизм для определения новых переносимых библиотек и программ верхнего уровня.

   Несмотря на то, что ранние реализации Scheme были неэффективны и медлительны, многие новые, основанные на компиляции,
   реализации быстры и способны производить код, работающий на ровне с программами, написанными на низкоуровневых
   языках. Относительная неэффективность, которую часто вменяют языку, ввиду того, что он требует проведения некоторых
   проверок во время выполнения для поддержки обобщенной арифметики и возможности предоставления программисту достаточной
   информации для обнаружения и исправления ошибки - всё это может быть отключено в большинстве реализаций языка.

   Scheme поддерживает множество типов данных, или объектов, включая буквы, строки, символы, списки или векторы объектов,
   и полный набор числовых типов данных, таких как комплексные, дробные, с плавающей точкой, рациональные числа.

   Память, требуемая под хранение содержимого объектов, выделяется динамически по необходимости и сохраняется до тех пор,
   пока используется, а затем автоматически освобождается, обычно, сборщиком мусора, который периодически очищает память
   от неиспользуемых объектов. Простые атомарные значения, такие как маленькие числа, буквы, булевы значения и пустые
   списки, обычно представлены в виде непосредственно своих значений и не требуют дополнительных затрат на выделения и
   освобождения памяти.

   Независимо от представления, /все/ данные являются объектами первого класса. Все они хранятся независимо и могут
   свободно передаваться как аргументы в процедуры, возвращаться как значение из процедуры, или комбинироваться для
   образования новых объектов.

   Это выделяет Scheme из множества других языков, где под составные структуры данных, такие как массивы, память
   выделяется статически и никогда не освобождается, выделяется при входе в блок кода и освобождается независимо от
   остальных условий при выходе из блока, или же выделяется и освобождается  программистом явно.

   Scheme относится к языкам с /вызовом-по-значению/ , но для, по меньшей мере,  мутабельных объектов (объекты, которые
   могут быть изменены), значением является указатель на реальное место хранения объекта. Эти указатели остаются за
   сценой, так что программисту нет нужды вдаваться в подробности их работы, за исключением лишь того, что бы понимать,
   что реальное значение содержимого хранилища объекта не копируется, когда объект передаётся или возвращается из
   процедуры.

   В сердце языка Scheme лежит небольшой набор синтаксических форм, из которых построены все остальные формы. Эти
   ключевые формы, расширенный набор синтаксических форм, выведенных из оных, вместе с примитивными процедурами и
   составляют язык Scheme. Интерпретатор или компилятор для Scheme может быть крайне мал, потенциально быстр и
   надёжен. Расширенные синтаксические формы и многие основные процедуры могут быть написаны на самом же Scheme, упрощая
   реализацию и увеличивая надёжность.

   Программы и структуры данных на Scheme выглядят одинаково, имеют одинаковое печатное представление. Как результат,
   любая программа на Scheme естественным и понятным образом представляется в виде объекта данных Scheme. Например,
   переменные и синтаксические ключевые слова представлены символами, в то время как структурированные синтаксические
   формы представлены в виде списков. Это представление лежит в основе возможностей по расширению синтаксиса,
   предоставляемых Scheme, для определения новых синтаксических форм в терминах уже существующих синтаксических форм и
   процедур. Это так же значительно облегчает написание интерпретаторов, компиляторов и других преобразующих код
   Scheme инструментов, непосредственно на самом же Scheme, а так же программ, преобразующих код других языков в Scheme.

   В Scheme ключевые слова и переменные имеют лексическую область видимости, а программы имеют блочную структуру.
   Идентификаторы могут быть импортированы в программу или библиотеку, или связаны локально в пределах блока
   кода, такого как библиотека, программа или тело процедуры. Локальное связывание имеет лексическую область видимости
   т.е. только в тексте программы, который составляет конкретный блок кода. Упоминание идентификатора с тем же именем за
   пределами этого блока кода, будет указывать на другой объект. Блоки могут быть вложенными, и связывания во внутреннем
   блоке могут /затенять/ связывания с тем же идентификатором в окружающем его блоке. Область связывания - это блок, в
   котором идентификатор связан, минус любые участки блока, в которых идентификатор затенён. Блочная структура и
   лексическая область видимости позволяют создавать программы, которые будут модульными, легко читаемыми,
   поддерживаемыми и надёжными. Лексическая область видимости так же позволяет производить эффективный код, потому что
   компилятор способен определить области действия всех связываний еще до выполнения программы и провести связывание
   с тем, во что раскрылась бы каждая ссылка на идентификатор в итоге. Это конечно не значит, что компилятор способен
   определить значения всех переменных, поскольку фактические значения не вычисляются в большинстве случаев до тех пор,
   пока программа не выполнится.

   В большинстве языков, объявление процедуры это просто сопоставление имени с блоком кода. Определённые переменные,
   локальные для этого блока, являются параметрами процедуры. В некоторых языках, процедура может быть объявлена в
   пределах другого блока или процедуры, и существовать до тех пор, пока выполнение этого участка кода не достигнет
   конца блока. В других, процедуры могут быть объявлены только на верхнем уровне. В Scheme, объявление процедуры может
   быть произведено внутри другого блока или процедуры и эта процедура затем может быть выполнена в любое время, даже
   когда внешний блок кода завершил своё выполнение. Для поддержки лексической области видимости, процедура, помимо
   самого кода, хранит в себе лексический контекст (окружение).

   Более того, процедуры в Scheme не всегда имеют имена. Вместо этого, процедуры являются объектами первого класса,
   такими как строки или числа, и переменная может быть связана с процедурой тем же способом, как связывается с любым
   другим объектом.

   Процедуры в Scheme, так же как и в большинстве других языков, могут быть рекурсивными. Это значит, что любая
   процедура, прямо или косвенно, может вызывать саму себя. Многие алгоритмы, будучи представленными в рекурсивном виде,
   становятся элегантнее или эффективнее. Особый вид рекурсии, называемый /хвостовая рекурсия/, используется для
   выражения итераций или циклов. Вызов считается хвостовым, когда одна процедура прямо возвращает результат выполнения
   другой процедуры. Рекурсия считается хвостовой, когда процедура, прямо или косвенно, рекурсивно делает хвостовой вызов
   самой себя. Ко всем реализациям Scheme предъявляется требование, реализовать хвостовые вызовы в виде переходов
   (gotos), а значит, накладные расходы по памяти и стеку, обычно ассоциируемые с рекурсией, устраняются. Как результат,
   Scheme программистам нужно лишь разобраться в обычных вызовах процедур и рекурсии, и нет никакой нужды обременять себя
   обычным набором итерационных конструкций.

   Scheme поддерживает определение произвольных управляющих структур с помощью /продолжений/ . /Продолжение/ , это
   процедура, которая заключает в себе остальную часть программы в заданной точке. /Продолжение/ может быть получено в
   любой момент во время выполнения программы. Так же, как и с другими процедурами, /продолжение/ является объектом
   первого класса и может быть выполнено в любой момент после его создания. Когда оно выполняется, программа немедленно
   продолжает выполнение с той точки, где это /продолжение/ было создано. /Продолжения/ позволяют реализовать сложные
   механизмы управления, включая поиск с возвратом, многопоточность и сопрограммы.

   Scheme так же позволяет программистам создавать новые синтаксические формы, или синтаксические выражения, путём
   написания преобразующих процедур, определяющих, как каждая новая синтаксическая форма будет преобразовываться в
   существующие синтаксические формы. Эта преобразующая процедура сама по себе выражается в Scheme с помощью удобного
   высокоуровневого языка шаблонов, который берёт на себя заботы по проверке синтаксиса, деконструкции входных данных и
   реконструкции выходных. По умолчанию, лексическая область видимости действует так же и для подобных преобразующих
   процессов, однако программист может осуществлять контроль над областью действия всех идентификаторов, появляющихся на
   выходе преобразователя. Синтаксические выражения полезны для объявления новых языковых конструкций, для имитации
   языковых конструкций, найденных в других языках программирования, для достижения эффекта встраивания (in-line)
   выражений, а так же для имитации целого языка. Большинство больших программ на Scheme представляют из себя комбинацию
   синтаксических выражений и объявлений процедур.

   Scheme произошел от Lisp'a и считается его диалектом. Scheme унаследовал от Lisp'a подход к работе с значениями, как
   объектами первого класса, ряд важных структур данных, включая символы и списки, представление программ как объектов, и
   многое другое. Лексическая область видимости и блочная структура - возможности, позаимствованные из Algol
   60 [fn:21]. Scheme был первым диалектом Lisp'a, впитавшим в себя идеи лексической области видимости и блочной
   структуры, процедур первого класса, оптимизацию хвостовой рекурсии, продолжения, и синтаксических выражений с
   лексической областью действия.

   Common Lisp [fn:27] и Scheme являются современными потомками Lisp'a, и развитие каждого из них так же сказывается и на
   другом. Как и в Scheme, но чего не было в ранних версиях Lisp'а, Common Lisp перенял лексическую область видимости и
   процедуры первого класса, не смотря на то, что в Common Lisp средства построения синтаксических выражений не считаются
   с лексической областью видимости. В Common Lisp правила обработки процедур отличаются от правил обработки остальных
   объектов, так же он поддерживает отдельное пространство имён для процедур, что препятствует использованию процедур как
   объектов первого класса. И хотя Common Lisp не поддерживает /продолжения/ или требует правильного обращения с
   хвостовыми вызовами, однако он поддерживает ряд менее общих структур данных, которых нет в Scheme. Хотя оба языка
   похожи, Common Lisp включает в себя более специализированные конструкции, в то время как Scheme включает в себя более
   универсальные строительные блоки, из которых могут быть построены такие конструкции (и другие).

   Остаток этой главы содержит в себе описание синтаксиса Scheme, соглашений в именовании и типографических соглашений,
   используемых в этой книге.

*** Синтаксис

    Программы на Scheme состоят из ключевых слов, переменных, структурирующих форм, константных данных (числа, буквы,
    строки, цитируемые векторы, цитируемые списки, цитируемые символы и т.д.), пробелов и комментариев.

    Ключевые слова, переменные и символы собирательно именуются идентификаторами. Идентификаторы могут быть образованы из
    букв, чисел и некоторых специальных символов, включающих ~?~, ~!~, ~.~, ~+~, ~-~, ~*~, ~/~, ~<~, ~=~, ~>~, ~:~, ~$~,
    ~%~, ~^~, ~&~, ~_~, ~~~, и ~@~, так же ряда дополнительных символов из Unicode. Идентификаторы не могут начинаться со
    знака @, а так же со знаков, с которых может начинаться число, таких как ~+~, ~-~, ~.~, исключение ~-~ знаки ~+~, ~-~
    и некоторые другие, которые могут быть идентификаторами сами по себе, а так же идентификаторы, начинающиеся с
    ~->~. Например, ~hi~, ~Hello~, ~n~, ~x~, ~x3~, ~x+2~, и ~?$&*!!!~ - корректные идентификаторы. Идентификаторы
    отделяются пробелами, комментарием, скобками, фигурными скобками, двойными кавычками и знаком решётки. Разделитель,
    или любая другая буква Unicode, могут быть включены в любое место в имени идентификатора путём экранирования в виде
    ~\xsv~, где sv - скалярное значение символа в шестнадцатеричном представлении.

    На длину идентификаторов не накладывается никаких ограничений, программист использовать столько символов в имени,
    сколько посчитает нужным. Однако, длинные идентификаторы не заменят комментариев, в то же время, их частое
    использование может сделать код трудным для форматирования и чтения. Хорошее правило, это использовать короткие имена
    идентификаторов в тех случаях, когда область видимости идентификатора мала, и длинные тогда, когда область видимости
    велика.

    Идентификаторы могут содержать любую комбинацию символов верхнего или нижнего регистров, регистр учитывается т.е. два
    идентификатора считаются различными, даже если они отличаются только регистром. Например, ~abcde~, ~Abcde~, ~AbCdE~ и
    ~ABCDE~ - все различные идентификаторы. Это нововведение, по сравнению с предыдущими отчётами по стандарту языка.

    Структурированные формы и списки констант заключаются в скобки, например ~(a b c)~ или ~(* (- x 2) y)~. Пустой список
    записывается как ~()~. Другие парные наборы скобок, такие как ~[~ ~]~, могут быть использованы вместо круглых скобок
    и часто используются для выделения подвыражений определенных стандартных синтаксических форм для удобочитаемости, как
    в примерах в этой книге. Векторы записываются таким же образом, как и списки, за исключением того, что они начинаются
    с ~#(~ и заканчиваются ~)~, например ~#(это вектор содержащий символы)~. Байт-векторы записываются как
    последовательность беззнаковых байтов (обычные целочисленные значения в диапазоне от 0 до 255), заключенных в ~#vu8(~
    и ~)~, например ~#vu8(3 250 45 73)~.

    Строки заключаются в двойные кавычки, например "Это строка" . Буквы предваряются ~#\~, например ~#\a~. Когда речь
    идёт о строках или буквах - регистр имеет значение, так же как и в случае с идентификаторами. Числа могут быть
    записаны в виде целочисленного значения (integer), например ~-123~, рационального числа, например ~1/2~, числа с
    плавающей точкой или в научной форме, например ~1.3~ или ~1e23~, как комплексное число, в прямоугольной или полярной
    системах координат например ~1.3-2.7i~ или ~-1.2@73~. В случае чисел регистр не имеет значения. Булевы значения,
    представляющие ложь и истину, обозначаются ~#f~ и ~#t~ соответственно. В Scheme, условные выражения обычно считают
    ~#f~ ложью, а любой другой объект истиной, так что ~3~, ~0~, ~()~, "false" или ~nil~ - всё это считается истиной.

    Детальное описание синтаксиса каждого константного типа данных дано в отдельной секции в главе 6 и в формальном
    описании синтаксиса, приведённом в конце книги.

    Выражения в Scheme могут занимать несколько строк, для этого не требуются специальные терминирующие
    символы. Учитывая, что количество пробельных символов и переводов строки между выражениями не имеет синтаксического
    значения, эту возможность следует использовать, чтобы программы на Scheme были выровнены таким образом, чтобы
    правильно отображать структуру кода и делать его настолько читаемым, насколько это возможно. Комментарии могут быть
    размещены в каждой строке программы, между символом ~;~ и концом строки. Комментарий, поясняющий конкретное выражение
    Scheme, обычно размещается в предыдущей строке, с тем же уровнем отступа. Комментарии, поясняющие процедуру или
    группу процедур, обычно размещаются перед процедурой, без отступа.

    Так же поддерживаются следующие два вида комментариев: блочные и комментарии по данным (datum). Блочные комментарии
    обосабливаются парой ~#|~ и ~|~, и могут быть вложенными. Комментарии данных начинаются с префикса ~#;~ , за которым
    следует печатная версия объекта данных. Комментарии по данным обычно используются, чтобы закомментировать конкретное
    объявление или выражение. Например, ~(список из трёх #;(а не четырёх) элементов)~. Комментарии по данным могут так же
    быть вложенными, например ~#;#;(a)(b)~, но это не имеет какого то особого значения, в сравнении, если бы
    комментировался каждый элемент по отдельности.

    Некоторые значения в Scheme, такие как процедуры или порты, не имеют стандартизированного печатного представления и
    по этому не могут быть представлены константой при печати. В этой книге используется обозначение ~#<пояснение>~,
    когда мы хотим оказать возвращаемый результат какой либо операции, возвращающей одно из таких значений, например
    ~#<procedure>~ или ~#<port>~.

*** Соглашения в именовании

    Соглашения по именованию, принятые в Scheme, разработаны так, чтобы обеспечивать высокий уровень системности и
    регулярности. Ниже приведён список таких соглашений:

    + Имена предикатов заканчиваются символом вопроса (?). Предикаты, это процедуры, возвращающие истину или ложь, такие
      как ~eq?~, ~zero?~ и ~string=?~. Обычные для чисел операции сравнения, такие как ~=~, ~<~, ~>~, ~<=~, и ~>=~
      являются исключением из правил.
    + Предикаты типов, например ~pair?~, составляются из имени типа, в данном случае /pair/ и знака вопроса.
    + Имена большинства процедур предикатов для букв, строк и векторов начинаются с префикса ~char-~, ~string-~,
      ~vector-~, например ~string-append~. (Имена некоторых процедур для списков начинаются с ~list-~, но большинство
      нет)
    + Имена процедур, которые преобразуют объект одного типа в объект другого типа, записываются как ~type1->type2~,
      например ~vector->list~.
    + Имена процедур и синтаксических форм, производящих побочные эффекты, оканчиваются знаком восклицательного знака
      (~!~). Например ~set!~ и ~vector-set!~. Процедуры, производящие операции ввода-вывода, формально так же считаются
      процедурами с побочными эффектами, однако они попадают под исключение из правил.
    + Программистам следует следовать этим соглашениям по именованию там, где это возможно.

*** Типографические и нотационные соглашения

    Про стандартные процедуры или синтаксические формы, единственная цель которых выполнение побочных эффектов, сказано,
    что возвращаемый ими результат не определён. Это значит, что конкретная реализация свободна возвращать любое
    количество значений, каждое из которых может быть любым объектом Scheme. Не рассчитывайте на то, что эти возвращаемые
    значения одинаковы для всех реализаций, одинаковые для версий одной и той же реализации, или даже одинаковы между
    двумя вызовами одной и той же процедуры или синтаксической формы. Некоторые реализации Scheme используют специальные
    объекты для обозначения неопределённого значения. Печать этого объекта часто подавляется интерактивными системами
    Scheme, поэтому значения выражений, возвращающих неопределённые значения, не печатаются.

    В то время, как большинство стандартных процедур возвращает одно значение, язык поддерживает процедуры, которые
    возвращают ноль, одно, более одного, или переменное количество значений, используя механизм, описанный в главе
    5.8. Некоторые стандартные выражения могут вычисляться в множество значений, если одно из подвыражений вычисляется в
    множество значений т.е. когда вызывается процедура, возвращающая несколько значений. Когда такое случается, выражению
    предписано возвращать /значения/, а не /значение/ его подвыражения. То же касается стандартных процедур, принимающих
    аргументом функцию - им предписывается возвращать множественное значение в том случае, если процедура-аргумент,
    влияющая на результат, возвращает множественное значение.

    В этой книге используются слова 'должен' и 'следует', чтобы описать программные требования, такие как требование,
    чтобы передаваемый индекс был меньше, чем длина вектора, при вызове ~vector-ref~. Если использовано слово 'должен', это
    значит, что реализация будет отслеживать выполнение этих требований т.е. будет выброшено исключение, обычно с типом
    условия ~&assertion~. Если используется слово 'следует', исключение может быть выброшено, а может не быть, если нет -
    поведение программы не определено. Фраза 'нарушение синтаксиса' используется, чтобы описать ситуацию, когда программа
    сформирована неправильно. Нарушения синтаксиса обнаруживаются в основном при выполнении программы. Когда нарушение
    синтаксиса обнаружено, выбрасывается исключение типа ~&syntax~ и программа прекращает работу.

    Типографические соглашения, используемые в этой книге весьма просты. Все объекты напечатаны таким же образом, как они
    выглядели бы, если бы их набрали на клавиатуре. Это касается ключевых слов синтаксиса, переменных, константных
    объектов, выражений Scheme, и примеров программ. Выделение /курсивом/ используется для обозначения синтаксических
    переменных в пояснениях синтаксических форм, аргументов и процедур. Так же курсивом выделены технических термины,
    используемые впервые. Обычно, имена и синтаксические формы находятся в нижнем регистре, даже если они начинают новое
    предложение.  То же касается и синтаксических переменных, выделенных курсивом.

    В описании синтаксических форм и процедур, один или несколько прототипов шаблонов показывают синтаксическую форму или
    формы или корректное количество аргументов для применения процедуры. Ключевое слово или имя процедуры выделяются
    машинописным шрифтом, так же как и круглые скобки. Остальные части синтаксиса или аргументы выделяются курсивом,
    используя имя, обозначающее тип выражения или аргумента, ожидаемого синтаксической формой или процедурой. Окружности
    используются для обозначения нуля или более вхождений подвыражения или аргумента. Например, ~(or expr ...)~
    описывает синтаксическую форму ~or~, которая имеет ноль или более подвыражений, и ~(member obj list)~ описывает
    процедуру ~member~, которая ожидает два аргумента - объект и список.

    Нарушением синтаксиса считается случай, когда структура синтаксической формы не совпадает с её прототипом. Обычно,
    выбрасывается исключение типа ~&assertion~, если количество аргументов, переданных в стандартную процедуру не
    совпадает с тем, которое ожидается к получению. Исключение с типом условия ~&assertion~ также выбрасывается, если
    стандартная процедура получает аргумент, который не подразумевается в его названии, или не удовлетворяет другим
    критериям, указанным в описании процедуры. Например, прототип для ~vector-set!~ таков:

#+begin_src scheme
    (vector-set! vector n obj)
#+end_src

    и описание говорится, что ~n~ должен быть неотрицательным целым числом, строго меньшим, чем длина вектора. Таким
    образом, ~vector-set!~ должен получить три аргумента, первый из которых должен быть вектором, второй должен быть
    неотрицательным целым числом, меньше длины вектора, и третьим может быть любой объект Scheme. В противном случае,
    будет выброшено исключение с типом условий ~&assertion~.

    В большинстве случаев тип ожидаемого аргумента очевиден, как в случае в ~vector~, ~obj~ или ~binary-input-port~. В
    остальных же случаях, по большей части использующихся в описании числовых операций, используются сокращения, такие
    как /int/ для целочисленных, /exint/ (от exact integer) для строгого указания целочисленного типа и /fx/ для типа
    /fixnum/. Эти сокращения поясняются в начале разделов, где мы их впервые коснёмся.

#+LATEX: \newpage
[[./images/ch2.png]]

** Начало

   Данная глава является введением в Scheme для новичков. Вы извлечёте значительно больше пользы из главы, если
   параллельно с чтением, будет сидеть за интерактивной оболочкой и набирать примеры и по мере чтения.

   После окончания этой главы и работы над упражнениями, у вас будет достаточная база для того, чтобы начать использовать
   Scheme. Вы изучите синтаксис программ на Scheme и как они выполняются, а так же как использовать простейшие структуры
   данных и управляющие конструкции.

*** Взаимодействие с интерактивной оболочкой Scheme

    Большенство реализаций Scheme систем предоставляют интерактивное окружение для программирования, которое упрощает
    разработку программ и эксперименты. Простейшая интерактивная оболочка Scheme представляет из себя цикл
    "чтение-выполнение-печать" (read-evaluate-print). Эта программа (обычно называемая по англ. read-evaluate-print loop,
    или просто REPL) считывает каждое выражение, подаваемое вами с клавиатуры, выполняет его, и выводит результат
    выполнения на экран.

    Благодаря интерактивной системе Scheme, вы можете набирать выражения с клавиатуры с сразу же видеть результат его
    выполнения. Вы можете объявить процедуру и сразу применить её к аргументам, чтобы проверить, как она будет
    работать. Вы можете даже набрать всю программу, представив её как последовательность объявления и применения процедур
    и протестировать её, не покидая системы. Когда же ваша программа станет достаточно большой, удобнее будет набрать её
    в файле (используя текстовый редактор), загрузить файл (в REPL) и тестировать его интерактивно. В большинстве
    реализаций файл может быть загружен с помощью нестандартизированной процедуры ~load~ , принимающую путь к файлу в
    качестве аргумента. Разработка программы в файле имеет ряд преимуществ: у вас есть возможность составлять свою
    программу более аккуратно, вы можете исправлять ошибку, не перенабирая код заново, и вы можете сохранить копию кода
    для дальнейшего использования. Большинство реализаций Scheme трактуют выражения, загруженные из файла, таким же
    образом, как если бы они были набраны на клавиатуре интерактивно.

    Хотя Scheme предоставляет различные процедуры ввода и вывода, REPL заботится о чтении выражений и печати их
    значений. Это освобождает Вас от необходимости заботиться о том, как результаты выполнения будут отображены, и
    позволяет сконцентрироваться на написании программы.

    Примеры в этой и остальных главах книги средуют определённым соглашениям в форматировании. Выражения, которые вы
    можете набрать с клавиатуры, идут в первую очередь, возможно, в нескольких строках. После → следует значение
    выражения, что следует читать как "имеет следующее значение". Знак → применим для определений и в тех случаях, когда
    значение выражения неопределено.

    Примеры в книге отформатированы в стиле "смотрится хорошо" и передают структуру программы. Код должен читаться легко,
    потому что отношения между каждым выражением и подвыражением показаны явно. Scheme игнорирует отступы и переносы
    строки, так что, мы вольны выбрирать любой стиль форматирования на своё усмотрение. Однако довольно важно, чтобы
    выбраный вами стиль поддерживался на протяжении всей программы. Scheme востринимает вашу программу так, как если бы
    она была написана в одну линию, перечисляя все входящие в неё подвыражения слева на право.

    Если у вас сейчас есть возможность запустить интерактивную систему Scheme, будет неплохо, если вы сделаете это, и
    будете набирать примеры по мере чтения. Одно из простейших выражений Scheme, это строковая константа. Попробуйте
    набрать "Hi Mom!" (включая двойные кавычки) в ответ на преглашение. Система должна ответить "Hi Mom!", потому что
    значение вычисления любой константы - сама константа.

#+begin_src scheme
    "Hi Mom!" → "Hi Mom!"
#+end_src

    Ниже приведёны несколько выражений с ответами Scheme на них. Они разъясняются в последующих секциях этой главы,
    однако вы можете использовать их уже сейчас, чтобы попрактиковаться в использовании интерактивной оболочки.

#+begin_src scheme
    "hello" → "hello"
    42 → 42
    22/7 → 22/7
    3.141592653 → 3.141592653
    + → #<procedure>
    (+ 76 31) → 107
    (* -12 10) → -120
    '(a b c d) → (a b c d)
#+end_src

    Будьте внимательны и не пропустите не одной одинарной кавычки ( ~'~ ), двойной кавычки, или скобки. Если вы пропустите
    одинарную кавычку в последнем выражении, скорее всего вы получите сообщение о том, что произошло исключение. Просто
    попробуйте еще раз. Если вы пропустите закрывающую скобку или двойную кавычку, система, скорее всего, продолжит
    ожидать её даже после окончания ввода.

    Ниже приведён еще один набор примеров для набора. Вы можете попробовать догадаться сами, что они значат, либо
    дождаться пояснений, найдя их далее в главе.

#+begin_src scheme
    (car '(a b c)) → a
    (cdr '(a b c)) → (b c)
    (cons 'a '(b c)) → (a b c)
    (cons (car '(a b c))
          (cdr '(d e f))) → (a e f)
#+end_src

    Как вы могли заметить, выражения Scheme могут занимать несколько строк. Scheme система понимает, что это одно
    выражение по парным двойным кавычкам и скобкам.

    Теперь, давайте попробуем определить новую процедуру.

#+begin_src scheme
    (define square
      (lambda (n)
        (* n n)))
#+end_src

    Процедура ~square~ вычисляет квадрат некоего числа n. О выражении, производящем непосредственно определение
    процедуры, мы поговорим подробнее чуть позже в этой главе. А пока будет тостаточно сказать, что ~define~ производит
    связывание переменной, ~lambda~ создаёт процедуру, а ~*~ - имя процедуры умножения. Обратите внимание на форму этих
    выражений. Все составные выражения заключены в круглые скобки и записаны в префиксной нотации т.е. оператор
    предшествует аргументам. Как можно видеть, это правило выполняется всегда, даже для простейших арифметических
    операций, вроде ~*~.

    Опробуем наш ~square~ в деле:

#+begin_src scheme
    (square 5) → 25
    (square -200) → 40000
    (square 0.5) → 0.25
    (square -1/2) → 1/4
#+end_src

    Несмотря на то, что определение ниже довольно короткое, давайте поместим его в файл. Предположим, вы назвали ваш файл
    "reciprocal.ss."

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Эта процедура, ~reciprocal~ (пер. обратный), вычисляет значение 1/n для любого n ≠ 0. Для случая n = 0, ~reciprocal~
    вернёт строку "oops!". Вернитесь в интерпретатор и попробуйте загрузить ваш файл, воспользовавшись процедурой ~load~:

#+begin_src scheme
    (load "reciprocal.ss")
#+end_src

    Наконец, попробовав использовать эту процедуру, вы увидите именно то, что заключено в её определении:

#+begin_src scheme
    (reciprocal 10) → 1/10
    (reciprocal 1/10) → 10
    (reciprocal 0) → "oops!"
    (reciprocal (reciprocal 1/10)) → 1/10
#+end_src

*** Простейшие выражения

    Простейшими выражениями в Scheme являются константные объекты данных, такие как строки, числа, символы и
    списки. Scheme поддерживает и другие типы объектов, но и этих четырёх достаточно для многих программ. Ниже будет ряд
    примеров со строками и числами.

    Давайте поговорим о числах чуть подробнее. Числа - это константы. Если вы введёте число, Scheme эхом ответит им же в
    ответ. В примерах ниже показано, что Scheme поддерживает различные типы чисел:

#+begin_src scheme
    123456789987654321 → 123456789987654321
    3/4 → 3/4
    2.718281828 → 2.718281828
    2.2+1.1i → 2.2+1.1i
#+end_src

    Числа в Scheme включают точные и неточные целочисленные, рациональные, вещественные и комплексные числа. Точные
    целочисленные и рациональные имеют произвольную точность т.е. могут иметь произвольный размер. Неточные числа обычно
    используют внутреннее представление согласно стандарту IEEE о представлении чисел с плавающей точкой.

    Scheme предоставляет имена ~+~, ~-~, ~*~, и ~/~ для соответствующих арифметических операций. Каждая процедура
    поддерживает работу при передаче двух аргументов. Выражения ниже называются применением процедуры, потому что
    обозначают применение процедуры к набору аргументов.

#+begin_src scheme
    (+ 1/2 1/2) → 1
    (- 1.5 1/2) → 1.0

    (* 3 1/2) → 3/2
    (/ 1.5 3/4) → 2.0
#+end_src

    Scheme требует префиксной нотации даже для обычных арифметических операций. Любое применение процедуры, будь то
    процедура принимающая ноль, один, два или больше аргументов, записывается как ~(процедура аргумент ...)~. Это
    постоянство упрощает синтаксис выражений: одна нотация используется независимо от операции, и нет сложных правил
    относительно приоритета или ассоциативности операторов.

    Применения процедуры могут быть вложенными, в этом случае сначала вычисляются самые глубоко вложенные значения. Таким
    образом, мы можем вкладывать применения арифметических процедур друг в друга, чтобы получить вычисление более сложных
    формул.

#+begin_src scheme
    (+ (+ 2 2) (+ 2 2)) → 8
    (- 2 (* 4 1/3)) → 2/3
    (* 2 (* 2 (* 2 (* 2 2)))) → 32
    (/ (* 6/7 7/2) (- 4.5 1.5)) → 1.0
#+end_src

    Эти примеры демонстрируют всё, что вам нужно знать, чтобы использовать Scheme как четырёхфункциевый калькулятор. Хотя
    мы не будем обсуждать их в этой главе, Scheme поддерживает многие другие арифметические процедуры. Возможно, сейчас
    лучшее время, чтобы обратиться к главе 6.4 и поэксперементировать с некоторыми из них.

    Для многих задач достаточно простых числовых объектов, но иногда необходимы накопительные структуры данных,
    содержащие два или более значений. В большинстве языков программирования такой накопительной структурой данных
    является массив (~array~). В Scheme же это список (~list~). Списки записываются как последовательности объектов,
    обособленные скобками. Например, ~(1 2 3 4 5)~ это список чисел, и ~("это" "тоже" "список")~ это список строк. Списки
    не обязательно содержат объекты одного типа, так что ~(4.2 "привет")~ это корректный список, содержащий число и
    строку. Списки могут быть вложенными (содержать другие списки), так что ~((1 2) (3 4))~ это корректный список из двух
    элементов, каждый из которых это список из двух элементов.

    Вы наверное уже подметили, что списки выглядят в точности так же, как применение процедуры, и вам интересно, как
    Scheme различает их. Например, как Scheme отличит список объектов ~(obj1 obj2 ...)~ от применения процедуры
    ~(procedure arg ...)~?

    В некоторых случаях различие может показаться очевидным. Список чисел ~(1 2 3 4 5)~ довольно сложно спутать с
    применением процедуры, потому что 1 это число, а не процедура. Итак, ответ на этот вопрос мог бы быть таким, что
    Scheme смотрит на первый элемент списка и принимает решение, процедура это или нет. Такой ответ не совсем корректен,
    потому что мы можем захотеть интерпретировать корректную запись применения процедуры, такую как ~(+ 3 4), как
    список. На самом деле ответ таков, что вы сами должны сказать Scheme явно, что интерпретировать как список, а что как
    применение процедуры. Это делается с помощью ~quote~ (пер. цитата, кавычка).

#+begin_src scheme
    (quote (1 2 3 4 5)) → (1 2 3 4 5)
    (quote ("да" "это" "всё" "ещё" "список")) → ("да" "это" "всё" "ещё" "список")
    (quote (+ 3 4)) → (+ 3 4)
#+end_src

    С помощью ~quote~ мы явно даём указание интерпретировать список как данные. Попробуйте ввести выражение выше без
    ~quote~, скорее всего вы получите сообщение об исключении для первых друх выражений и результат выполнения для
    третьего.

    Поскольку использование ~quote~ крайне востребовано в Scheme коде, для него было введено специальное сокращённое
    обозначение в виде одинарной цитирующей кавычки (~`~), предшествующей выражению, которая является просто
    аббривеатурой для ~quote~.

#+begin_src scheme
    '(1 2 3 4) → (1 2 3 4)
    '((1 2) (3 4)) → ((1 2) (3 4))
    '(/ (* 2 -1) 3) → (/ (* 2 -1) 3)
#+end_src

    Обе эти формы называются выражениями цитирования. Мы обычно будет говорить об объекте, что он цитируется, когда он
    будет заключён в выражение ~quote~.

    Выражение ~quote~ это не применение процедуры, поскольку он препятствует вычислению своего подвыражения. Это
    принципиально отличная синтаксическая форма. Scheme поддерживает и иные синтаксические формы, помимо применения
    процедур и цитирования выражений. Каждая синтаксическая форма вычисляется по-своему. К счастью, не так много
    принципиально различных синтаксических форм. Мы познакомимся с большинством из них далее в этой главе.

    Не все выражения цитаты содержат списки. Попробуйте выполнить следующее выражение /с/ и /без/ оператора ~quote~.

#+begin_src scheme
    (quote hello) → hello
#+end_src

    Символ ~hello~ должен быть цитирован, чтобы предостеречь Scheme от попыток интерпретировать ~hello~ как
    переменную. Символы и переменные в Scheme имеют такое же значение, как символы и переменные в математических
    выражениях и уравнениях. Когда мы вычисляем математическое выражение ~1 - x~ для некоторого значения ~x~, мы думаем
    об ~x~ как о переменной. С другой стороны, когда мы работаем с алгебраическим уравнением ~x^2 -1 = (x - 1)(x + 1)~ мы
    думаем об ~x~ как о символе (мы вообще обо всём выражении размышляем в символьной форме). Так же как цитирование
    списка говорит Scheme интерпретировать параметризованную форму как список, а не как применение процедуры, цитирование
    идентификатора говорит Scheme интерпретировать идентификатор как сивол, а не как переменную. Хотя символы обычно
    используются для представления переменных в описании символьных уравнений или программ, символы могут также
    использоваться, например, как слова в описании предложений естественного языка.

    Вас наверное удивляет, почему применения процедур и переменные имеют такое же обозначение, как списки и
    символы. Одинаковое обозначение позволяет программам на Scheme иметь такой же вид, как и данным Scheme, что упрощает
    написание интерпретаторов, компиляторов, редакторов и других инструментов для работы с Scheme. Это продемонстрировано
    в главе 12.7, где представлен интерпретатор Scheme, написанный на самом Scheme. Многие люди считают, что это одна из
    самых значительных особенностей Scheme.

    Числа и строки также могут цитироваться:

#+begin_src scheme
    '2 → 2
    '2/3 → 2/3
    (quote "Hi Mom!") → "Hi Mom!"
#+end_src

    Числа и строки интерпретируются как константы в любом случае, так что цитировать их не обязательно.

    Теперь давайте обсудим некоторые процедуры Scheme для работы со списками. Рассмотри две базовые процедуры получения
    значения из списка: ~car~ и ~cdr~ (произносится 'кудр'). ~car~ возвращает первый элемент из списка, ~cdr~ возвращает
    оставшуюся часть, хвост списка. Имена ~car~ и ~cdr~ произошли от операций, поддерживаемых первым компьютером,
    на котором впервые был реализован Lisp, IBM 704. Обе эти операции принимают не пустой список в качестве аргумента:

#+begin_src scheme
    (car '(a b c)) → a
    (cdr '(a b c)) → (b c)
    (cdr '(a)) → ()

    (car (cdr '(a b c))) → b
    (cdr (cdr '(a b c))) → (c)

    (car '((a b) (c d))) → (a b)
    (cdr '((a b) (c d))) → ((c d))
#+end_src

    Первый элемент списка, часто называют /car/ или /головой/ списка, остальную часть списка часто называют /cdr/ или
    /хвостом/. ~cdr~ от списка с одним элементом это ~()~, пустой список.

    Процедура ~cons~ создаёт список. Она принимает два аргумента. Второй элемент, обычно, это список, в этом случае
    ~cons~ вернёт список.

#+begin_src scheme
    (cons 'a '()) → (a)
    (cons 'a '(b c)) → (a b c)
    (cons 'a (cons 'b (cons 'c '()))) → (a b c)
    (cons '(a b) '(c d)) → ((a b) c d)

    (car (cons 'a '(b c))) → a
    (cdr (cons 'a '(b c))) → (b c)
    (cons (car '(a b c))
          (cdr '(d e f))) → (a e f)
    (cons (car '(a b c))
          (cdr '(a b c))) → (a b c)
#+end_src

    "car" и "cdr" обычно употребляются в качестве существительных, "cons" в качестве глагола. Создание нового списка
    путём добавления элемента в начало списка называется /consing/ (устоявшегося перевода на русский язык нет, но
    примерный - /кортежирование/, или возможно /спаривание/, ведь здесь речь идёт о кортежах именно длины 2, у которых
    есть устоявшееся название - пары).

    Обратите внимание на слово "обычно" в описании второго аргумента ~cons~. Процедура ~cons~, на самом деле, создаёт
    пары и вовсе не обязательно, чтобы /cdr/ пары был списком. Список - это последовательность пар. /cdr/ каждой пары это
    следующая пара в последовательности.

#+ATTR_LATEX: :width 200px
[[./images/1.png]]

    /cdr/ последней пары в /правильном/ списке это пустой список. В противном случае, последовательность пар формирует
    /неправильный/ список. Если говорить более формально, то пустой список - это /правильный/ список, а так же
    /правильным/ становится любой список, /cdr/ которого /правильный/ список.

    Неправильный список печатается в точечно-парной нотации, с периодом или точкой, предшествующей последнему элементу
    списка.

#+begin_src scheme
    (cons 'a 'b) → (a . b)
    (cdr '(a . b)) → b
    (cons 'a '(b . c)) → (a b . c)
#+end_src

    Из за этих соглашений о печати, пары, чей /cdr/ не является списком, часто называют /точечными парами/. Так же пары,
    чей /cdr/ является списком так же могут быть записаны в точечно-парной нотации, однако функции печати всегда выводят
    /правильные/ списки без точек.

#+begin_src scheme
    '(a . (b . (c . ()))) → (a b c)
#+end_src

    Процедура ~list~ похожа на ~cons~, с той разницей, что она принимает произвольное количество аргументов и всегда
    строит /правильные/ списки.

#+begin_src scheme
    (list 'a 'b 'c) → (a b c)
    (list 'a) → (a)
    (list) → ()
#+end_src

    Глава 6.3 содержит больше информации о списках и процедурах Scheme для работы с ними. Возможно, сейчас самое время,
    чтобы перейти к этой главе и получше разобраться со списками и представленными там процедурами.

**** Упражнение 2.2.1

     Запишите следующие арифметические выражения в виде выражений Scheme и вычислите их:
     1. ~1.2 × (2 - 1/3) + -8.7~
     2. ~(2/3 + 4/9) ÷ (5/11 - 4/3)~
     3. ~1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))~
     4. ~1 × -2 × 3 × -4 × 5 × -6 × 7~

**** Упражнение 2.2.2

     Поэксперементируйте с процедурами ~+~, ~-~, ~*~, и ~/~ чтобы разобраться с правилами Scheme для типа значения,
     возвращаемого каждой из процедур, когда она принимает на вход аргументы различных типов.

**** Упражнение 2.2.3

     Определите, во что вычислятся следующие выражения. Используйте интерактивную систему Scheme, чтобы проверить свои
     ответы:
     1. ~(cons 'car 'cdr)~
     2. ~(list 'this '(is silly))~
     3. ~(cons 'is '(this silly?))~
     4. ~(quote (+ 2 3))~
     5. ~(cons '+ '(2 3))~
     6. ~(car '(+ 2 3))~
     7. ~(cdr '(+ 2 3))~
     8. ~cons~
     9. ~(quote cons)~
     10. ~(quote (quote cons))~
     11. ~(car (quote (quote cons)))~
     12. ~(+ 2 3)~
     13. ~(+ '2 '3)~
     14. ~(+ (car '(2 3)) (car (cdr '(2 3))))~
     15. ~((car (list + - * /)) 2 3)~

**** Упражнение 2.2.4

     ~(car (car '((a b) (c d))))~ возвращает ~a~. Определите необходимую комбинацию из ~car~ и ~cdr~, применение
     которой к ~((a b) (c d))~ вернёт ~b~, ~c~, ~d~.

**** Упражнение 2.2.5

     Напишите выражение Scheme, которое бы вычислялось в список следующей структуры:

#+ATTR_LATEX: :width 200px
[[./images/2.png]]

**** Упражнение 2.2.6

     Нарисуйте, как будет выглядить список, возвращённый следующим выражением:
     ~(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))~

**** Упражнение 2.2.7

     Поведение выражения ~(car (car (car '((a b) (c d)))))~ неопределено, потому что  ~(car '((a b) (c d)))~ это  ~(a
     b)~, ~(car '(a b))~ это ~a~, а ~(car 'a)~ неопределно. Определите все корректные комбинации ~car~ и ~cdr~ для
     выражения ~((a b) (c d))~.

**** Упражнение 2.2.8

     Попробуйте объяснить, как вычисляются выражения Scheme. Последний пример из упражнения 2.2.3 укладывается в ваше
     объяснение?

*** Выполнение Scheme выражений

    Давайте вернёмся к обсуждению, как всётаки Scheme выполняет набранные Вами выражения. Мы уже установили правила для
    константных  объектов, таких как строки и числа: эти объекты являются значениями сами по себе. Вы возможно уже
    выработали у себя в голове некоторые правила для вычисления применения процедур вида ~(procedure arg1
    ... argN)~. Здесь, ~procedure~ это выражение, представляющее Scheme процедуру, а ~arg1 ... argN~ выражения,
    представляющие её аргументы. Один из возможных вариантов её применения следующий:

    + Определить значение ~procedure~.
    + Определить значение ~arg1~.
    + ...
    + Определить значение ~argN~.
    + Применить значение ~procedure~ к значениям ~arg1 ... argN~.

    Для примера, рассмотрим применение простой процедуры ~(+ 3 4)~. Значение ~+~ это процедура сложения, значение ~3~
    это число ~3~, значение ~4~ это число ~4~. Применение процедуры сложения к ~3~ и ~4~ даёт ~7~, так что мы получаем
    значение ~7~.

    Применяя данный алгоритм на каждом уровне, мы можем найти значения вложенного выражения ~(* (+ 3 4) 2)~. Значение
    ~*~ это процедура умножения, значение ~(+ 3 4)~, как мы выяснили выше, это ~7~, а значение ~2~ это ~2~. Перемножив
    ~7~ и ~2~ мы получаем ~14~, так что наш ответ ~14~.

    Это правило работает для применения процедуры, но не работает для /цитированного/ выражения, потому что подвыражения
    примененияя процедуры вычисляются, в то время как подвыражения /цитированного/ выражения нет. Вычисление
    /цитированного/ выражения более похоже на вычисление константного объекта. Значение /цитированного/ выражения ~(quote
    object)~ это просто ~object~.

    Константные объекты, применения процедур и /цитированные/ выражения это только три из множества синтаксических форм,
    предоставляемых Scheme. К счастью, лишь немногие из оставшихся синтаксических форм неприменно должны быть понимаемы
    Scheme программистом. Они называются /основными синтаксическими формами/. Остальные синтаксические формы это
    синтаксические выражения, преимущественное, выраженные в терминах основных синтаксических форм. Мы обсудим
    оставшиеся синтаксические формы и некоторые синтаксические выражение ниже в этой главе. Секция 3.1 подытоживает
    обзор основных синтаксических форм и даёт введение в механизм расширения синтаксиса.

    Прежде чем мы перейдём к новым синтаксическим формам и процедурам, будет не лишним сказать пару слов о вычислении
    применения процедур. Во-первых, описанный выше процесс слишком строг, поскольку он требует вычисления подвыражений
    слева направо, это значит, что значение ~procedure~ будет вычислено до вычисления ~arg1~, ~arg1~ до ~arg2~ и
    т.д. Это вовсе не обязательно. /Вычислитель/ Scheme свободен вычислять выражения в любом порядке - слева направо,
    справо налево, или в любой другой последовательности. На деле, подвыражения могут вычисляться в различном порядке в
    различных случаях, даже в рамках одной и той же реализации.

    Во-вторых ~procedure~ вычисляется таким же образом, как и ~arg1 ... argN~. Хотя процедура часто является переменной,
    которая указывает на конкретную процедуру, это не обязательно. Упражнение 2.2.3 предложит Вам определить значение
    выражения ~((car (list + - * /)) 2 3)~. Здесь процедура это ~(car (list + - * /))~. Значение ~(car (list + - * /))~
    это процедура сложения, как если бы была просто записана переменная +.

**** Exercise 2.3.1

     Опишите шаги, необходимые для вычисления выражения ниже:

#+begin_src scheme
     ((car (cdr (list + - * /))) 17 5)
#+end_src

*** Переменые и ~let~ выражения

    Пусть ~expr~ это Scheme выражение, содержащее переменную ~var~. Допустим также, что нам хотелось бы, чтобы
    переменная ~var~ содержала бы значение ~val~, когда мы вычисляем значение ~expr~. Например, мы хотим, чтобы ~x~ имел
    значение ~2~, когда вычисляется выражение ~(+ x 3)~. Или, мы хотим, чтобы ~y~ имел значение ~3~, при вычислении
    выражения ~(+ 2 y)~. Примеры ниже показывают, как добиться такого поведения при помощи синтаксической формы ~let~:

#+begin_src scheme
    (let ((x 2))
      (+ x 3)) → 5

    (let ((y 3))
      (+ 2 y)) → 5

    (let ((x 2) (y 3))
      (+ x y)) → 5
#+end_src

    Синтаксическая форма ~let~ включает в себя список пар /переменная->выражение/, а так же список выражений,
    использующих эти переменные, называемый телом (/body/) ~let~. В общем виде выражение ~let~ имеет следующую форму:

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    Таким образом, с помощью ~let~, мы говорим, что переменные связываются со своими значениями, и далее мы можем
    ссылаться на них в теле выражения.

    ~let~ выражения применяются очень часто и служат средством упрощения выражений, которые содержат несколько
    идентичных подвыражений. Вынесение этого подвыражения в секцию связывания переменных гарантирует, что выражение
    будет вычислено лишь единожды.

#+begin_src scheme
    (+ (* 4 4) (* 4 4)) → 32

    (let ((a (* 4 4))) (+ a a)) → 32
#+end_src

    В секции связывания переменных часто вместо круглых скобок применяют квадратные, чтобы визуально отделить эту
    область от остального тела:

#+begin_src scheme
    (let ([list1 '(a b c)] [list2 '(d e f)])
      (cons (cons (car list1)
                  (car list2))
            (cons (car (cdr list1))
                  (car (cdr list2))))) → ((a . d) b . e)
#+end_src

    Scheme интерпретирует формы, заключённые в квадратные скобки так, как будто они заключены в круглые скобки, но
    нельзя их смешивать - открывающей круглой скобке должна соответствовать закрывающая круглая скобка, а открывающей
    квадратной - квадратная. Мы используем квадратные скобки для ~let~ (и как вы скоро увидите, так же ещё для некоторых
    стандартных синтаксических форм), чтобы улучшить читаемость кода, особенно когда мы могли бы иметь две или более
    последовательные открывающие круглые скобки.

    Поскольку, при применении процедуры, вычисление выражения, стоящего в первой позиции, происходит таким же образом,
    как и любого другого выражения, здесь так же может быть использована /let-связанная/ переменная:

#+begin_src scheme
    (let ([f +])
      (f 2 3)) → 5

    (let ([f +] [x 2])
      (f x 3)) → 5

    (let ([f +] [x 2] [y 3])
      (f x y)) → 5
#+end_src

    Переменные, связанные с помощью ~let~ видны только в пределах /тела/:

#+begin_src scheme
    (let ([+ *])
      (+ 2 3)) → 6

    (+ 2 3) → 5
#+end_src

    И это очень хорошо, что оно работает именно так, потому что мы не хотели бы, чтобы значение + было методом умножения
    всюду.

    Так же выражения ~let~ могут быть вложенными:

#+begin_src scheme
    (let ([a 4] [b -3])
      (let ([a-squared (* a a)]
            [b-squared (* b b)])
        (+ a-squared b-squared))) → 25
#+end_src

    Когда во вложенном ~let~ выражении производят связывание той же переменной, что и во внешнем, только связывание,
    выполненное последним, на более глубоком уровне, считается действующим в пределах тела внутреннего ~let~-выражения:

#+begin_src scheme
    (let ([x 1])
      (let ([x (+ x 1)])
        (+ x x))) → 4
#+end_src

    Здесь внешнее ~let~ выражение связывает ~x~ и 1 в пределах своего тела, место которого занимает второе ~let~
    выражение. Внутреннее ~let~ выражение связывает ~x~ со значением ~(+ x 1)~ в рамках своего тела, которое
    представлено выражением ~(+ x x)~. Каково значение выражения ~(+ x 1)~? Поскольку ~(+ x 1)~ появляется в теле
    внешнего ~let~, но не в теле внутреннего ~let~, значение ~x~ должно быть 1, и, следовательно, значение ~(+ x 1)~
    равно 2. А что насчёт ~(+ x x)~? Оно появляется в теле обоих выражений ~let~. Видно только внутреннее связывание для
    ~x~, поэтому ~x~ равно 2, а ~(+ x x)~ равно 4.

    Про внутреннее связывание для ~x~ говорят, что оно /затеняет/ внешнее связывание. let-связанная переменная видна
    везде внутри тела ее выражения ~let~, кроме случаев, когда она затенена. Область, в которой действует связывание
    переменной, называется /областью видимости/ (scope). Область видимости первого ~x~ в приведенном выше примере - это
    тело внешнего выражения ~let~ минус тело внутреннего выражения ~let~, где он затеняется вторым ~x~. Эта форма
    определения области видимости называется /лексической областью видимости/, поскольку область видимости каждого
    связывания может быть определена путем простого текстового анализа программы.

    Затенения можно избежать, дав различные имена переменным. Выражение выше может быть переписано так, что во
    внутреннем ~let~ выражении будет производиться связывание значения с именем ~new-x~:

#+begin_src scheme
    (let ([x 1])
      (let ([new-x (+ x 1)])
        (+ new-x new-x))) → 4
#+end_src

    Хотя выбор разных имен иногда может предотвратить путаницу, затенение может помочь предотвратить случайное
    использование "старого" значения. Например, в исходной версии предыдущего примера мы не могли бы ошибочно сослаться
    на внешний ~x~ в теле внутреннего ~let~.

**** Упражнение 2.4.1

     Перепишите выражения ниже, используя ~let~, чтобы вынести общие подвыражения и улучшить структуру кода. Не
     используйте математических упрощений.

     + ~(+ (- (* 3 a) b) (+ (* 3 a) b))~
     + ~(cons (car (list a b c)) (cdr (list a b c)))~

**** Упражнение 2.4.2

     Определите значение вычисления следующего выражение. Поясните, как вы получили это значение.

#+begin_src scheme
     (let ([x 9])
       (* x
          (let ([x (/ x 3)])
            (+ x x))))
#+end_src

**** Упражнение 2.4.3

     Перепишите следующие выражения, чтобы дать уникальные имена каждой отдельной let-связанной переменной, чтобы ни
     одна из переменных не была затенена. Убедитесь, что значение вашего выражения совпадает со значением исходного
     выражения.

     +
#+begin_src scheme
     (let ([x 'a] [y 'b])
       (list (let ([x 'c]) (cons x y))
             (let ([y 'd]) (cons x y))))
#+end_src

     +
#+begin_src scheme
     (let ([x '((a b) c)])
       (cons (let ([x (cdr x)])
               (car x))
             (let ([x (car x)])
               (cons (let ([x (cdr x)])
                       (car x))
                     (cons (let ([x (car x)])
                             x)
                           (cdr x))))))
#+end_src

*** Лямбда выражения

    В выражении ~(let ([x (* 3 4)]) (+ x x))~ переменная ~x~ связана со значением ~(* 3 4)~. Что будет, если мы захотим
    получить значение выражения ~(+ x x)~ где  ~x~ связана со значением ~(/ 99 11)~? А где ~x~ связана со значением
    ~(- 2 7)~? В каждом случае нам потребуется новое ~let~-выражение. И чем сложнее становится тело ~let~, тем менее
    удобно становится повторять его.

    Вместо этого мы можем использовать синтаксическую форму ~lambda~ для создания новой процедуры, которая имеет ~x~ в
    качестве входного параметра и имеет такое же тело, как у ~let~-выражения.

#+begin_src scheme
    (lambda (x) (+ x x)) → #<procedure>
#+end_src

    Общая форма лямбда-выражения:

#+begin_src scheme
    (lambda (var ...) body1 body2 ...)
#+end_src

    Переменные ~var ...~ это формальные параметры процедуры, а последовательность выражений ~body1 body2 ...~ это её
    тело. (В действительности, по-настоящему общая форма это нечто более обобщённое, чем это, как вы увидите позже).

    Процедура - это такой же объект, как число, строка, символ или пара. У неё нет какого-либо вменяемого печатного
    представления, по крайней мере в Scheme, тем не менее, в этой книге мы будем использовать обозначение ~#<procedure>~
    чтобы показать, что значение выражения это процедура.

    Простейшая операция, которую можно совершить над процедурой - это применить её к одному или более значений:

#+begin_src scheme
    ((lambda (x) (+ x x)) (* 3 4)) → 24
#+end_src

    Здесь нет никакого отличия от какого-то другого способа применения процедуры. Процедура это результат вычисления
    выражения ~(lambda (x) (+ x x))~ и единственный агрумент это значение выражения ~(* 3 4)~, или 12. Значения
    аргументов, или параметры, связываются с формальными параметрами в пределах тела лямбда-выражения таким же образом,
    как и let-связывание связывает переменные с их значениями. В этом случае, ~x~ связывается с 12, а значение ~(+ x x)~
    равно 24. Таким образом, результат применения процедуры к значению 12 равен 24.

    Посколько процедуры это объекты, мы можем установить процедуру как значение переменной и использовать эту процедуру
    в дальнейшем не раз.

#+begin_src scheme
    (let ([double (lambda (x) (+ x x))])
      (list (double (* 3 4))
            (double (/ 99 11))
            (double (- 2 7)))) → (24 18 -10)
#+end_src

    Здесь мы установили связывание между ~double~ и процедурой, а затем использовали эту процедуру, чтобы удвоить три
    различных значения.

    Наша процедура ожидает, что её фактическим параметром будет число, поскольку он передаётся фактическим параметром в
    ~+~. В общем же случае, фактическим параметром может быть объект любого сорта. Рассмотрим, для примера, простейшую
    процедуру, которая использует ~cons~ вместо ~+~:

#+begin_src scheme
    (let ([double-cons (lambda (x) (cons x x))])
      (double-cons 'a)) → (a . a)
#+end_src

    Отмечая сходство между ~double~ и ~double-cons~, вы не должны удивляться, узнав, что они могут быть объединены в
    одну процедуру путем добавления дополнительного аргумента.

#+begin_src scheme
    (let ([double-any (lambda (f x) (f x x))])
      (list (double-any + 13)
            (double-any cons 'a))) → (26 (a . a))
#+end_src

    Здесь демонстрируется, что процедуры могут принимать более одного аргумента и эти аргументы, передаваемые в
    процедуру, сами могу быть процедурами.

    Как и с ~let~-выражениями, лямбда-выражения становятся несколько интереснее, когда они вложены в другие
    лямбда- или let-выражения.

#+begin_src scheme
    (let ([x 'a])
      (let ([f (lambda (y) (list x y))])
        (f 'b))) → (a b)
#+end_src

    Вхождение ~x~ в лямбда-выражение ссылается на ~x~ за пределами лямбды, который был связан внешним
    let-выражением. Говорят, что переменная ~x~ в лямбда-выражении свободна или является свободной переменной
    лямбда-выражения. Переменная ~y~ не является свободной переменной в лямбда-выражении, поскольку она была связана в
    лямбда-выражении. Переменная, которая становится свободной в лямбда-выражении должна уже быть связана, например,
    окружающим лямбда- или let-выражением, кроме случая, когда переменная связывается вне выражения, который мы обсудим
    в следующем разделе.

    Что происходит, когда процедура применяется где-то вне области привязок для переменных, которые встречаются в
    процедуре свободно, как в следующем выражении?

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (f 'i 'am)) → (sam i am)
#+end_src

    Ответ заключается в том, что те же привязки, которые действовали при создании процедуры, снова применяются при
    применении процедуры. Это верно, даже если другая привязка для ~x~ видна там, где применяется процедура.

#+begin_src scheme
    (let ([f (let ([x 'sam])
               (lambda (y z) (list x y z)))])
      (let ([x 'not-sam])
        (f 'i 'am))) → (sam i am)
#+end_src

    В обоих случаях, значение ~x~ за пределами процедуры названой ~f~ это ~sam~.

    Примечательно, что let-выражение это ни что иное, как прямое применение лямбда-выражения с целью задать аргументы
    выражения. Например, два выражения ниже эквивалентны:

#+begin_src scheme
    (let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)
#+end_src

    В действительности, let-выражение это синтаксическое выражение, определённое в терминах лямбда-выражения и
    применения процедуры, которые оба являются базовыми синтаксическими формами. В общем случае, любое выражение вида

#+begin_src scheme
    (let ((var expr) ...) body1 body2 ...)
#+end_src

    эквивалентно следующему

#+begin_src scheme
    ((lambda (var ...) body1 body2 ...)
     expr ...)
#+end_src

    В секции 3.1 будут более подробно обсуждаться базовые формы и расширения синтаксиса.

    Как упоминалось выше, общая форма лямбда-выражения несколько сложнее, чем форма, рассмотренная нами ранее, в том,
    что формальное объявление параметра, ~(var ...)~, не обязано быть правильным списом, или даже списком
    вообще. Формальное объявление параметра может быть любой из трёх форм ниже:

    + правильный список переменных ~(var1 ... varN)~, как мы видели только что
    + одна переменная ~varR~
    + неправильный список переменных, ~(var1 ... varN . varR)~.

    В первом случае должно быть передано ровно ~N~ параметров, и каждая переменная связана с соответствующим
    переданным параметром. Во втором, любое количество переданных параметров валидно, все переданные параметры
    собираются в один список и единственная переменная связывается с этим списком. Третий случай это гибрид первых
    двух. По меньшей мере ~N~ параметров должно быть передано. Переменные ~var1 ... varN~ связываются с соответствующими
    переданными параметрами, а переменная ~varR~ связывается со списком, содержащим остальные переданные параметры. Во
    втором и третьем случаях, параметр ~varR~ иногда обозначают как "rest" (англ. остальные), потому что он содержит
    оставшиеся переданные параметры, помимо тех, которые индивидуально названы.

    Давайте рассмотрим несколько примеров, чтобы прояснить более общий синтаксис лямбда-выражений:

#+begin_src scheme
    (let ([f (lambda x x)])
      (f 1 2 3 4)) → (1 2 3 4)

    (let ([f (lambda x x)])
      (f)) → ()

    (let ([g (lambda (x . y) (list x y))])
      (g 1 2 3 4)) → (1 (2 3 4))

    (let ([h (lambda (x y . z) (list x y z))])
      (h 'a 'b 'c 'd)) → (a b (c d))
#+end_src

    В первых двух примерах, процедура, названная ~f~ принимает любое количество аргументов. Эти аргументы автоматически
    групируются в список, с которым связывается переменная ~x~, значение ~f~ это этот список. В первом примере,
    аргументы 1, 2, 3, 4, так что ответ ~(1 2 3 4)~. Во втором примере нет аргументов, так что ответ это пустой список
    ~()~. Значение процедуры названой ~g~, в третьем примере, это список, чей первый элемент это первый аргумент, а
    второй элемент это список, содержащий остальные аргументы. Процедура под именем ~h~ похожа, но здесь второй аргумент
    отделён. Если процедура ~f~ принимает любое количество агрументов, ~g~ должен иметь по меньшей мере один, то ~h~
    должен получать не меньше двух аргументов.

**** Упражнение 2.5.1

     Определите значения выражений ниже.

     +
#+begin_src scheme
     (let ([f (lambda (x) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda x x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) x)])
       (f 'a))
#+end_src

     +
#+begin_src scheme
     (let ([f (lambda (x . y) y)])
       (f 'a))
#+end_src

**** Упраженение 2.5.2

     Как может выглядеть определение примитивной процедуры ~list~?

**** Упражнение 2.5.3

     Найдите все свободные переменные в лямбда-выражениях ниже. Переменные, указывающие на примитивные процедуры, такие
     как ~+~ и ~cons~ не в счёт.

     +
#+begin_src scheme
     (lambda (f x) (f x))
#+end_src

     +
#+begin_src scheme
     (lambda (x) (+ x x))
#+end_src

     +
#+begin_src scheme
     (lambda (x y) (f x y))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (cons x (f x y)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([z (cons x y)])
         (x y z)))
#+end_src

     +
#+begin_src scheme
     (lambda (x)
       (let ([y (cons x y)])
         (x y z)))
#+end_src

*** Определения верхнего уровня

    Переменные, связанные с помощью ~let~ и ~lambda~ не видны за пределами тел этих выражений. Допустим, у вас есть
    некий объект или процедура, который должен быть доступи отовсюду, например, как ~+~ или ~cons~. Вам нужно
    определение верхнего уровня, которое может быть установлено с помощью ~define~. Определения верхнего уровня,
    поддерживаемые большенством интерактивных систем Scheme, доступны в любом введённом вами выражении, за исключением
    случаев, когда оно затенено другим локальным связыванием.

    Давайте установим определение верхнего уровня для процедуры ~double-any~ из последней секции:

#+begin_src scheme
    (define double-any
      (lambda (f x)
        (f x x)))
#+end_src

    Теперь переменная ~double-any~ имеет тот же статус, что и ~cons~ или любая другая примитивная процедура. Мы можем
    использовать ~double-any~ так, как если бы это была примитивная процедура.

#+begin_src scheme
    (double-any + 10) → 20
    (double-any cons 'a) → (a . a)
#+end_src

    Определение верхнего уровня может быть установлено для любого объекта, не только процедур.

#+begin_src scheme
    (define sandwich "peanut-butter-and-jelly")

    sandwich → "peanut-butter-and-jelly"
#+end_src

    Однако чаще всего определения верхнего уровня используются для процедур.

    Как было отмечено выше, определения верхнего уровня могут быть затенены связываниями в ~let~ или ~lambda~.

#+begin_src scheme
    (define xyz '(x y z))
    (let ([xyz '(z y x)])
      xyz) → (z y x)
#+end_src

    Переменные, объявленные на верхнем уровне действуют почти так-же, как если бы они были связаны при помощи
    let-выражения, охватывающего весь ваш код.

    Учитывая только простые инструменты, о которых вы читали до этого момента, уже можно определить некоторые
    примитивные процедуры, предоставляемые Scheme и описанные далее в этой книге. Если вы прошли упражнения из прошлой
    главы, вы должны уже знать, как определить функцию ~list~.

#+begin_src scheme
    (define list (lambda x x))
#+end_src

    Также, Scheme предоставляет сокращения ~cadr~ и ~cddr~ для сочетаний ~car~ и ~cdr~ с ~cdr~. Так, ~(cadr list)~
    равнозначно ~(car (cdr list))~, а ~(cddr list)~ это ~(cdr (cdr list))~. Эти функции легко определяются, как описано
    ниже.

#+begin_src scheme
    (define cadr
      (lambda (x)
        (car (cdr x))))

    (define cddr
      (lambda (x)
        (cdr (cdr x))))

    (cadr '(a b c)) → b
    (cddr '(a b c)) → (c)
#+end_src

    Любое определение ~(define var expr)~, где ~expr~ это лямбда, может быть записано в сокращённой форме, которая
    скрывает ~lambda~. Явный синтаксис зависит от формата спецификатора формального параметра лямбда-выражения,
    т.е. будь то правильный список переменных, единственная переменная или неправильный список переменных. Определение
    формы

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN)
      e1 e2 ...)
#+end_src

    в то время как

#+begin_src scheme
    (define var0
      (lambda varR
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 . varR)
      e1 e2 ...)
#+end_src

    и

#+begin_src scheme
    (define var0
      (lambda (var1 ... varN . varR)
        e1 e2 ...))
#+end_src

    может быть сокращено до

#+begin_src scheme
    (define (var0 var1 ... varN . varR)
      e1 e2 ...)
#+end_src

    Например, определения ~cadr~ и ~list~ могут быть записаны следующим образом

#+begin_src scheme
    (define (cadr x)
      (car (cdr x)))

    (define (list . x) x)

#+end_src

    В этой книге данный альтернативный синтаксис используется редко. Несмотря на короткую запись, это приводит к
    сокрытию того факта, что процедура не имеет такой тесной связи с переменными или именами, как во многих других
    языках. Этот синтаксис часто называют несколько уничижительно, как «defun» для define, после формы defun,
    введённой языками Lisp, в которой процедуры более тесно связаны с их именами.

    Определения верхнего уровня облегчают нам эксперименты с процедурой в интерактивном режиме, поскольку нам не нужно
    повторно вводить процедуру каждый раз, когда она используется.

    Давайте попробуем определить несколько более сложный вариант ~double-any~, который превращает «обычную» процедуру с
    двумя аргументами в «дублирующую» процедуру с одним аргументом.

#+begin_src scheme
    (define doubler
      (lambda (f)
        (lambda (x) (f x x))))
#+end_src

    ~doubler~ принимает один аргумент, ~f~, который должен быть процедурой, принимающей два аргумента. Процедура,
    возвращаемая ~doubler~ принимает один аргумент, который используется как оба аргумента при применении ~f~. Мы можем
    определить с помощью ~doubler~ процедуры ~double~ и ~double-cons~ из прошлой главы:

#+begin_src scheme
    (define double (doubler +))
    (double 13/2) → 13

    (define double-cons (doubler cons))
    (double-cons 'a) → (a . a)
#+end_src

    Также мы можем определить ~double-any~ с помощью ~doubler~.

#+begin_src scheme
    (define double-any
      (lambda (f x)
        ((doubler f) x)))
#+end_src

    В ~double~ и ~double-cons~, ~f~ преобретает собственное значение т.е. ~+~ или ~cons~, даже если процедуры явно
    применяются вне области действия ~f~.

    Что произойдёт, если вы попробуете использовать пременную, не связанную ~let~ или ~lambda~, а так же не имеющую
    определения на верхнем уровне? Попробуйт использовать переменную ~i-am-not-defined~ чтобы увидеть, что произойдёт.

#+begin_src scheme
    (i-am-not-defined 3)
#+end_src

    Большенство реализаций Scheme выведет сообщение, уведомляющее о том, что произошло исключение из за использования
    несвязанной или неопределённой переменной.

    Однако система не должна жаловаться на появление неопределенной переменной в лямбда-выражении до тех пор, пока не
    будет применена результирующая процедура. Следующее не должно вызывать исключения, хотя мы еще не установили
    определение верхнего уровня для ~proc2~.

#+begin_src scheme
    (define proc1
      (lambda (x y)
        (proc2 y x)))
#+end_src

    Если вы попробуете применить ~proc1~ до определения ~proc2~, вы должны получить сообщение об исключении из за
    неопределённости переменной. Давайте дадим ~proc2~ определение верхнего уровня и опробуем ~proc1~.

#+begin_src scheme
    (define proc2 cons)
    (proc1 'a 'b) → (b . a)
#+end_src

    Когда вы определяете ~proc1~ система принимает ваше обещание определить ~proc2~ и не жалуется до тех пор, пока вы не
    используете ~proc1~, так и не определив ~proc2~. Это позволяет вам определять процедуры в любом удобном для вас
    порядке. Это особенно удобно, когда ты пытаешься организовать файл, полный определений процедур, таким образом,
    чтобы сделать его более читаемым. Это так же нужно, когда две процедуры, определённых на верхнем уровне, зависят
    друг от друга, вы увидите такие примеры далее.

**** Упражнение 2.6.1

     Что произойдёт, если вы наберёте

#+begin_src scheme
     (double-any double-any double-any)
#+end_src

     давая определение ~double-any~ в начале этого раздела?

**** Упражнение 2.6.2

     Более элегантный (а также возможно менее эффективный) способ определения ~cadr~ и ~cddr~, чем данный в этой главе,
     это определить процедуру, которая объединяет две процедуры, чтобы создать третью. Создайте процедуру ~compose~,
     вида ~(compose p1 p2)~, которая будет создавать композицию процедур ~p1~ и ~p2~ (предполагается, что они ожидают по
     одному аргументу). Применение этой процедуры, ~(compose p1 p2)~, должно возвращать новую процедуру от одного
     аргумента, которая применяет ~p1~ к результату применения ~p2~ к аргументу. Используйте эту процедуру, чтобы
     определить ~cadr~ и ~cddr~.

**** Упражнение 2.6.3

     Scheme также предоставляет процедуры ~caar~, ~cdar~, ~caaar~, ~caadr~ и т.д., все компинации до четырёх /a/
     (обозначающих ~car~) или /d/ (обозначающих ~cdr~) между /c/ и /r/ (см. Главу 6.3). Определите каждую из них с
     помощью процедуры ~compose~ из предыдущего упражнения.

*** Условные выражения

    До сих пор мы рассматривали выражения, которые выполняют свою задачу безоговорочно. Предположим, что мы хотим
    написать процедуру ~abs~. Если аргумент ~x~ отрицательный, ~abs~ возвращает ~-x~; в противном случае возвращает
    ~х~. Самый простой способ написать ~abs~ - это определить, является ли аргумент отрицательным и, если это так,
    инвертировать его, используя синтаксическую форму ~if~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (< n 0)
            (- 0 n)
            n)))

    (abs 77) → 77
    (abs -77) → 77
#+end_src

    Выражение ~if~ имеет форму ~(if тест следствие альтернатива)~, где ~следствие~ это выражение, которое будет
    вычислено, если ~тест~ будет истиной (true), а ~альтернатива~, соответственно, выражение, которое будет выполнено в
    обратном случае т.е. если ~тест~ будет ложью (false). В выражении выше, тест это ~(< n 0)~, следствие ~(- 0 n)~, а
    альтернатива это ~n~.

    Процедура ~abs~ может быть написана множеством других способов. Любое из следующего является корректным определением
    ~abs~.

#+begin_src scheme
    (define abs
      (lambda (n)
        (if (>= n 0)
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (not (< n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (or (> n 0) (= n 0))
            n
            (- 0 n))))

    (define abs
      (lambda (n)
        (if (= n 0)
            0
            (if (< n 0)
                (- 0 n)
                n))))

    (define abs
      (lambda (n)
        ((if (>= n 0) + -)
         0
         n)))
#+end_src

    Первое из этих определений спрашивает, является ли ~n~ больше или равно нулю, инвертируя тест. Второе спрашивает, если
    ~n~ не меньше нуля, используя процедуру ~not~ с ~<~. Третье спрашивает, является ли ~n~ больше нуля или ~n~ равно нулю,
    используя синтаксическую форму ~or~. Четвертое рассматривает ноль отдельно, хотя в этом нет никакой пользы. Пятое
    несколько хитрее; ~n~ либо прибавляется, либо вычитается из нуля, в зависимости от того, больше или равно ~n~ чем
    ноль.

    Почему ~if~ это синтаксическая форма, а не процедура? Чтобы ответить на этот вопрос, давайте вернемся к определению
    обратной величины из первого раздела этой главы.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (= n 0)
            "oops!"
            (/ 1 n))))
#+end_src

    Второй аргумент процедуры деления не должен быть нулевым, поскольку результат математически не определен. Наше
    определение обратной величины позволяет избежать этой проблемы путем проверки на ноль перед делением. Если бы ~if~
    была процедурой, её аргументы (включая ~(/ 1 n)~) были бы вычислены прежде, чем у нее была возможность выбора между
    следствием и альтернативой. Как и цитирование (~quote~), которое не вычисляет своё единственное подвыражение, ~if~
    не вычисляет все его подвыражения и поэтому не может быть процедурой.

    Синтаксическая форма ~or~ действует аналогично ~if~. Общая форма выражения ~or~ является ~(or expr ...)~. Если нет
    подвыражений, то есть выражение просто ~(or)~, значение ложно. В противном случае каждое выражение вычисляется по
    очереди, пока либо (а) одно из выражений не станет истинным, либо (б) больше не останется выражений. В случае (а)
    значение истинно; в случае (б) значение ложно.

    Чтобы быть более точным, в случае (a) значение выражения ~or~ является значением последнего вычисленного
    подвыражения. Это уточнение необходимо, потому что существует много возможных истинных значений. Обычно результатом
    тестового выражения является один из двух объектов ~#t~ для обозначения истины или ~#f~ для лжи.

#+begin_src scheme
    (< -1 0) → #t
    (> -1 0) → #f
#+end_src

    Каждый объект Scheme, любой, является либо истиной либо ложью, для условных выражений, но не для процедур. Только
    ~#f~ считается ложью, любой другой объект считается истиной.

#+begin_src scheme
    (if #t 'true 'false) → true
    (if #f 'true 'false) → false
    (if '() 'true 'false) → true
    (if 1 'true 'false) → true
    (if '(a b c) 'true 'false) → true

    (not #t) → #f
    (not "false") → #f
    (not #f) → #t

    (or) → #f
    (or #f) → #f
    (or #f #t) → #t
    (or #f 'a #f) → a
#+end_src

    Синтаксическая форма ~and~ похожа на ~or~ или, но выражение ~and~ является истинным, если все его подвыражения
    истинны, и ложным в противном случае. В случае, когда нет никаких подвыражений, то есть выражение просто ~(and)~,
    значение равно ~true~. В противном случае подвыражения вычисляются по очереди до тех пор, пока либо не останется
    подвыражений, либо значение подвыражения будет ложным. Результатом выполнения ~and~ является значение последнего
    вычисленного подвыражения.

    Используя ~and~ мы можем определить ~reciprocal~ несколько иначе:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (and (not (= n 0))
             (/ 1 n))))

    (reciprocal 3) → 1/3
    (reciprocal 0.5) → 2.0
    (reciprocal 0) → #f
#+end_src

    В этой версии значение равно ~#f~, если ~n~ равно нулю, и ~1/n~ в противном случае.

    Процедуры ~=~, ~<~, ~>~, ~<=~, и ~>=~ называются предикатами. Предикаты это процедуры, которые отвечают на
    специальный вопрос о своём аргументе и возвращают одно из двух значений, ~#t~ или ~#f~. Имена большинства предикатов
    заканчиваются знаком вопроса (?). Простейшие численные процедуры, перечисленные выше, исключение из правил. Конечно
    же не все предикаты требуют в качестве аргументов числа. Предикат ~null?~ возвращает истину, если его аргумент
    пустой список ~()~, иначе ложь.

#+begin_src scheme
    (null? '()) → #t
    (null? 'abc) → #f
    (null? '(x y z)) → #f
    (null? (cdddr '(x y z))) → #t
#+end_src

    Процедуре ~cdr~ нельзя передавать ничего, кроме пары, иначе это приведёт к исключению. В Common Lisp, однако,
    результат ~(cdr '())~ определен как ~()~. Следующая процедура, ~lisp-cdr~, определена с использованием ~null?~,
    чтобы вернуть ~()~, если её аргумент был ~()~.

#+begin_src scheme
    (define lisp-cdr
      (lambda (x)
        (if (null? x)
            '()
            (cdr x))))

    (lisp-cdr '(a b c)) → (b c)
    (lisp-cdr '(c)) → ()
    (lisp-cdr '()) → ()
#+end_src

    Еще один полезный предикат - ~eqv?~, который ожидает два аргумента. Если два аргумента эквивалентны, ~eqv?~
    возвращает истину. Иначе ~eqv?~ возвращает ложь.

#+begin_src scheme
    (eqv? 'a 'a) → #t
    (eqv? 'a 'b) → #f
    (eqv? #f #f) → #t
    (eqv? #t #t) → #t
    (eqv? #f #t) → #f
    (eqv? 3 3) → #t
    (eqv? 3 2) → #f
    (let ([x "Hi Mom!"])
      (eqv? x x)) → #t
    (let ([x (cons 'a 'b)])
      (eqv? x x)) → #t
    (eqv? (cons 'a 'b) (cons 'a 'b)) → #f
#+end_src

    Как видите, ~eqv?~ возвращает истину, если аргументы - это один и тот же символ, логическое значение, число, пара
    или строка. Две пары не считаются эквивалентными с точки зрения ~eqv?~, если они были созданы различными вызовами
    ~cons~, даже если их содержимое одинаково. Подробные правила эквивалентности для ~eqv?~ приведены в разделе 6.2.

    Scheme также предоставляет набор предикатов типа, которые возвращают истину или ложь в зависимости от типа объекта,
    например, ~pair?~, ~symbol?~, ~number?~, и ~string?~. Предикат ~pair?~, например, возвращает истину только в случае,
    если его аргумент - пара.

#+begin_src scheme
    (pair? '(a . c)) → #t
    (pair? '(a b c)) → #t
    (pair? '()) → #f
    (pair? 'abc) → #f
    (pair? "Hi Mom!") → #f
    (pair? 1234567890) → #f
#+end_src

    Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For
    example, the following version of reciprocal checks first to see that its argument is a number before testing against
    zero or performing the division.

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            "oops!")))

    (reciprocal 2/3) → 3/2
    (reciprocal 'a) → "oops!"
#+end_src

    Между прочим, код, использующий ~reciprocal~ должен проверять, что было возвращено процедурой - число или
    строка. Чтобы освободить пользователя процедуры от этого обязательства, обычно предпочтительно сообщить об ошибке,
    используя ~assertion-violation~ (науршение соглашения) следующим образом:

#+begin_src scheme
    (define reciprocal
      (lambda (n)
        (if (and (number? n) (not (= n 0)))
            (/ 1 n)
            (assertion-violation 'reciprocal
              "improper argument"
              n))))

    (reciprocal .25) → 4.0
    (reciprocal 0) → exception in reciprocal: improper argument 0
    (reciprocal 'a) → exception in reciprocal: improper argument a
#+end_src

    Первый аргумент ~assertion-violation~ это символом, показывающий, откуда исходит сообщение, второй является строкой,
    описывающей ошибку, а третий и последующие аргументы являются «раздражителями», которые будут включены в сообщение
    об ошибке.

    Давайте рассмотрим ещё одно условное выражение, ~cond~, которое часто оказывается более полезно, чем ~if~. ~cond~
    похож на ~if~ с той разницей, что он позволяет указывать множество пар тест -> выражение. Рассмотрим следующее
    определение процедуры ~sign~, которая возвращает -1, если ей передали негативный аргумент, +1 если позитивный, иначе
    ноль.

#+begin_src scheme
    (define sign
      (lambda (n)
        (if (< n 0)
            -1
            (if (> n 0)
                +1
                0))))

    (sign -88.3) → -1
    (sign 0) → 0
    (sign 333333333333) → 1
    (* (sign -88.3) (abs -88.3)) → -88.3
#+end_src

    Эти два ~if~ выражения могут быть заменены одним ~cond~ следующим образом:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [else 0])))
#+end_src

    Выражение ~cond~ обычно имеет следующую форму:

#+begin_src scheme
    (cond (test expr) ... (else expr))
#+end_src

    Конечно же клауза ~else~ может быть опущена. Это следует делать только в том случае, если невозможно, чтобы все
    тесты провалились, как в новой версии ~sign~ ниже:

#+begin_src scheme
    (define sign
      (lambda (n)
        (cond
          [(< n 0) -1]
          [(> n 0) +1]
          [(= n 0) 0])))
#+end_src

    В этом определении ~sign~ не зависит от порядка в котором тесты будут проводиться, потому что только один из тестов
    может быть истиной, для любого ~n~. Следующая процедура рассчитывает налог для указанного дохода в прогрессивной
    налоговой системе с контрольными точками для 10000, 20000, 30000 долларов.

#+begin_src scheme
    (define income-tax
      (lambda (income)
        (cond
          [(<= income 10000) (* income .05)]
          [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
          [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
          [else (+ (* (- income 30000) .21) 2600.00)])))

    (income-tax 5000) → 250.0
    (income-tax 15000) → 900.0
    (income-tax 25000) → 1950.0
    (income-tax 50000) → 6800.0
#+end_src

    В этом примере важен порядок выполнения тестов - слева направо (сверху вниз).

**** Упражнение 2.7.1

     Определите предикат ~atom?~, который возвращает истину, если его аргумент не пара и ложь в обратном случае.

**** Упражнение 2.7.2

     Процедура ~length~ возвращает длину своего аргумента, который должен быть списком. Например, ~(length '(a b c))~
     это 3. Используя ~length~, определите процедуру ~shorter~, возвращающую кратчайший из двух списков в
     аргументах. Пусть она возвращает первый список, если длины равны.

#+begin_src scheme
     (shorter '(a b) '(c d e)) → (a b)
     (shorter '(a b) '(c d)) → (a b)
     (shorter '(a b) '(c)) → (c)
#+end_src

*** Простая рекурсия

    Мы видели, кака можно контролировать выполнение с помощью ~if~, ~or~ и ~cond~. Мы также можем выполнить выражение
    более одного раза, создав процедуру, содержащую это выражение и вызвав её несколько раз. Но что, если нам необходимо
    повторять некоторое выражение, например, для каждого элемента в списке или для каждого числа от одного до десяти? Мы
    можем сделать это с помощью рекурсии. В основе рекурсии лежит простая идея: вызов процедуры из самой этой
    процедуры. Освоение рекурсии может показаться сложным, на первых порах, однако освоившись с ней, вы получаете в своё
    распоряжение мощную силу, намного превосходящую обычные циклы.

    Рекурсивная процедура это процедура, вызывающая саму себя. Ниже представлен, возможно, самый простой вариант
    рекурсивной процедуры, которую мы назвали ~goodbye~.

#+begin_src scheme
    (define goodbye
      (lambda ()
        (goodbye)))

    (goodbye) →
#+end_src

    Эта процедура не принимает аргументов и просто немедленно вызывает саму себя. Здесь нет значения после → потому что
    ~goodbye~ никогда не вернёт управление (и результат).

    Обычно, чтобы получить практическую пользу от рекурсивной процедуры мы должны предусмотреть некое условие остановки
    рекурсии. Большинство рекурсивных процедур должно содержать по меньшей мере два базовых элемента - /базовый вариант/
    и /шаг рекурсии/. Базовый вариант останавливает процедуру, возвращая значение в случае получения некого базового
    аргумента. Шаг рекурсии описывает результат в терминах вызова этой же процедуры, примененной к новому аргументу. Чтобы
    завершить рекурсию, этот новый аргумент должен быть ближе к базовому случаю, чем предыдущий.

    Давайте рассмотрим проблему поиска длины правильного списка рекурсивным способом. Нам нужны базовый случай и шаг
    рекурсии. Логичным базовым аргументом при рекурсии по списку почти всегда будет пустой список. Длина пустого списка
    равна нулю, так что базовый случай должен возвращать ноль, если его аргументом будет пустой список. Чтобы
    последовательно приближаться к пустому списку, естественнно будет на  шаге рекурсии применять ~cdr~ к
    аргументу. Непустой список на один элемент длинее, чем его ~cdr~, так что шаг рекурсии дает значение на единицу
    больше длины ~cdr~ списка.

#+begin_src scheme
    (define length
      (lambda (ls)
        (if (null? ls)
            0
            (+ (length (cdr ls)) 1))))

    (length '()) → 0
    (length '(a)) → 1
    (length '(a b)) → 2
#+end_src

    Выражение ~if~ проверяет не пуст ли список. Если это так, результат - ноль. Это базовый случай. Если нет, результат
    будет на единицу больше, чем длина ~cdr~ этого списка. Это шаг рекурсии.

    Многие реализации Scheme позволяют отслеживать выполнение процедуры, чтобы увидеть, как она работает. Например, в
    Chez Scheme одним из способов трассировки процедуры является ввод ~(trace name)~, где ~name~ - это имя процедуры,
    которую вы определили на верхнем уровне. Если вы трассируете ~length~, как определено выше, и передадите ей аргумент
    ~'(a b c d)~, вы должны увидеть что-то вроде этого:

#+BEGIN_EXAMPLE
    |(length (a b c d))
    | (length (b c d))
    | |(length (c d))
    | | (length (d))
    | | |(length ())
    | | |0
    | | 1
    | |2
    | 3
    |4
#+END_EXAMPLE

    Отступами обозначен уровень глубины рекурсии; вертикальные линии визуально соотносят вызовы процедур с их
    результатами. Обратите внимание, что с каждым вызовом ~length~ список становится меньше, пока окончательно не станет
    ~()~. Результат для ~()~ известен - это 0, и каждый уровень глубины добавляет к этому результату единицу.

    Давайте напишем процедуру ~list-copy~, возвращающую копию своего аргумента, который должен быть списком. Именно
    новый список из заново спареных элементов (но не старых пар) старого списка. Создание копии может быть полезным,
    если исходный список или копия могут быть модифицированы с помощью ~set-car!~ или ~set-cdr!~, о которые мы поговорим
    позже.

#+begin_src scheme
    (list-copy '()) → ()
    (list-copy '(a b c)) → (a b c)
#+end_src

    Посмотрите, можете ли вы определить ~list-copy~, прежде чем изучать определение ниже.

#+begin_src scheme
    (define list-copy
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (car ls)
                  (list-copy (cdr ls))))))
#+end_src

    Определение ~list-copy~ аналогично определению ~length~. Тест в базовом случае такой же, ~(null? ls)~.  Значение в
    базовом случае равно ~()~, а не 0, потому что мы строим список, а не число. Рекурсивный вызов такой же, но вместо
    добавления единицы, ~list-copy~ спаривает ~car~ списка-аргумента с результатом рекурсивного вызова.

    Нет причин, по которым не может быть более одного базового случая. Процедура ~memv~ принимает два аргумента, объект
    и список. Возвращает первый подсписок (хвост списка), чей ~car~ равен объекту, или ~#f~, если объект не найден в
    списке. Значение ~memv~ может использоваться как список или как значение истинности в условном выражении.

#+begin_src scheme
    (define memv
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eqv? (car ls) x) ls]
          [else (memv x (cdr ls))])))

    (memv 'a '(a b b d)) → (a b b d)
    (memv 'b '(a b b d)) → (b b d)
    (memv 'c '(a b b d)) → #f
    (memv 'd '(a b b d)) → (d)
    (if (memv 'b '(a b b d))
        "yes"
        "no") → "yes"
#+end_src

    Здесь есть два условия для проверки, так что используем ~cond~. Первое условие ~cond~ проверяет базовое
    значение ~()~; ни один объект не является членом ~()~, поэтому ответ ~#f~. Вторая клауза проверяет, является ли
    ~car~ списка искомым объектом, и в этом случае возвращается список, являющийся первым хвостом, ~car~ которого
    содержит искомый объект. Шаг рекурсии просто продолжает обход дальше по списку.

    Также может быть более одного случая рекурсии. Как и ~memv~, процедура ~remv~, определенная ниже, принимает два
    аргумента, объект и список. Возвращает новый список, в котором все вхождения объекта удалены из списка.

#+begin_src scheme
    (define remv
      (lambda (x ls)
        (cond
          [(null? ls) '()]
          [(eqv? (car ls) x) (remv x (cdr ls))]
          [else (cons (car ls) (remv x (cdr ls)))])))

    (remv 'a '(a b b d)) → (b b d)
    (remv 'b '(a b b d)) → (a d)
    (remv 'c '(a b b d)) → (a b b d)
    (remv 'd '(a b b d)) → (a b b)
#+end_src

    Это определение аналогично определению ~memv~ выше, за исключением того, что ~remv~ не завершает работу, когда находит
    нужный элемент в ~car~ списка. Выполнение продолжается, просто игнорируя элемент. Если элемент не найден в ~car~,
    ~remv~ делает то же самое, что и ~list-copy~ выше: он спаривает ~car~ списка с результатом рекурсии.

    До сих пор рекурсия проходила только по ~cdr~ списка. Однако иногда полезно, чтобы процедура повторялась как на
    ~cdr~, так и на ~car~ списка. Процедура ~tree-copy~, определённая ниже, интерпретирует структуру пар как дерево, а
    не как список, где левое поддерево является ~car~ от пары, а правое - ~cdr~. Процедура совершает схожие с
    ~list-copy~ операции, образуя новые пары, но оставляя старые элементы (листья).

#+begin_src scheme
    (define tree-copy
      (lambda (tr)
        (if (not (pair? tr))
            tr
            (cons (tree-copy (car tr))
                  (tree-copy (cdr tr))))))

    (tree-copy '((a . b) . c)) → ((a . b) . c)
#+end_src

    Естественным базовым аргументом для древовидной структуры является все, что не является парой, поскольку рекурсия
    проходит через пары, а не списки. В этом случае рекурсивный шаг вдвойне рекурсивен, рекурсивно находит значение для
    ~car~, а также ~cdr~ аргумента.

    На этом этапе читатели, знакомые с другими языками, которые предоставляют специальные итерационные конструкции,
    например циклы ~while~ или ~for~, могут задаться вопросом, требуются ли подобные конструкции в Scheme. Такие
    конструкции не нужны; итерация в Scheme выражается более ясно и лаконично через рекурсию. Рекурсия носит более общий
    характер и устраняет необходимость назначения переменных, требуемых итерационными конструкциями многих других
    языков, в результате чего получается более надежный и понятный код. Некоторая рекурсия по сути является итерацией и
    выполняется таким же образом; Раздел 3.2 может сказать больше об этом. Однако зачастую нет необходимости проводить
    различие. Вместо этого сконцентрируйтесь на написании ясных, кратких и правильных программ.

    Прежде чем мы оставим тему рекурсии, давайте рассмотрим специальную форму повторения, называемую /отображением/.
    Рассмотрим следующую процедуру ~abs-all~, которая принимает список чисел в качестве входных данных и возвращает
    список их абсолютных значений.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (abs (car ls))
                  (abs-all (cdr ls))))))

    (abs-all '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Эта процедура формирует новый список из входного списка, применяя процедуру ~abs~ к каждому элементу. Мы говорим,
    что ~abs-all~ отображает входной список в выходной при помощи ~abs~. Отображение списков через процедуры - довольно
    распространенная вещь, поэтому Scheme предоставляет процедуру ~map~, которая отображает с помощью своего первого
    аргумента, процедуры, свой второй аргумент, список. Мы можем использовать ~map~, чтобы определить ~abs-all~.

#+begin_src scheme
    (define abs-all
      (lambda (ls)
        (map abs ls)))
#+end_src

    Однако в действительности мы не нуждаемся в ~abs-all~, поскольку соответствующее прямое применение ~map~ такое же
    короткое и, возможно, более понятное.

#+begin_src scheme
    (map abs '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Конечно, мы можем использовать ~lambda~ чтобы создать аргумент-процедуру для ~map~, например, чтобы возводить в
    квадрат числа в списке.

#+begin_src scheme
    (map (lambda (x) (* x x))
         '(1 -3 -5 7)) → (1 9 25 49)
#+end_src

    Мы можем отображать сразу несколько списков с помощью процедуры, имеющей столько же аргументов, например:

#+begin_src scheme
    (map cons '(a b c) '(1 2 3)) → ((a . 1) (b . 2) (c . 3))
#+end_src

    Списки должны иметь одинаковую длину, и процедура должна принимать столько аргументов, сколько списков
    передано. Каждый элемент выходного списка является результатом применения процедуры к соответствующим элементам
    входных списков.

    Глядя на первое определение ~abs-all~ выше, вы должны были уже начать догадываться, ещё до изученного только что,
    как могла бы быть устроена процедура ~map1~ - ограниченная версия ~map~, которая отображает процедуру с одним
    аргументом в одном списке.

#+begin_src scheme
    (define map1
      (lambda (p ls)
        (if (null? ls)
            '()
            (cons (p (car ls))
                  (map1 p (cdr ls))))))

    (map1 abs '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)
#+end_src

    Все, что мы сделали, это заменили вызов ~abs~ в ~abs-all~ вызовом нового параметра ~p~. Определение более общего
    ~map~ дано в разделе 5.4.

**** Упражнение 2.8.1

     Опишите, что произойдет, если вы измените порядок аргументов ~cons~ в определении ~tree-copy~.

**** Упражнение 2.8.2

     Обратитесь к разделу 6.3 для описания ~append~ и напишите её новую версию с двумя аргументами. Что произойдет, если
     вы измените порядок аргументов в вызове ~append~ в пределах вашего определения ~append~?

**** Упражнение 2.8.3

     Определите процедуру ~make-list~, которая принимает неотрицательное целое число ~n~ и объект и возвращает новый
     список длиной ~n~, каждый элемент которого является этим объектом.

#+begin_src scheme
     (make-list 7 '()) → (() () () () () () ())
#+end_src

     [Подсказка: базовый тест должен быть ~(= n 0)~, а шаг рекурсии должен включать ~(- n 1)~. Тогда как ~()~ -
     естественный базовый случай для рекурсии по спискам, 0 - естественный базовый случай для рекурсии по
     неотрицательным целым числам. Точно так же вычитание 1 является естественным способом приблизить неотрицательное
     целое число к 0.]

**** Упражнение 2.8.4

     Процедуры ~list-ref~ и ~list-tail~ возвращают N-ный элемент и N-ный хвост списка соответственно.

#+begin_src scheme
     (list-ref '(1 2 3 4) 0) → 1
     (list-tail '(1 2 3 4) 0) → (1 2 3 4)
     (list-ref '(a short (nested) list) 2) → (nested)
     (list-tail '(a short (nested) list) 2) → ((nested) list)
#+end_src

     Определите обе процедуры.

**** Упражнение 2.8.5

     В упражнении 2.7.2 вы использовали ~length~ в определении процедуры ~shorter~, возвращающей кратчайший из двух
     переданных списков, или первый, если длины равны. Напишите ~shorter~ без использования ~length~. [Подсказка:
     определите рекурсивную процедуру-помошник ~shorter?~ и используйте её вместо сравнения длин списков.]

**** Упражнение 2.8.6

     Все рекурсивные процедуры, показанные до сих пор, были непосредственно рекурсивными. То есть каждая процедура
     непосредственно применяет себя к новому аргументу. Также возможно написать две процедуры, которые используют друг
     друга, что приводит к косвенной рекурсии. Определите процедуры ~even?~ (чётно?) и ~odd?~ (нечётно?), каждую в
     терминах другой. [Подсказка: что каждый должен возвращать, когда его аргумент равен 0?]

#+begin_src scheme
     (even? 17) → #f
     (odd? 17) → #t
#+end_src

**** Упражнение 2.8.7

     Используйте ~map~, чтобы определить процедуру ~transpose~, которая берет список пар и возвращает пару списков
     следующим образом.

#+begin_src scheme
     (transpose '((a . 1) (b . 2) (c . 3))) → ((a b c) 1 2 3)
#+end_src

     [Подсказка: ~((a b c) 1 2 3)~ это то же, что и ~((a b c) . (1 2 3))~.]

*** Присваивания

    Хотя многие программы могут быть написаны без них, иногда полезны определения переменных верхнего уровня,
    let-связывания и lambda-связывания. /Присваивания/ не создают новые связывания, как в случае ~let~ или ~lambda~, а
    скорее изменяют значения существующих связываний. Присваивания выполняются с помощью  ~set!~.

#+begin_src scheme
    (define abcde '(a b c d e))
    abcde → (a b c d e)
    (set! abcde (cdr abcde))
    abcde → (b c d e)
    (let ([abcde '(a b c d e)])
      (set! abcde (reverse abcde))
      abcde) → (e d c b a)
#+end_src

    Многие языки требуют использования присваиваний для инициализации локальных переменных, отдельно от объявления или
    связывания переменных. В Scheme все локальные переменные получают значение сразу после связывания. Помимо
    необходимости выполнять отдельное присваивание для инициализации локальных переменных, это гарантирует, что
    программист не сможет забыть инициализировать их, что является распространенным источником ошибок в большинстве
    языков.

    Фактически, большинство назначений, которые либо необходимы, либо удобны в других языках, в Scheme как ненужны, так
    и неудобные, поскольку обычно существует более понятный способ выражения того же алгоритма без присвоений. Обычной
    практикой в некоторых языках является последовательное выполнение выражений и присваиваний, как в следующей
    процедуре, которая находит корни квадратного уравнения.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
          (cons root1 root2))))
#+end_src

    Корни вычисляются по известной формуле поиска корней квадратного уравнения,

#+ATTR_LATEX: :width 60px
[[./images/4.png]]

    что дает решения уравнения /0 = ax^2 + bx + c/. Выражение ~let~ в этом определении используется исключительно для
    установления привязок переменных, соответствующих объявлениям, требуемым в других языках. Первые три выражения
    присваивания вычисляют части формулы, а именно ~-b~ и ~2а~.

#+ATTR_LATEX: :width 60px
[[./images/5.png]]

    Последние два выражения присваивания вычисляют два корня. Пара из двух корней является результатом вычисления
    квадратичной формулы. Например, два корня /2x^2 - 4x - 6/ - это x = 3 и x = -1.

#+begin_src scheme
    (quadratic-formula 2 -4 -6) → (3 . -1)
#+end_src

    Вышеприведенное определение работает, но оно может быть написано более четко без присвоений, как показано ниже.

#+begin_src scheme
    (define quadratic-formula
      (lambda (a b c)
        (let ([minusb (- 0 b)]
              [radical (sqrt (- (* b b) (* 4 (* a c))))]
              [divisor (* 2 a)])
          (let ([root1 (/ (+ minusb radical) divisor)]
                [root2 (/ (- minusb radical) divisor)])
            (cons root1 root2)))))
#+end_src

    В этой версии ~set!~ выражения ушли, и у нас остался по сути тот же алгоритм. Однако, используя два выражения ~let~,
    определение яснее показывает зависимость ~root1~ и ~root2~ от значений ~minusb~, ~radius~ и ~divisor~. Не менее
    важно, что выражения let ясно показывают отсутствие зависимостей между собой для ~minusb~, ~radical~ и ~divisor~, а
    также между ~root1~ и ~root2~.

    Присвоения действительно имеют определённые применения в Scheme, иначе язык бы их не поддерживал. Рассмотрим
    следующую версию ~cons~, которая подсчитывает количество её вызовов, сохраняя счетчик в переменной с именем
    ~cons-count~. Здесь используется ~set!~ чтобы увеличить счетчик; нет способа добиться того же поведения без
    использования подобного рода присвоений.

#+begin_src scheme
    (define cons-count 0)
    (define cons
      (lambda (x y)
        (set! cons-count (+ cons-count 1))
        (cons x y)))
#+end_src

#+begin_src scheme
    (kons 'a '(b c)) → (a b c)
    kons-count → 1
    (kons 'a (kons 'b (kons 'c '()))) → (a b c)
    kons-count → 4
#+end_src

    Присвоения обычно используются для реализации процедур, которые должны поддерживать некоторое внутреннее
    состояние. Например, предположим, что мы хотим определить процедуру, которая возвращает 0 в первый раз, когда она
    вызывается, 1 во второй раз, 2 в третий раз и так далее до бесконечности. Мы могли бы написать что-то похожее на
    определенный выше ~cons-count~:

#+begin_src scheme
    (define next 0)
    (define count
      (lambda ()
        (let ([v next])
          (set! next (+ next 1))
          v)))

    (count) → 0
    (count) → 1
#+end_src

    Это решение несколько нежелательно в том смысле, что переменная ~next~ видна на верхнем уровне, даже если это не
    обязательно. Так как она видна на верхнем уровне, любой код в системе может изменить её значение, возможно,
    непреднамеренно повлиять на поведение счетчика неявным образом. Мы можем решить эту проблему с помощью
    let-связывания вне лямбда-выражения:

#+begin_src scheme
    (define count
      (let ([next 0])
        (lambda ()
          (let ([v next])
            (set! next (+ next 1))
            v))))
#+end_src

    Последнее решение также легко обобщается для предоставления нескольких счетчиков, каждый из которых имеет свой
    собственный локальный счетчик. Процедура ~make-counter~, определенная ниже, возвращает новую процедуру подсчета
    каждый раз, когда она вызывается.

#+begin_src scheme
    (define make-counter
      (lambda ()
        (let ([next 0])
          (lambda ()
            (let ([v next])
              (set! next (+ next 1))
              v)))))
#+end_src

    Поскольку ~next~ связывается внутри ~make-counter~, но вне процедуры, возвращаемой ~make-counter~, каждая
    возвращаемая процедура использует свой уникальный счетчик.

#+begin_src scheme
    (define count1 (make-counter))
    (define count2 (make-counter))

    (count1) → 0
    (count2) → 0
    (count1) → 1
    (count1) → 2
    (count2) → 1
#+end_src

   Если переменная состояния должна совместно использоваться более чем одной процедурой, определенной на верхнем уровне,
   но мы не хотим, чтобы переменная состояния была видимой на верхнем уровне, мы можем использовать ~let~, чтобы связать
   переменную и ~set!~ сделать процедуры видимыми на верхнем уровне.

#+begin_src scheme
    (define shhh #f)
    (define tell #f)
    (let ([secret 0])
      (set! shhh
        (lambda (message)
          (set! secret message)))
      (set! tell
        (lambda ()
          secret)))

    (shhh "sally likes harry")
    (tell) → "sally likes harry"
    secret → exception: variable secret is not bound
#+end_src

    Переменные должны быть определены до того, как им будет присвоено значение, поэтому мы вначале определяем ~shhh~ и
    присваиваем ему ~#f~ (подойдет любое начальное значение). Мы увидим эту структуру снова в Разделе 3.5, а лучший
    способ структурировать подобный код как библиотеку в Разделе 3.6.

    Локальное состояние иногда полезно для кэширования вычисленных значений, а так же позволяет производить ленивые
    вычисления, т. е. производить вычисления только один раз и только по требованию. Процедура ~lazy~ ниже принимает
    чанк (англ. thunk), процедуру нулевой арности, в качестве аргумента. Чанки часто используются для «замораживания»
    вычислений, которые по какой-то причине должны быть отложены, что в точности то, что нам нужно в данной
    ситуации. При передаче чанка ~t~, ~lazy~ возвращает новый чанк, который при вызове возвращает значение вызова
    ~t~. Единожды вычисленое, значение сохраняется в локальной переменной, так что вычисление больше не
    требуется. Логический флаг используется для записи того, был ли вычислен ~t~ и сохранено ли его значение.

#+begin_src scheme
    (define lazy
      (lambda (t)
        (let ([val #f] [flag #f])
          (lambda ()
            (if (not flag)
                (begin (set! val (t))
                       (set! flag #t)))
            val))))
#+end_src


    Синтаксическая форма ~begin~, используемая здесь впервые, выполняет свои подвыражения в последовательности слева
    направо и возвращает значение последнего подвыражения, как тело выражения ~let~ или лямбда-выражения. Мы также
    видим, что альтернативное подвыражение выражения ~if~ может быть опущено. Это должно быть сделано только тогда,
    когда значение ~if~ отбрасывается, как в этом случае.

    Ленивые вычисления особенно полезны для значений, которые требуют значительного времени для рассчёта. Откладывая
    вычисление, мы можем избежать рассчёта значения в целом, а сохраняя результат, мы избегаем вычисления его более
    одного раза.

    Функционирование ~lazy~ может быть лучше всего проиллюстрирована выводом сообщения из чанка, переданного в
    ~lazy~ в качестве аргумента.

#+begin_src scheme
    (define p
      (lazy (lambda ()
              (display "Ouch!")
              (newline)
              "got me")))
#+end_src

    При первом вызове ~p~  печатается сообщение ~"Ouch!"~ , и возвращается строка ~"got me"~ . Последующие вызовы
    возвращают ~"got me"~ , но сообщение не печатают. Процедуры ~display~ и ~newline~ - это первые примеры явного
    ввода/вывода, которые мы видели; ~display~ выводит строку без кавычек, а ~newline~  печатает символ новой строки.

    Чтобы дополнительно проиллюстрировать использование ~set!~, давайте рассмотрим реализацию объектов стека, внутренняя
    работа которых не видна снаружи. Объект стека принимает одно из четырех сообщений: ~empty?~, которое возвращает
    ~#t~, если стек пуст; ~push!~, который добавляет объект на вершину стека; ~top~, который возвращает объект с
    вершины стека; и ~pop!~, который удаляет объект сверху стека. Приведенная ниже процедура ~make-stack~ создает новый
    стек каждый раз, когда она вызывается, аналогично ~make-counter~.

#+begin_src scheme
    (define make-stack
      (lambda ()
        (let ([ls '()])
          (lambda (msg . args)
            (cond
              [(eqv? msg 'empty?) (null? ls)]
              [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
              [(eqv? msg 'top) (car ls)]
              [(eqv? msg 'pop!) (set! ls (cdr ls))]
              [else "oops"])))))
#+end_src

    Каждый стек хранится в виде списка, привязанного к переменной ~ls~; ~set!~ используется для изменения этой привязки
    в ~push!~ и ~pop!~. Обратите внимание, что список аргументов внутреннего лямбда-выражения использует синтаксис
    неправильного списка для связывания всех аргументов, кроме первого, со списком. Это полезно здесь, потому что в
    случае ~empty?~, ~top~ и ~pop!~ есть только один аргумент (сообщение), но в случае ~push!~ их два (сообщение и
    объект, который нужно поместить в стек).

#+begin_src scheme
    (define stack1 (make-stack))
    (define stack2 (make-stack))
    (list (stack1 'empty?) (stack2 'empty?)) → (#t #t)

    (stack1 'push! 'a)
    (list (stack1 'empty?) (stack2 'empty?)) → (#f #t)

    (stack1 'push! 'b)
    (stack2 'push! 'c)
    (stack1 'top) → b
    (stack2 'top) → c

    (stack1 'pop!)
    (stack1 'top) → a
    (list (stack1 'empty?) (stack2 'empty?)) → (#f #f)

    (stack1 'pop!)
    (list (stack1 'empty?) (stack2 'empty?)) → (#t #f)
#+end_src

    Как и в случае счетчиков, созданных ~make-counter~, состояние, используемое каждым объектом стека, напрямую доступно
    только внутри объекта. Каждый доступ или изменение этого состояния выполняется явно самим объектом. Одним из важных
    преимуществ является то, что мы можем изменить внутреннюю структуру стека, например, использовав вектор (см. Раздел
    6.9) вместо списка для хранения элементов без изменения его внешнего поведения. Поскольку поведение объекта известно
    абстрактно (не операционно), он считается абстрактным объектом. Смотри раздел 12.8 для получения дополнительной
    информации о создании абстрактных объектов.

    Помимо изменения значений переменных, мы также можем изменять значения полей пар ~car~ и ~cdr~, используя процедуры
    ~set-car!~ и ~set-cdr!~ .

#+begin_src scheme
    (define p (list 1 2 3))
    (set-car! (cdr p) 'two)
    p → (1 two 3)
    (set-cdr! p '())
    p → (1)
#+end_src

    Мы можем использовать эти операторы для определения типа данных 'очередь', который похож на стек, за исключением
    того, что новые элементы добавляются на одном конце и извлекаются из другого. Следующая реализация очереди
    использует структуру ~tconc~. ~tconc~ состоит из непустого списка и заголовка. Заголовок - это пара, ~car~ которой
    указывает на первую пару (заголовок) списка, а ~cdr~ указывает на последнюю пару (конец) списка.

#+ATTR_LATEX: :width 200px
[[./images/6.png]]

    Последний элемент списка является заполнителем и не считается частью очереди.

    Ниже приведены четыре операции с очередями: ~make-queue~, которая создает очередь; ~putq!~ , которая добавляет
    элемент в конец очереди; ~getq~, которая извлекает элемент в начале очереди; и ~delq!~, который удаляет элемент из
    начала очереди.

#+begin_src scheme
    (define make-queue
      (lambda ()
        (let ([end (cons 'ignored '())])
          (cons end end))))

    (define putq!
      (lambda (q v)
        (let ([end (cons 'ignored '())])
          (set-car! (cdr q) v)
          (set-cdr! (cdr q) end)
          (set-cdr! q end))))

    (define getq
      (lambda (q)
        (car (car q))))

    (define delq!
      (lambda (q)
        (set-car! q (cdr (car q)))))
#+end_src

    Все это простые операции, кроме ~putq!~, которая изменяет конечную пару, чтобы она содержала новое значение, и
    добавляет новую конечную пару.

#+begin_src scheme
    (define myq (make-queue))

    (putq! myq 'a)
    (putq! myq 'b)
    (getq myq) → a
    (delq! myq)
    (getq myq) → b
    (delq! myq)
    (putq! myq 'c)
    (putq! myq 'd)
    (getq myq) → c
    (delq! myq)
    (getq myq) → d
#+end_src

**** Упражнение 2.9.1

     Измените ~make-counter~ так, чтобы он принимал два аргумента: начальное значение для счетчика, которое будет
     использоваться вместо 0, и значение, на которое счетчик увеличивается каждый раз.

**** Упражнение 2.9.2

     Посмотрите описание случая в разделе 5.3. Замените выражение ~cond~ в ~make-stack~ на эквивалентное выражение
     ~case~. Добавить ~mt?~ как второе имя для сообщения ~empty?~.

**** Упражнение 2.9.3

     Измените объект стека, чтобы разрешить два сообщения ~ref~ и ~set!~. ~(stack 'ref i)~ должен возвращать i-й элемент
     от верхушки стека; ~(stack 'ref 0)~ должен быть эквивалентен ~(stack 'top)~. ~(stack 'set! i v)~ должен изменить
     i-й элемент с вершины стека на v.

#+begin_src scheme
     (define stack (make-stack))

     (stack 'push! 'a)
     (stack 'push! 'b)
     (stack 'push! 'c)

     (stack 'ref 0) → c
     (stack 'ref 2) → a
     (stack 'set! 1 'd)
     (stack 'ref 1) → d
     (stack 'top) → c
     (stack 'pop!)
     (stack 'top) → d
#+end_src

     [Подсказка: используйте ~list-ref~ для реализации ~ref~ и ~list-tail~ с ~set-car!~ чтобы реализовать ~set!~.]

**** Упражнение 2.9.4

     Scheme поддерживает также векторы, как и списки. Как и списки, векторы являются собирательными объектами, которые
     содержат другие объекты. В отличие от списков, векторы имеют фиксированный размер и располагаются в одном плоском
     блоке памяти, обычно с заголовком, содержащим длину вектора, как в векторе из десяти элементов ниже.

#+ATTR_LATEX: :width 200px
[[./images/7.png]]

     Это делает векторы более подходящими для приложений, нуждающихся в быстром доступе к любому элементу
     последовательности, но менее подходящими для приложений, которым требуются структуры данных, которые растут и
     сжимаются по мере необходимости.

     Посмотрите основные векторные операции в Разделе 6.9 и переопределите объект стека, чтобы использовать вектор
     вместо списка для хранения содержимого стека. Добавьте ~ref~ и ~set!~ сообщения из упражнения 2.9.3. Пусть новый
     ~make-stack~ принимает аргумент размера ~n~ и задает длину вектора ~n~, но никак иначе не изменяет внешний
     (абстрактный) интерфейс.

**** Упражнение 2.9.5

     Определите предикат ~emptyq?~, определяющий, пуста ли очередь. Измените ~getq~ и ~delq!~ так, чтобы вызвать
     исключение при обнаружении пустой очереди, используя ~assertion-violation~.

**** Упражнение 2.9.6

     В реализации очереди последняя пара в инкапсулированном списке является заполнителем, то есть никогда не содержит
     ничего полезного. Перепишите операторы очереди, чтобы избежать этой потраченной впустую пары. Убедитесь, что серия
     операций с очередями, приведенная ранее, работает с новой реализацией. Какую реализацию вы бы предпочли?

**** Упражнение 2.9.7

     Используя ~set-cdr!~, можно создавать циклические списки. Например, следующее выражение возвращает список, ~car~
     которого является символ ~a~, а ~cdr~ является самим списком.

#+begin_src scheme
     (let ([ls (cons 'a '())])
       (set-cdr! ls ls)
       ls)
#+end_src

     Что произойдёт, если вы введёте вышеприведенное выражение во время интерактивного сеанса Scheme? Что будет делать
     реализация ~length~ из раздела 2.8, если ей передать циклический список? Как поведёт себя встроенный примитив
     ~length~?

**** Упражнение 2.9.8

     Определите предикат ~list?~, который возвращает ~#t~, если его аргумент является правильным списком, и ~#f~ в
     противном случае (см. Раздел 6.3). Он должен возвращать ~#f~ для циклических списков, а также для списков,
     оканчивающихся объектами, отличными от ~()~.

#+begin_src scheme
     (list? '()) → #t
     (list? '(1 2 3)) → #t
     (list? '(a . b)) → #f
     (list? (let ([ls (cons 'a '())])
              (set-cdr! ls ls)
              ls)) → #f
#+end_src

     Сначала напишите упрощенную версию ~list?~ которая не обрабатывает случай с циклическими списки, а затем расширьте
     её для правильной обработки циклических списков. Пересматривайте свое определение, пока не убедитесь, что оно
     максимально четкое и краткое. [Подсказка: используйте следующий алгоритм "заяц и черепаха" для определения
     цикличных списков. Определите рекурсивную вспомогательную процедуру с двумя аргументами: заяц и черепаха. Запустите
     зайца и черепаху в начале списка. Сделайте так, чтобы заяц продвигался на два ~cdr~ каждый раз,
     когда черепаха продвигается на один ~cdr~. Если заяц ловит черепаху, значит это цикл.]

#+LATEX: \newpage
[[./images/ch3.png]]

** Двигаемся дальше

   Предыдущая глава подготовила вас к написанию программ Scheme с использованием небольшого набора наиболее полезных
   примитивных синтаксических форм и процедур. В этой главе представлен ряд дополнительных функций и методов
   программирования, которые позволят вам писать более сложные и эффективные программы.

*** Syntactic Extension

    Как мы видели в Разделе 2.5, синтаксическая форма ~let~ - это просто синтаксическое расширение, определяемое в
    терминах лямбда-выражения и применения процедуры, которые являются основными синтаксическими формами. В этот момент
    вам может быть интересно, какие синтаксические формы являются основными, а какие - синтаксическими расширениями, и
    как могут быть определены новые синтаксические расширения. В этом разделе приведены некоторые ответы на эти
    вопросы.

    По правде говоря, нам не нужно проводить различие между основными формами и синтаксическими расширениями, поскольку
    после определения синтаксическое расширение имеет точно такой же статус, что и основная форма. Проведение различия,
    однако, облегчает понимание языка, поскольку позволяет нам сосредоточить внимание на основных формах и понять все
    остальные с точки зрения этих форм.

    Для реализации Scheme необходимо различать основные формы и синтаксические расширения. Реализация Scheme
    разворачивает синтаксические расширения в основные формы на первом этапе компиляции или интерпретации, позволяя
    остальной части компилятора или интерпретатора сосредоточиться только на основных формах. Однако набор основных
    форм, остающихся после раскрытия, которые будут обрабатываться непосредственно компилятором или интерпретатором,
    зависит от реализации и может отличаться от набора форм, описанных здесь как основные.

    Таким образом, точный набор синтаксических форм, составляющих ядро ​​языка, является предметом споров, хотя должна
    быть возможность вывести все другие формы из любого набора форм, объявленных основными. Описанный здесь набор
    является одним из самых простых, для которых это ограничение выполняется.

    Основные синтаксические формы включают в себя формы определения верхнего уровня (~define~), константы, переменные,
    применение процедур, ~quote~, ~lambda~, ~if~ и ~set!~ выражения. Грамматика ниже описывает основной синтаксис Scheme
    в терминах этих определений и выражений. В грамматике вертикальные черты (~|~) разделяют альтернативы, а форма, за
    которой следует звездочка (~*~), представляет ноль или более вхождений формы. ~<variable>~ - это любой идентификатор
    Scheme. ~<datum>~ - это любой объект Scheme, например число, список, символ или вектор. ~<boolean>~ это либо ~#t~,
    либо ~#f~, ~<number>~ - это любое число, ~<character>~ - это любой символ, а ~<string>~ - это любая строка. Мы уже
    видели примеры чисел, строк, списков, символов и логических значений. См. главу 6 или описание формального
    синтаксиса, для получения дополнительной информации о синтаксисе этих и других объектов.

#+BEGIN_EXAMPLE
    <program>             → <form>*
    <form>                → <definition> | <expression>
    <definition>          → <variable definition> | (begin <definition>*)
    <variable definition> → (define <variable> <expression>)
    <expression>          → <constant>
                          | <variable>
                          | (quote <datum>)
                          | (lambda <formals> <expression> <expression>*)
                          | (if <expression> <expression> <expression>)
                          | (set! <variable> <expression>)
                          | <application>
    <constant>            → <boolean> | <number> | <character> | <string>
    <formals>             → <variable>
                          | (<variable>*)
                          | (<variable> <variable>* . <variable>)
    <application>         → (<expression> <expression>*)
#+END_EXAMPLE

    Грамматика неоднозначна в том смысле, что синтаксис применения процедур конфликтует с синтаксисами ~quote~,
    ~lambda~, ~if~ и ~set!~ выражения. Чтобы трактоваться как применение процедуры, первое ~<expression>~ не должно быть
    одним из этих ключевых слов, если только ключевое слово не было переопределено или связано локально.

    Синтаксис ~"defun"~ для определения, приведенный в разделе 2.6, не включен в ядро, так как определения в этой форме
    прямо переводятся в более простой синтаксис определения. Точно так же основной синтаксис для ~if~ не позволяет
    опустить альтернативу, как это было сделано в примере в Разделе 2.9. Выражение ~if~, в котором отсутствует
    альтернатива, может быть переведено в основной синтаксис ~if~, просто заменив отсутствующее подвыражение
    произвольной константой, такой как ~#f~.

    Форма ~begin~, содержащая только определения, считается определением в грамматике; это разрешено, чтобы позволить
    синтаксическим расширениям разворачиваться в более чем одно определение. Выражение ~begin~ т.е. форма ~beging~,
    содержащая выражения, не считается основной формой. Выражение ~begin~ в виде

#+begin_src scheme
    (begin e1 e2 ...)
#+end_src

    это эквивалент применения ~lambda~-выражения

#+begin_src scheme
    ((lambda () e1 e2 ...))
#+end_src

    следовательно, нет нужды содержать его в ядре.

    Теперь, когда мы создали набор основных синтаксических форм, давайте обратимся к обсуждению синтаксических
    расширений. Синтаксические расширения называются так потому, что они расширяют ядро синтаксиса Scheme. Все
    синтаксические расширения в программе на Scheme должны быть в конечном итоге сводимы к основным формам. Однако одно
    синтаксическое расширение может быть определено в терминах другого синтаксического расширения, если последнее в
    некотором смысле «ближе» к основному синтаксису. Синтаксические формы могут применяться везде, где ожидается
    выражение или определение, при условии, что расширенная форма раскрывается в определение или выражение по мере
    необходимости.

    Синтаксические расширения определяются с помощью ~define-syntax~. ~define-syntax~ аналогично ~define~, за
    исключением того, что ~define-syntax~ связывает процедуру синтаксического преобразования или преобразователь с
    ключевым словом (например, ~let~), а не связывает значение с переменной. Вот как мы можем определить ~let~ с помощью
    ~define-syntax~.

#+begin_src scheme
    (define-syntax let
      (syntax-rules ()
        [(_ ((x e) ...) b1 b2 ...)
         ((lambda (x ...) b1 b2 ...) e ...)]))
#+end_src

    Идентификатор, появляющийся после ~define-syntax~, является именем или ключевым словом определяемого синтаксического
    расширения, в данном случае ~let~. Форма ~syntax-rule~ - это выражение, которое выполняет преобразователь. Элемент,
    следующий за ~syntax-rule~ - это списком вспомогательных ключевых слов и это почти всегда ~()~. Примером
    вспомогательного ключевого слова является ~else~ в ~cond~ (другие примеры, требующие использования вспомогательных
    ключевых слов, приведены в главе 8). После списка вспомогательных ключевых слов приведена последовательность из
    одного или нескольких правил или пар образец/шаблон. Только одно правило появляется в нашем определении
    ~let~. Часть правила "образец" определяет форму, которую должен принимать вход, а "шаблон" указывает, во что вход
    должен быть преобразован.

    Образец всегда должен быть структурированным выражением, первым элементом которого является подчеркивание (~_~). (Как
    мы увидим в главе 8, использование ~_~ - это всего лишь соглашение, но оно хорошо подходит в нашем случае). Если
    присутствует более одного правила, подходящее выбирается путем сопоставления образцов по порядку с формой, поданой
    на вход, во время раскрытия. Если ни один из образцов не соответствует входным данным, это синтаксическое
    нарушение.

    Идентификаторы, отличные от подчеркивания или многоточия, встречающиеся в образце, являются переменными образца,
    если только они не указаны в качестве вспомогательных ключевых слов. Переменные образца соответствуют любой
    подструктуре и привязываются к этой подструктуре в соответствующем образце. Нотация ~pat ...~ в образце
    позволяет сопоставить ноль или более выражений в многоточии с прототипом ~pat~ во входных данных. Точно так же
    запись ~expr ...~ в шаблоне выдает ноль или более выражений, сопоставленных многоточием в прототипе ~expr~ в
    вывод. Количество ~pat~ на входе определяет количество ~expr~ на выходе; чтобы это работало, любой прототип
    многоточия в шаблоне должен содержать хотя бы одну переменную шаблона из прототипа многоточия в шиблоне.

    Единственное правило в нашем определении ~let~ должно быть достаточно самоочевидным, но стоит упомянуть несколько
    моментов. Во-первых, синтаксис ~let~ требует, чтобы тело содержало хотя бы одну форму; следовательно, мы указали ~b1
    b2 ...~ вместо ~b ...~, что может показаться более естественным. С другой стороны, ~let~ не требует, чтобы была хотя
    бы одна пара переменная/значение, поэтому мы могли просто использовать ~(x e) ...~. Во-вторых, переменные-образцы
    ~x~ и ~e~, хотя и вместе в одном прототипе в образце, разделены в шаблоне; возможна любая перестановка или
    рекомбинация. Наконец, три переменные образца ~x~, ~e~ и ~b2~, которые появляются в прототипах многоточия в образце,
    также появляются в прототипах многоточия в шаблоне. Это не совпадение; это требование. В общем случае, если
    переменная-образец появляется в прототипе многоточия в образце, она не может появляться вне прототипа многоточия в
    шаблоне.

    Определение ~and~ ниже несколько сложнее, чем определение для ~let~.

#+begin_src scheme
    (define-syntax and
      (syntax-rules ()
        [(_) #t]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (if e1 (and e2 e3 ...) #f)]))
#+end_src

    Это определение является рекурсивным и включает более одного правила. Напомним, что ~(and)~ возвращает ~#t~; первое
    правило заботится об этом случае. Второе и третье правила определяют базовый случай и шаг рекурсии и вместе
    переводят ~and~ выражение с двумя или более подвыражениями во вложенные выражения ~if~. Например, ~(and a b c)~
    разворачивается сначала в

#+begin_src scheme
    (if a (and b c) #f)
#+end_src

    а потом в

#+begin_src scheme
    (if a (if b (and c) #f) #f)
#+end_src

    и наконец в

#+begin_src scheme
    (if a (if b c #f) #f)
#+end_src

    При таком раскрытии, если ~a~ и ~b~ возвращают истинну, тогда результатом является значение ~c~, в противном случае
    ~#f~, что и требовалось.

    Версия ~and~ ниже проще, но, к сожалению, неверна.

#+begin_src scheme
    (define-syntax and ; incorrect!
      (syntax-rules ()
        [(_) #t]
        [(_ e1 e2 ...)
         (if e1 (and e2 ...) #f)]))
#+end_src

    Выражение

#+begin_src scheme
    (and (not (= x 0)) (/ 1 x))
#+end_src

    должно вернуть значение ~(/ 1 х)~, когда ~х~ не ноль. При неверной версии ~and~ выражение раскрывается следующим
    образом.

#+begin_src scheme
    (if (not (= x 0)) (and (/ 1 x)) #f) →
    (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) →
    (if (not (= x 0)) (if (/ 1 x) #t #f) #f)
#+end_src

    Окончательный ответ, если ~x~ не ноль, это ~#t~, а не значение ~(/ 1 х)~.

    Определение ~or~ ниже аналогично определению ~and~, за исключением того, что для каждого промежуточного значения
    должна быть введена временная переменная, чтобы мы могли одновременно проверить значение и вернуть его, если оно
    является истинной. (Временная переменная не нужна для ~and~, поскольку существует только одно ложное значение,
    ~#f~).

#+begin_src scheme
    (define-syntax or
      (syntax-rules ()
        [(_) #f]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         (let ([t e1])
           (if t t (or e2 e3 ...)))]))
#+end_src

    Как и переменные, связанные лямбда-выражением или ~let~, идентификаторы, введенные шаблоном, имеют лексическую
    область видимости, то есть видимы только в выражениях, введенных шаблоном. Таким образом, даже если одно из
    выражений ~e2 e3 ...~ содержит ссылку на ~t~, введенная привязка для ~t~ не "захватывает" эти ссылки. Обычно это
    достигается путем автоматического переименования введенных идентификаторов.

    Как и в случае с более простой версией ~and~ приведенной выше, более простая версия ~or~ ниже является
    неправильной.

#+begin_src scheme
    (define-syntax or ; incorrect!
      (syntax-rules ()
        [(_) #f]
        [(_ e1 e2 ...)
         (let ([t e1])
           (if t t (or e2 ...)))]))
#+end_src

    Однако причина более тонкая и является предметом упражнения 3.2.6.

**** Упражнение 3.1.1

     Запишите шаги, необходимые для раскрытия расширения

#+begin_src scheme
     (let ([x (memv 'a ls)])
       (and x (memv 'b x)))
#+end_src

    в базовые формы.

**** Упражнение 3.1.2

     Запишите шаги, необходимые для раскрытия расширения

#+begin_src scheme
     (or (memv x '(a b c)) (list x))
#+end_src

     в базовые формы.

**** Упражнение 3.1.3

     ~let*~ аналогичен ~let~, но выполняет связывания по порядку. Каждое из выражений в правой части находится в рамках
     области действия предыдущих привязок.

#+begin_src scheme
     (let* ([a 5] [b (+ a a)] [c (+ a b)])
       (list a b c)) → (5 10 15)
#+end_src

     ~let*~ может быть реализован как вложенные выражения ~let~. Например, вышеприведенное выражение ~let*~ эквивалентно
     вложенным выражениям ~let~ ниже.

#+begin_src scheme
     (let ([a 5])
       (let ([b (+ a a)])
         (let ([c (+ a b)])
           (list a b c)))) → (5 10 15)
#+end_src

     Определите ~let*~ с помощью ~define-syntax~.

**** Упражнение 3.1.4

     Как мы видели в разделе 2.9, допустимо опускать третье или альтернативное подвыражение выражения ~if~. Однако это
     часто приводит к путанице. Scheme предоставляет две синтаксические формы, ~when~ и ~unless~, которые могут
     использоваться вместо таких «одноруких» ~if~.

#+begin_src scheme
     (when test expr1 expr2 ...)
     (unless test expr1 expr2 ...)
#+end_src

     В обеих формах тест вычисляется первым. Для ~when~, если ~test~ возвращает истину, остальные формы выполняются
     последовательно, как если бы они были заключены в неявное выражение ~begin~. Если ~test~ возвращает ложь, остальные
     формы не выполняются, а результат неопределён. ~unless~ ведёт себя аналогично, за исключением того, что остальные
     формы выполняются только если тест оценивается как ложный.

#+begin_src scheme
     (let ([x 3])
       (unless (= x 0) (set! x (+ x 1)))
       (when (= x 4) (set! x (* x 2)))
       x) → 8
#+end_src

     Определите ~when~ как синтаксическое расширение в терминах ~if~ и ~begin~, и определите ~unless~, только в терминах
     ~when~.

*** Больше о рекурсии

    В разделе 2.8 мы увидели, как определять рекурсивные процедуры, используя определения верхнего уровня. До этого мы
    видели, как создавать локальные связывания для процедур с использованием ~let~. Естественно задаться вопросом, может
    ли ~let~-процедура быть рекурсивной. Ответ - нет, по крайней мере, не прямым способом. Если вы попытаетесь выполнить
    выражение

#+begin_src scheme
    (let ([sum (lambda (ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5)))
#+end_src

    это, вероятно, вызовет исключение с сообщением о том, что ~sum~ не определена. Это связано с тем, что переменная
    ~sum~ видна только в теле выражения ~let~, а не в лямбда-выражении, значение которого связано с ~sum~. Мы можем
    обойти эту проблему, передав процедуру ~sum~ себе самой следующим образом.

#+begin_src scheme
    (let ([sum (lambda (sum ls)
                 (if (null? ls)
                     0
                     (+ (car ls) (sum sum (cdr ls)))))])
      (sum sum '(1 2 3 4 5))) → 15
#+end_src

    Это работает и является разумным решением, но есть более простой способ, используя ~letrec~. Как и ~let~,
    синтаксическая форма ~letrec~ включает в себя набор пар переменная-значение и последовательность выражений,
    называемых телом ~letrec~.

#+begin_src scheme
    (letrec ((var expr) ...) body1 body2 ...)
#+end_src

    В отличие от ~let~, переменные ~var ...~ видны не только внутри тела ~letrec~, но и внутри выражения ~expr
    ...~. Таким образом, мы можем переписать приведенное выше выражение следующим образом.

#+begin_src scheme
    (letrec ([sum (lambda (ls)
                    (if (null? ls)
                        0
                        (+ (car ls) (sum (cdr ls)))))])
      (sum '(1 2 3 4 5))) → 15
#+end_src

    Используя ~letrec~, мы также можем определить взаимно рекурсивные процедуры, такие как процедуры ~even?~ и ~odd?~,
    которые были предметом упражнения 2.8.6.

#+begin_src scheme
    (letrec ([even?
              (lambda (x)
                (or (= x 0)
                    (odd? (- x 1))))]
             [odd?
              (lambda (x)
                (and (not (= x 0))
                     (even? (- x 1))))])
      (list (even? 20) (odd? 20))) → (#t #f)
#+end_src

    В выражении ~letrec~ ~expr ...~ чаще всего является лямбда-выражением, хотя это не обязательно. Однако необходимо
    соблюдать одно ограничение для выражений. Должна быть возможность вычислять каждое выражение без вычисления
    какой-либо из переменных ~var ...~. Это ограничение всегда выполняется, если все выражения являются
    лямбда-выражениями, поскольку, хотя переменные могут появляться в лямбда-выражениях, они не могут быть вычислены до
    тех пор, пока результирующие процедуры не будут вызваны в теле ~letrec~. Следующее выражение ~letrec~ подчиняется
    этому ограничению.

#+begin_src scheme
    (letrec ([f (lambda () (+ x 2))]
             [x 1])
      (f)) → 3
#+end_src

    А это нет.

#+begin_src scheme
    (letrec ([y (+ x 2)]
             [x 1])
      y)
#+end_src

    В этом случае возникает исключение, указывающее, что ~x~ не определено там, где на него ссылаются.

    Мы можем использовать ~letrec~, чтобы скрыть определения «вспомогательных» процедур, чтобы они не загромождали
    пространство имен верхнего уровня. Это демонстрирует определение ~list?~ ниже, который следует алгоритму «заяц и
    черепаха», описанному в упражнении 2.9.8.

#+begin_src scheme
    (define list?
      (lambda (x)
        (letrec ([race
                  (lambda (h t)
                    (if (pair? h)
                        (let ([h (cdr h)])
                          (if (pair? h)
                              (and (not (eq? h t))
                                   (race (cdr h) (cdr t)))
                              (null? h)))
                        (null? h)))])
          (race x x))))
#+end_src

    Когда рекурсивная процедура вызывается только в одном месте вне процедуры, как в примере выше, часто проще
    использовать именованное выражение ~let~. Именованные ~let~ выражения принимают следующую форму.

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    Именованный ~let~ похож на безымянный ~let~ в том, что он связывает переменные ~var ...~ со значениями ~expr ...~ в
    теле ~body1 body2 ...~. Как и в случае безымянного ~let~, переменные видны только внутри тела, а не внутри ~expr
    ...~. В дополнение, переменная ~name~ внутри тела связана с процедурой, которая может быть вызвана для рекурсии;
    аргументы процедуры становятся новыми значениями переменных ~var ...~.

    Определение ~list?~ было переписано ниже для использования именнованного ~let~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (let race ([h x] [t x])
          (if (pair? h)
              (let ([h (cdr h)])
                (if (pair? h)
                    (and (not (eq? h t))
                         (race (cdr h) (cdr t)))
                    (null? h)))
              (null? h)))))
#+end_src

    Так же, как обычный ~let~ может быть представлен в виде простого применения лямбда-выражения к аргументам, так и
    именованный ~let~ может быть представлен как применение рекурсивной процедуры к аргументам. Форма именованного ~let~

#+begin_src scheme
    (let name ((var expr) ...)
      body1 body2 ...)
#+end_src

    может быть переписана в терминах ~letrec~ следующим образом.

#+begin_src scheme
    ((letrec ((name (lambda (var ...) body1 body2 ...)))
       name)
     expr ...)
#+end_src

    Или иначе это может быть переписано как

#+begin_src scheme
    (letrec ((name (lambda (var ...) body1 body2 ...)))
      (name expr ...))
#+end_src

    при условии, что переменная ~name~ не появляется свободно в ~expr ...~.

    Как мы обсуждали в разделе 2.8, некоторая рекурсия по сути является итерацией и выполняется как таковая. Когда вызов
    процедуры находится в хвостовой позиции (см. ниже) по отношению к лямбда-выражению, он считается хвостовым вызовом,
    и системы Scheme должны правильно обрабатывать его как ~"goto"~ или прыжок. Когда процедура вызывает себя хвостовым
    вызовом или вызывает себя косвенно через серию хвостовых вызовов, результатом является хвостовая рекурсия. Поскольку
    хвостовые вызовы обрабатываются как переходы, хвостовая рекурсия может использоваться для неограниченной итерации
    вместо более ограниченных итерационных конструкций, предоставляемых другими языками программирования, не опасаясь
    переполнения любого вида стека рекурсии.

    Вызов находится в хвостовой позиции по отношению к лямбда-выражению, если его результат возвращается непосредственно
    из лямбда-выражения, т.е. если после вызова ничего не остается делать, кроме как возвращаться из
    лямбда-выражения. Например, вызов находится в хвостовой позиции, если это последнее выражение в теле
    лямбда-выражения, последующая или альтернативная часть выражения ~if~ в хвостовой позиции, последнее подвыражение
    ~and~ или ~or~ в хвостовой позиции, последнее выражение в теле ~let~ или ~letrec~ в хвостовой позиции и т. д. Каждый
    из вызовов ~f~ в приведенных ниже выражениях является хвостовым вызовом, а вызовы ~g~ - нет.

#+begin_src scheme
    (lambda () (f (g)))
    (lambda () (if (g) (f) (f)))
    (lambda () (let ([x 4]) (f)))
    (lambda () (or (g) (f)))
#+end_src

    В каждом случае результат вызовов ~f~ возвращаются напрямую, тогда как вызовы ~g~ - нет.

    Рекурсия в общем и именованный ~let~ позволяет, в частности, обеспечить естественный способ реализации многих
    алгоритмов, будь то итеративный, рекурсивный или частично итеративный, или частично рекурсивный; программист не
    принуждён выбирать между двумя различными механизмами.

    Следующие два определения факториала используют именованные выражения ~let~ для вычисления факториала ~n!~ целого
    неотрицательного числа ~n~. Первый использует рекурсивное определение ~n! = n × (n - 1)!~, где ~0!~ определяется
    как 1.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n])
          (if (= i 0)
              1
              (* i (fact (- i 1)))))))

    (factorial 0) → 1
    (factorial 1) → 1
    (factorial 2) → 2
    (factorial 3) → 6
    (factorial 10) → 3628800
#+end_src

    Вторая - это итерационная версия, в которой используется итеративное определение ~n! = n × (n - 1) × (n - 2) × ... ×
    1~, использующая аккумулятор ~a~ для хранения промежуточных результатов.

#+begin_src scheme
    (define factorial
      (lambda (n)
        (let fact ([i n] [a 1])
          (if (= i 0)
              a
              (fact (- i 1) (* a i))))))
#+end_src

    Аналогичная проблема заключается в вычислении n-го числа Фибоначчи для данного ~n~. Числа Фибоначчи представляют
    собой бесконечную последовательность целых чисел 0, 1, 1, 2, 3, 5, 8 и т. д., в которой каждое число является суммой
    двух предыдущих чисел в последовательности. Процедура вычисления n-го числа Фибоначчи наиболее естественно
    определяется рекурсивно следующим образом.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (let fib ([i n])
          (cond
            [(= i 0) 0]
            [(= i 1) 1]
            [else (+ (fib (- i 1)) (fib (- i 2)))]))))

    (fibonacci 0) → 0
    (fibonacci 1) → 1
    (fibonacci 2) → 1
    (fibonacci 3) → 2
    (fibonacci 4) → 3
    (fibonacci 5) → 5
    (fibonacci 6) → 8
    (fibonacci 20) → 6765
    (fibonacci 30) → 832040
#+end_src

    Это решение требует вычисления двух предыдущих чисел Фибоначчи на каждом шаге и, следовательно, является дважды
    рекурсивным. Например, для вычисления ~(fibonacci 4)~ требуется вычисление обоих ~(fib 3)~ и ~(fib 2)~, для
    вычисления ~(fib 3)~ требуется вычисление как ~(fib 2)~ и ~(fib 1)~, так и для вычисления ~(fib 2)~ требуется
    вычисление как ~(fib 1)~, так и ~(fib 0)~. Это очень неэффективно и становится все более неэффективным с ростом
    ~n~. Более эффективное решение состоит в том, чтобы адаптировать решение с аккумулятором из приведенного выше
    примера факториала, чтобы использовать два аккумулятора, ~a1~ для текущего числа Фибоначчи и ~a2~ для предыдущего.

#+begin_src scheme
    (define fibonacci
      (lambda (n)
        (if (= n 0)
            0
            (let fib ([i n] [a1 1] [a2 0])
              (if (= i 1)
                  a1
                  (fib (- i 1) (+ a1 a2) a1))))))
#+end_src

    Здесь ноль рассматривается как особый случай, так как предшествующего значения нет. Это позволяет нам использовать
    один базовый случай ~(= i 1)~. Время, необходимое для вычисления n-го числа Фибоначчи с использованием этого
    итеративного решения, растет линейно с ростом ~n~, что существенно лучше по сравнению с дважды рекурсивной
    версией. Чтобы почувствовать разницу, попробуйте вычислить ~(fibonacci 35)~ и ~(fibonacci 40)~, используя оба
    определения, чтобы увидеть, сколько времени занимает каждое из них.

    Мы также можем почувствовать разницу, взглянув на трассировку для каждого на небольших входных данных. Первая
    трассировка ниже показывает вызовы ~fib~ в версии ~fibonacci~ без хвостовой рекурсии, со входом 5.

#+BEGIN_EXAMPLE
    |(fib 5)
    | (fib 4)
    | |(fib 3)
    | | (fib 2)
    | | |(fib 1)
    | | |1
    | | |(fib 0)
    | | |0
    | | 1
    | | (fib 1)
    | | 1
    | |2
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | 3
    | (fib 3)
    | |(fib 2)
    | | (fib 1)
    | | 1
    | | (fib 0)
    | | 0
    | |1
    | |(fib 1)
    | |1
    | 2
    |5
#+END_EXAMPLE

    Обратите внимание, что есть несколько вызовов ~fib~ с аргументами 2, 1 и 0. Вторая трассировка показывает вызовы
    ~fib~ в хвостовой рекурсивной версии, опять же с 5 на входе.

#+BEGIN_EXAMPLE
    |(fib 5 1 0)
    |(fib 4 1 1)
    |(fib 3 2 1)
    |(fib 2 3 2)
    |(fib 1 5 3)
    |5
#+END_EXAMPLE

    Очевидно, что есть большая разница.

    Примеры с именованным ~let~, показанные до сих пор, были либо хвост-рекурсивными, либо не хвост-рекурсивными. Часто
    случается, что один рекурсивный вызов в одном и том же выражении является хвостово-рекурсивным, а другом -
    нет. Определение ~factor~ ниже вычисляет простые множители его неотрицательного целочисленного аргумента. Первый
    вызов ~f~ не хвост-рекурсивный, но второй - да.

#+begin_src scheme
    (define factor
      (lambda (n)
        (let f ([n n] [i 2])
          (cond
            [(>= i n) (list n)]
            [(integer? (/ n i))
             (cons i (f (/ n i) i))]
            [else (f n (+ i 1))]))))
#+end_src

#+begin_src scheme
    (factor 0) → (0)
    (factor 1) → (1)
    (factor 12) → (2 2 3)
    (factor 3628800) → (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
    (factor 9239) → (9239)
#+end_src

    Трассировка вызовов ~f~, произведенная в Chez Scheme путем замены ~let~ на ~trace-let~, при выполнении ~(factor
    120)~ ниже подчеркивает разницу между нехвостыми и хвостовыми вызовами.

#+BEGIN_EXAMPLE
    |(f 120 2)
    | (f 60 2)
    | |(f 30 2)
    | | (f 15 2)
    | | (f 15 3)
    | | |(f 5 3)
    | | |(f 5 4)
    | | |(f 5 5)
    | | |(5)
    | | (3 5)
    | |(2 3 5)
    | (2 2 3 5)
    |(2 2 2 3 5)
#+END_EXAMPLE

    Нехвостовой вызов ~f~ отображается с отступом относительно уровня, на котором его вызвали, поскольку вызывающий все
    еще активен, тогда как хвостовые вызовы отображаются на том же уровне отступа.

**** Упражнение 3.2.1

     Какие из рекурсивных процедур, определенных в разделе 3.2, являются хвостово-рекурсивными, а какие нет?

**** Упражнение 3.2.2

     Перепишите ~factor~, используя ~letrec~, чтобы связать ~f~ вместо именованного ~let~. Какую версию вы предпочитаете?

**** Упражнение 3.2.3

     Можно ли переписать приведенное ниже выражение ~letrec~, используя именованный ~let~? Если нет, то почему? Если да,
     то сделайте это.

#+begin_src scheme
     (letrec ([even?
               (lambda (x)
                 (or (= x 0)
                     (odd? (- x 1))))]
              [odd?
               (lambda (x)
                 (and (not (= x 0))
                      (even? (- x 1))))])
       (even? 20))
#+end_src

**** Упражнение 3.2.4

     Перепишите оба определения ~fibonacci~, приведенные в этом разделе, чтобы подсчитать количество рекурсивных вызовов
     ~fib~, используя счетчик, аналогичный тому, который использовался в примере с ~cons-count~ в разделе
     2.9. Подсчитайте количество рекурсивных вызовов, сделанных в каждом случае для различных входных значений. Что вы
     заметили?

**** Упражнение 3.2.5

     Дополните определение ~let~, данное в Разделе 3.1, для обработки именованных ~let~ и ~let~ без имен, используя два
     правила.

**** Упражнение 3.2.6

     Следующее определение ~or~ проще, чем приведенное в разделе 3.1.

#+begin_src scheme
     (define-syntax or ; incorrect!
       (syntax-rules ()
         [(_) #f]
         [(_ e1 e2 ...)
          (let ([t e1])
            (if t t (or e2 ...)))]))
#+end_src

     Поясните, почему это не правильно. [Подсказка: подумайте, что бы произошло, если бы эта версия или использовалась в
     ~even?~ и ~odd?~ для особенно больших значений на входе?]

**** Упражнение 3.2.7

     Определение ~factor~ не является наиболее эффективным из возможных. Во-первых, никакие множители ~n~, кроме самого
     ~n~, невозможно найти за пределами значения корня из ~n~. Во-вторых, деление ~(/ n i)~ выполняется дважды, когда
     множитель найден. В-третьих, после 2, никаких чётных множителей найдено быть не может. Перепишите ~factor~, чтобы
     исправить все три проблемы. Какая из этих проблем самая важная? Есть ли дополнительные улучшения, которые вы можете
     сделать?

*** Продолжения

    Во время выполнения выражения Scheme, реализация должна отслеживать две вещи: (1) что выполнять и (2) что делать со
    значением. Рассмотрим выполнение ~(null? x)~ в выражении ниже.

#+begin_src scheme
    (if (null? x) (quote ()) (cdr x))
#+end_src

    Реализация должна сначала выполнить ~(null? x)~ и, основываясь на его значении, выполнить либо ~(quote ())~, либо
    ~(cdr x)~. "Что выполнять" - это ~(null? x)~, а "что делать со значением" - это принимать решение, какое из
    выражений, ~(quote ())~ или ~(cdr x)~ выполнить. Мы называем "что делать со значением" /продолжением/ вычисления.

    Таким образом, в любой точке во время вычисления любого выражения есть продолжение, готовое завершить или, по
    крайней мере, продолжить вычисление с этой точки. Предположим, что ~x~ имеет значение ~(a b c)~. Мы можем выделить
    шесть продолжений во время выполнения ~(если (null? X) (quote ()) (cdr x))~, продолжения ожидают

    1. значение ~(if (null? x) (quote ()) (cdr x))~,
    2. значение ~(null? х)~,
    3. значение ~null?~,
    4. значение ~х~,
    5. значение ~cdr~, и
    6. значение ~х~ (снова).

    Продолжение ~(cdr x)~ не указано в списке, поскольку оно совпадает с продолжением ~(if (null? X) (quote ()) (cdr
    x))~.

    Scheme позволяет фиксировать продолжение любого выражения с помощью процедуры ~call/cc~. ~call/cc~ должна быть
    передана процедура ~p~ с одним аргументом. ~call/cc~ создает конкретное представление текущего продолжения и
    передает его в ~p~. Само продолжение представлено процедурой ~k~. Каждый раз, когда ~k~ применяется к значению, оно
    возвращает значение в продолжение от вызова ~call/cc~. Это значение становится, по сути, значением вызова ~call/cc~
    (результатом).

    Если ~p~ возвращается без вызова ~k~, значение, возвращаемое процедурой, становится значением приложения ~call/cc~.

    Рассмотрим простые примеры ниже.

#+begin_src scheme
    (call/cc
      (lambda (k)
        (* 5 4))) → 20

    (call/cc
      (lambda (k)
        (* 5 (k 4)))) → 4

    (+ 2
       (call/cc
         (lambda (k)
           (* 5 (k 4))))) → 6
#+end_src

    В первом примере продолжение захватывается и связывается с ~k~, но ~k~ никогда не используется, поэтому результатом
    является просто произведением 5 и 4. Во втором, продолжение вызывается перед умножением, поэтому результатом
    является значение, переданное в продолжение, 4. В третьем продолжение дополнено сложением с 2; таким образом,
    результат - это значение, переданное продолжению 4 плюс 2.

    Вот менее тривиальный пример, показывающий использование ~call/cc~ для обеспечения нелокального выхода из рекурсии.

#+begin_src scheme
    (define product
      (lambda (ls)
        (call/cc
          (lambda (break)
            (let f ([ls ls])
              (cond
                [(null? ls) 1]
                [(= (car ls) 0) (break 0)]
                [else (* (car ls) (f (cdr ls)))]))))))

    (product '(1 2 3 4 5)) → 120
    (product '(7 3 8 0 1 9 5)) → 0
#+end_src

    Нелокальный выход позволяет ~product~ возвращать результат немедленно, без выполнения остальных умножений, при
    обнаружении нулевого значения.

    Каждый из приведенных выше вызовов продолжения возвращается к продолжению, в то время как управление остается в
    пределах процедуры, переданной в ~call/cc~. В следующем примере используется продолжение после того, как эта
    процедура уже вернула значение.

#+begin_src scheme
    (let ([x (call/cc (lambda (k) k))])
      (x (lambda (ignore) "hi"))) → "hi"
#+end_src

    Продолжение, захваченное этим вызовом ~call/cc~, может быть описано как "возьмите значение, свяжите его с ~x~ и
    примени значение ~x~ к значению ~(lambda (ignore) "hi")~". Поскольку ~(lambda (k) k)~ возвращает свой аргумент, ~x~
    связан с самим продолжением; это продолжение применяется к процедуре, полученной в результате выполнения ~(lambda
    (ignore) "hi")~ . Это имеет эффект привязки ~x~ (снова!) к этой процедуре и применения процедуры к себе. Процедура
    игнорирует свой аргумент и возвращает "hi".

    Следующий вариант приведенного выше примера, вероятно, является самой запутанной программой Scheme своего размера;
    может быть легко догадаться, что он возвращает, но нужно подумать, почему.

#+begin_src scheme
    (((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") → "HEY!"
#+end_src

    Значение ~call/cc~ является его собственным продолжением, как в предыдущем примере. Это применяется к процедуре
    возвращающей свой аргумент ~(lambda (x) x)~, поэтому ~call/cc~ возвращается второй раз с этим значением. Затем
    процедура, возвращающая свой аргумент, применяется к себе, возвращая процедуру, возвращающую свой аргумент. Наконец,
    это применяется к "HEY!", В результате получается "HEY!".

    Продолжения, используемые таким образом, не всегда так озадачивают. Рассмотрим следующее определение факториала,
    которое сохраняет продолжение в основе рекурсии перед возвратом 1, присваивая его переменной верхнего уровня
    ~retry~.

#+begin_src scheme
    (define retry #f)

    (define factorial
      (lambda (x)
        (if (= x 0)
            (call/cc (lambda (k) (set! retry k) 1))
            (* x (factorial (- x 1))))))
#+end_src

    С этим определением ~factorial~ работает так, как мы ожидаем от факториала, за исключением того, что он имеет
    побочный эффект назначения повторных попыток.

#+begin_src scheme
    (factorial 4) → 24
    (retry 1) → 24
    (retry 2) → 48
#+end_src

    Продолжение, связанное с ~retry~, может быть описано как «Умножьте значение на 1, затем умножьте этот результат на
    2, затем умножьте этот результат на 3, а затем умножьте этот результат на 4». Если мы передадим продолжению другое
    значение, т. е. не 1, мы заставим базовое значение отличаться от 1 и, следовательно, изменим конечный результат.

#+begin_src scheme
    (retry 2) → 48
    (retry 5) → 120
#+end_src

    Этот механизм может быть основой для пакета точек останова, реализованного с помощью ~call/cc~; каждый раз, когда
    встречается точка останова, продолжение точки останова сохраняется, так что вычисление может быть перезапущено с
    точки останова (более одного раза, если это необходимо).

    Продолжения могут быть использованы для реализации различных форм многозадачности. Простой механизм «облегченного
    процесса», определенный ниже, позволяет чередовать несколько вычислений. Поскольку он не является вытесняющим, он
    требует, чтобы каждый процесс время от времени добровольно «приостанавливался», чтобы другие могли работать.

#+begin_src scheme
    (define lwp-list '())
    (define lwp
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))

    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))

    (define pause
      (lambda ()
        (call/cc
          (lambda (k)
            (lwp (lambda () (k #f)))
            (start)))))
#+end_src

    Следующие легкие процессы взаимодействуют, чтобы напечатать бесконечную последовательность строк, содержащих "hey!".

#+begin_src scheme
    (lwp (lambda () (let f () (pause) (display "h") (f))))
    (lwp (lambda () (let f () (pause) (display "e") (f))))
    (lwp (lambda () (let f () (pause) (display "y") (f))))
    (lwp (lambda () (let f () (pause) (display "!") (f))))
    (lwp (lambda () (let f () (pause) (newline) (f))))
    (start) → hey!
              hey!
              hey!
              hey!
              ...
#+end_src

    См. Раздел 12.11 для реализации механизмов, которые поддерживают вытесняющую многозадачность, с ~call/cc~.

**** Упражнение 3.3.1

     Используйте ~call/cc~, чтобы написать программу, которая зацикливается бесконечно, печатая последовательность
     чисел, начинающуюся с нуля. Не используйте никаких рекурсивных процедур и не используйте никаких присвоений.

**** Упражнение 3.3.2

     Перепишите ~product~ без ~call/cc~, сохранив функцию, при которой лишнее умножения не выполняются, если любой из
     элементов списка равен нулю.

**** Упражнение 3.3.3

     Что произойдет, если процесс, созданный ~lwp~, как определено выше, завершится, то есть просто вернет значение без
     вызова ~pause~? Определите процедуру выхода, которая позволяет завершать процесс, не влияя иначе на систему ~lwp~.
     Обязательно разберитесь со случаем, когда единственный оставшийся процесс завершается.

**** Упражнение 3.3.4

     Каждый раз, когда вызывается ~lwp~, список процессов копируется, потому что ~lwp~ использует ~append~ для
     добавления своего аргумента в конец списка процессов. Измените исходный код ~lwp~, чтобы использовать тип данных
     очереди, разработанный в разделе 2.9, чтобы избежать этой проблемы.

**** Упражнение 3.3.5

     Механизм облегченных процессов позволяет создавать новые процессы динамически, хотя пример, приведенный в этом
     разделе, этого не делает. Придумайте приложение, которое требует динамического создания новых процессов, и
     реализцйте его, используя механизм облегченных процессов.

*** Стиль передачи продолжений

    Как мы уже говорили в предыдущем разделе, продолжение ожидает значения каждого выражения. В частности, продолжения
    связанные с каждым вызовом процедуры. Когда одна процедура вызывает другую посредством нехвостого вызова, вызываемая
    процедура получает неявное продолжение, которое отвечает за завершение того, что осталось от тела вызывающей
    процедуры, плюс возврат к продолжению вызывающей процедуры. Если вызов является хвостовым, вызываемая процедура
    просто получает продолжение вызывающей процедуры.

    Мы можем сделать продолжения явными, заключив "что делать" в явный процедурный аргумент, передаваемый при каждом
    вызове. Например, продолжение вызова ~f~ в

#+begin_src scheme
    (letrec ([f (lambda (x) (cons 'a x))]
             [g (lambda (x) (cons 'b (f x)))]
             [h (lambda (x) (g (cons 'c x)))])
      (cons 'd (h '()))) → (d b a c)
#+end_src

    помещает символ ~b~ в возвращаемое ему значение, а затем возвращает результат этих объединений в продолжение вызова
    ~g~. Это продолжение аналогично продолжению вызова ~h~, который помещает символ ~d~ в возвращаемое ему значение. Мы
    можем переписать это в стиле передачи продолжения, или /CPS/ (англ. continuation-passing style, стиль передачи
    продолжений), заменив эти неявные продолжения явными процедурами.

#+begin_src scheme
    (letrec ([f (lambda (x k) (k (cons 'a x)))]
             [g (lambda (x k)
                  (f x (lambda (v) (k (cons 'b v)))))]
             [h (lambda (x k) (g (cons 'c x) k))])
      (h '() (lambda (v) (cons 'd v))))
#+end_src

    Как и неявное продолжение ~h~ и ~g~ в предыдущем примере, явное продолжение передается в ~h~ и ~g~,

#+begin_src scheme
    (lambda (v) (cons 'd v))
#+end_src

    добавляет символ ~d~ в значение, переданное ему. Аналогично, продолжение переданное ~f~,

#+begin_src scheme
    (lambda (v) (k (cons 'b v)))
#+end_src

    добавляет ~b~ в переданное ему значение, а затем передает это в продолжение ~g~.

    Выражения, написанные на CPS, конечно, сложнее, но у этого стиля программирования есть несколько полезных
    приложений. CPS позволяет процедуре передать более одного результата своему продолжению, поскольку процедура,
    реализующая продолжение, может принимать любое количество аргументов.

#+begin_src scheme
    (define car&cdr
      (lambda (p k)
        (k (car p) (cdr p))))

    (car&cdr '(a b c)
      (lambda (x y)
        (list y x))) → ((b c) a)
    (car&cdr '(a b c) cons) → (a b c)
    (car&cdr '(a b c a d) memv) → (a d)
#+end_src

    (Это также может быть сделано с несколькими значениями; см. Раздел 5.8.) CPS также позволяет процедуре принимать
    отдельные продолжения "успех" и "неудача", которые могут принимать различное количество аргументов. Примером
    является целочисленное деление ниже, которое передает частное и остаток первых двух аргументов своему третьему, если
    только второй аргумент (делитель) не равен нулю, и в этом случае он передает сообщение об ошибке своему четвертому
    аргументу.

#+begin_src scheme
    (define integer-divide
      (lambda (x y success failure)
        (if (= y 0)
            (failure "divide by zero")
            (let ([q (quotient x y)])
              (success q (- x (* q y)))))))

    (integer-divide 10 3 list (lambda (x) x)) → (3 1)
    (integer-divide 10 0 list (lambda (x) x)) → "divide by zero"
#+end_src

    Процедура ~quotient~, используемая в ~integer-divide~, возвращает частное от двух его аргументов, усеченных до нуля.

    Явные продолжения для успеха и неудачи иногда могут помочь избежать дополнительной коммуникации, необходимой для
    отделения успешного выполнения процедуры от неудачного выполнения. Кроме того, возможно иметь несколько успешных или
    неудачных продолжений для разных разновидностей успеха или неудачи, каждый из которых может принимать разное число и
    тип аргументов. См. разделы 12.10 и 12.11 для расширенных примеров, которые используют стиль передачи продолжения.

    В этот момент вы можете задаться вопросом о связи между CPS и продолжениями, записанными через
    ~call/cc~. Оказывается, что любая программа, использующая ~call/cc~, может быть переписана в CPS без ~call/cc~, но
    может потребоваться полное переписывание программы (иногда даже с учетом системных примитивов). Попробуйте
    преобразовать пример ~product~ из главы 3.3 в CPS, прежде чем смотреть на версию ниже.

#+begin_src scheme
    (define product
      (lambda (ls k)
        (let ([break k])
          (let f ([ls ls] [k k])
            (cond
              [(null? ls) (k 1)]
              [(= (car ls) 0) (break 0)]
              [else (f (cdr ls)
                       (lambda (x)
                         (k (* (car ls) x))))])))))

    (product '(1 2 3 4 5) (lambda (x) x)) → 120
    (product '(7 3 8 0 1 9 5) (lambda (x) x)) → 0
#+end_src

**** Упражнение 3.4.1

     Перепишите пример ~reciprocal~, впервые приведенный в Разделе 2.1, чтобы принимать как успешные, так и неудачные
     продолжения, как это сделано в ~integer-divide~ выше.

**** Упражнение 3.4.2

     Перепишите пример с ~retry~ используя CPS.

**** Упражнение 3.4.3

     Перепишите следующее выражение в CPS, чтобы избежать использования ~call/cc~.

#+begin_src scheme
     (define reciprocals
       (lambda (ls)
         (call/cc
           (lambda (k)
             (map (lambda (x)
                    (if (= x 0)
                        (k "zero found")
                        (/ 1 x)))
                  ls)))))

     (reciprocals '(2 1/3 5 1/4)) → (1/2 3 1/5 4)
     (reciprocals '(2 1/3 0 5 1/4)) → "zero found"
#+end_src

*** Внутренние объявления

    В разделе 2.6 мы обсудили определения верхнего уровня. Определения могут также появляться в начале тела
    лямбда-выражения, ~let~ или ~letrec~, и в этом случае создаваемые ими привязки являются локальными для тела.

#+begin_src scheme
    (define f (lambda (x) (* x x)))
    (let ([x 3])
      (define f (lambda (y) (+ y x)))
      (f 4)) → 7
    (f 4) → 16
#+end_src

    Процедуры, связанные внутренними определениями, могут быть взаимно рекурсивными, как с ~letrec~. Например, мы можем
    переписать ~even?~ и ~odd?~ из примера из раздела 3.2 с использованием внутренних определений следующим образом.

#+begin_src scheme
    (let ()
      (define even?
        (lambda (x)
          (or (= x 0)
              (odd? (- x 1)))))
      (define odd?
        (lambda (x)
          (and (not (= x 0))
               (even? (- x 1)))))
      (even? 20)) → #t
#+end_src

    Точно так же мы можем заменить использование ~letrec~ для связывания ~race~ внутренним определением ~race~ в нашем
    первом определении ~list?~.

#+begin_src scheme
    (define list?
      (lambda (x)
        (define race
          (lambda (h t)
            (if (pair? h)
                (let ([h (cdr h)])
                  (if (pair? h)
                      (and (not (eq? h t))
                           (race (cdr h) (cdr t)))
                      (null? h)))
                (null? h))))
        (race x x)))
#+end_src

    Фактически, внутреннее определение переменных и ~letrec~ практически взаимозаменяемы. Единственная разница, кроме
    очевидной разницы в синтаксисе, состоит в том, что определения переменных гарантированно будут выполняться слева
    направо, а связывания ~letrec~ могут выполняться в любом порядке. Поэтому мы не можем полностью заменить тело
    лямбда-выражения, ~let~ или ~letrec~, содержащие внутренние определения, выражением ~letrec~. Однако мы можем
    использовать ~letrec*~, который, как и ~let*~, гарантирует порядок выполнения слева направо. Тело следующего вида

#+begin_src scheme
    (define var expr0)
    ...
    expr1
    expr2
    ...
#+end_src

    эквивалентно выражению ~letrec*~, связывающему определенные переменные со ассоциативными значениями в теле,
    содержащем выражения.

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    И наоборот, ~letrec*~ вида

#+begin_src scheme
    (letrec* ((var expr0) ...) expr1 expr2 ...)
#+end_src

    может быть заменено выражением ~let~, содержащим внутренние определения и выражения из тела следующим образом.

#+begin_src scheme
    (let ()
      (define var expr0)
      ...
      expr1
      expr2
      ...
    )
#+end_src

    Кажущееся отсутствие симметрии между этими преобразованиями связано с тем, что выражения ~letrec*~ могут появляться
    везде, где выражение допустимо, тогда как внутренние определения могут появляться только в начале тела. Таким
    образом, заменяя ~letrec*~ внутренними определениями, мы обычно должны вводить выражение ~let~ для хранения
    определений.

    Другое различие между внутренними определениями и ~letrec~ или ~letrec*~ заключается в том, что синтаксические
    определения могут появляться среди внутренних определений, тогда как ~letrec~ и ~letrec*~ связывают только
    переменные.

#+begin_src scheme
    (let ([x 3])
      (define-syntax set-x!
        (syntax-rules ()
          [(_ e) (set! x e)]))
      (set-x! (+ x x))
      x) → 6
#+end_src

    Область действия синтаксического расширения, созданного внутренним определением синтаксиса, так же как и область
    определения внутренней переменной, ограничены телом, в котором появляется определение.

    Внутренние определения могут использоваться вместе с определениями и назначениями верхнего уровня, что помогает
    разбивать программаму на модули. Каждый модуль программы должен делать видимыми только те привязки, которые нужны
    другим модулям, в то же время скрывая другие привязки, которые в противном случае загромождают пространство имен
    верхнего уровня и, возможно, приводят к непреднамеренному использованию или переопределению этих привязок. Общий
    способ структурирования модуля показан ниже.

#+begin_src scheme
    (define export-var #f)
     ...
    (let ()
      (define var expr)
       ...
      init-expr
       ...
      (set! export-var export-val)
       ...
    )
#+end_src

    Первый набор определений устанавливает привязки верхнего уровня для переменных, которые мы хотим экспортировать
    (сделать видимыми глобально). Второй набор определений устанавливает локальные привязки, видимые только внутри
    модуля. Выражения ~init-expr ...~ выполняют любую инициализацию, которая должна произойти после установления
    локальных связываний. Наконец ~set!~ выражения присваивают экспортируемым переменным соответствующие значения.

    Преимущество этой формы модульности заключается в том, что охватывающее выражение ~let~ может быть удалено или
    закомментировано во время разработки программы, что делает внутренние определения определениями верхнего уровня, для
    облегчения интерактивного тестирования. Эта форма модульности также имеет несколько недостатков, как мы обсудим в
    следующем разделе.

    Следующий модуль экспортирует одну переменную ~calc~, которая связана с процедурой, реализующей простой
    четырехфункциональный калькулятор.

#+begin_src scheme
    (define calc #f)
    (let ()
      (define do-calc
        (lambda (ek expr)
          (cond
            [(number? expr) expr]
            [(and (list? expr) (= (length expr) 3))
             (let ([op (car expr)] [args (cdr expr)])
               (case op
                 [(add) (apply-op ek + args)]
                 [(sub) (apply-op ek - args)]
                 [(mul) (apply-op ek * args)]
                 [(div) (apply-op ek / args)]
                 [else (complain ek "invalid operator" op)]))]
            [else (complain ek "invalid expression" expr)])))
      (define apply-op
        (lambda (ek op args)
          (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
      (define complain
        (lambda (ek msg expr)
          (ek (list msg expr))))
      (set! calc
        (lambda (expr)
          ; grab an error continuation ek
          (call/cc
            (lambda (ek)
              (do-calc ek expr))))))

    (calc '(add (mul 3 2) -4)) → 2
    (calc '(div 1/2 1/6)) → 3
    (calc '(add (mul 3 2) (div 4))) → ("invalid expression" (div 4))
    (calc '(mul (add 1 -2) (pow 2 7))) → ("invalid operator" pow)
#+end_src

    В этом примере используется выражение ~case~, чтобы определить, какой оператор применить. ~case~ аналогичен ~cond~,
    за исключением того, что тест всегда одинаков: ~(memv val (key ...))~, где ~val~ - значение первой подформы ~case~,
    а ~(key ...)~ - список элементов в начале каждого случая ~case~. Выражение ~case~ в приведенном выше примере можно
    переписать с помощью ~cond~ следующим образом.

#+begin_src scheme
    (let ([temp op])
      (cond
        [(memv temp '(add)) (apply-op ek + args)]
        [(memv temp '(sub)) (apply-op ek - args)]
        [(memv temp '(mul)) (apply-op ek * args)]
        [(memv temp '(div)) (apply-op ek / args)]
        [else (complain ek "invalid operator" op)]))
#+end_src

**** Упражнение 3.5.1

     Переопределите ~complain~ в примере ~calc~ как эквивалентное синтаксическое расширение.

**** Упражнение 3.5.2

     В примере ~calc~ продолжение ошибки ~ek~ передается при каждом вызове ~apply-op~, ~complain~ и
     ~do-calc~. Переместите определения ~apply-op~, ~complain~ и ~do-calc~ внутрь, насколько это необходимо, чтобы
     исключить аргумент ~ek~ из определений и применений этих процедур.

**** Упражнение 3.5.3

     Исключите ~call/cc~ из ~calc~ и перепишите ~complain~, чтобы вызвать исключение с использованием
     ~assertion-violation~.

**** Упражнение 3.5.4

     Расширьте ~calc~ для обработки унарных выражений ~minus~, например,

#+begin_src scheme
     (calc '(minus (add 2 3))) → -5
#+end_src

     и другие операторы на ваш выбор.

*** Библиотеки

    В конце предыдущего раздела мы обсудили форму модульности, которая включает в себя присвоение набора переменных
    верхнего уровня из ~let~, сохраняя неопубликованные помощники локальными для ~let~. Эта форма модульности имеет
    несколько недостатков:

    + Это непереносимо, потому что поведение и даже существование интерактивного верхнего уровня не гарантируется
      Revised6 Report.
    + Это требует назначений, которые делают код несколько неуклюжим и могут препятствовать анализу и оптимизации
      компилятора.
    + Он не поддерживает публикацию привязки ключевых слов, так как нет аналога ~set!~ для ключевых слов.

    Альтернативой, которая не разделяет эти недостатки, является создание библиотеки. Библиотека экспортирует набор
    идентификаторов, каждый из которых определен в библиотеке или импортирован из какой-либо другой
    библиотеки. Экспортированный идентификатор не обязательно должен быть связан как переменная; вместо этого он может
    быть связан как ключевое слово.

    Следующая библиотека экспортирует два идентификатора: переменная ~gpa->grade~ и ключевое слово ~gpa~. Переменная
    ~gpa->grade~ связана с процедурой, которая принимает средний балл (GPA), представленный в виде числа, и возвращает
    соответствующую буквенную оценку по четырехбалльной шкале. Ключевое слово ~gpa~ называет синтаксическое расширение,
    чьи подчиненные формы должны быть буквенными оценками, а значение - это GPA, вычисленный из этих буквенных оценок.

#+begin_src scheme
    (library (grades)
      (export gpa->grade gpa)
      (import (rnrs))

      (define in-range?
        (lambda (x n y)
          (and (>= n x) (< n y))))

      (define-syntax range-case
        (syntax-rules (- else)
          [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...
               [else ee1 ee2 ...]))]
          [(_ expr ((x - y) e1 e2 ...) ...)
           (let ([tmp expr])
             (cond
               [(in-range? x tmp y) e1 e2 ...]
               ...))]))

      (define letter->number
        (lambda (x)
          (case x
            [(a)  4.0]
            [(b)  3.0]
            [(c)  2.0]
            [(d)  1.0]
            [(f)  0.0]
            [else (assertion-violation 'grade "invalid letter grade" x)])))

      (define gpa->grade
        (lambda (x)
          (range-case x
            [(0.0 - 0.5) 'f]
            [(0.5 - 1.5) 'd]
            [(1.5 - 2.5) 'c]
            [(2.5 - 3.5) 'b]
            [else 'a])))

      (define-syntax gpa
        (syntax-rules ()
          [(_ g1 g2 ...)
           (let ([ls (map letter->number '(g1 g2 ...))])
             (/ (apply + ls) (length ls)))])))
#+end_src

    Название библиотеки ~(grades)~. Это может показаться странным названием, но все имена библиотек заключены в
    скобки. Библиотека импортирует из стандартной библиотеки (rnrs), которая содержит большинство примитивов и привязок
    ключевых слов, которые мы использовали в этой и последней главе, и все, что нам нужно для реализации ~gpa->grade~ и
    ~gpa~.

    Наряду с ~gpa->grade~ и ~gpa~, в библиотеке определены несколько других синтаксических расширений и процедур, но ни
    одна из них не экспортируется. Те, которые не экспортируются, являются просто помощниками для тех, которые
    экспортируются. Все, что используется в библиотеке, должно быть знакомо, за исключением процедуры ~apply~, которая
    описана в главе 5.1.

    Если ваша реализация Scheme поддерживает импорт на интерактивном верхнем уровне, вы можете протестировать два
    экспорта, как показано ниже.

#+begin_src scheme
    (import (grades))
    (gpa c a c b b) → 2.8
    (gpa->grade 2.8) → b
#+end_src

    Глава 10 описывает библиотеки более подробно и предоставляет дополнительные примеры их использования.

**** Упражнение 3.6.1

     Измените ~gpa~ для обработки оценок "х", которые не учитываются в среднем балле. Будьте осторожны, чтобы изящно
     справиться с ситуацией, когда все оценки равны "x".

#+begin_src scheme
     (import (grades))
     (gpa a x b c) → 3.0
#+end_src

**** Упражнение 3.6.2

     Экспортируйте из ~(grades)~ новую синтаксическую форму, ~distribution~, которая принимает набор оценок, например,
     ~gpa~, но возвращает список вида ~((ng) ...)~, где ~n~ - количество раз, когда ~g~ появляется в наборе для каждой
     записи ~g~. Пусть ~distribution~ вызывает неэкспортированную процедуру для выполнения реальной работы.

#+begin_src scheme
     (import (grades))
     (distribution a b a c c c a f b a) → ((4 a) (2 b) (3 c) (0 d) (1 f))
#+end_src

**** Упражнение 3.6.3

     Теперь прочитайте об операциях вывода в Разделе 7.8 и определите новый экспорт, ~histogram~, как процедуру, которая
     принимает текстовый порт вывода и распределение, которое может быть произведено ~distribution~, и печатает
     гистограмму в стиле, проиллюстрированном примером ниже.

#+begin_src scheme
     (import (grades))
     (histogram
       (current-output-port)
       (distribution a b a c c a c a f b a))
#+end_src

     напечатает:

#+BEGIN_EXAMPLE
   a: *****
   b: **
   c: ***
   d:
   f: *
#+END_EXAMPLE


#+LATEX: \newpage
[[./images/ch4.png]]

** Связывания процедур и переменных

   Процедуры и привязки переменных являются основными строительными блоками Scheme программ. В этой главе описывается
   небольшой набор синтаксических форм, основной целью которых является создание процедур и управление привязками
   переменных. Он начинается с двух самых фундаментальных строительных блоков программ Scheme: ссылок на переменные и
   лямбда-выражений и продолжается описанием форм привязки и назначения переменных, таких как ~define~, ~letrec~,
   ~let-values~ и ~set!~.

   Различные другие формы, которые связывают или присваивают переменные, для которых привязка или присваивание не
   является основной целью (например, именованный ~let~), описаны в главе 5.

*** Ссылки на переменные

#+BEGIN_VERSE
    *синтаксис:* variable
    *возвращает:* значение переменной
#+END_VERSE

    Любой идентификатор, появляющийся как выражение в программе, является переменной, если существует видимая привязка
    переменной для идентификатора, например, идентификатор появляется в пределах области привязки, созданной при помощи
    ~define~, ~lambda~, ~let~ или другой конструкции привязки переменной.

#+begin_src scheme
list → #<procedure>
(define x 'a)
(list x x) → (a a)
(let ([x 'b])
  (list x x)) → (b b)
(let ([let 'let]) let) → let
#+end_src

    Это синтаксическое нарушение, когда ссылка на идентификатор появляется внутри формы ~library~ или программы
    верхнего уровня, если она не связана как переменная, ключевое слово, имя записи или другая сущность. В случае, если
    область определения это все тело, будь то библиотеки, программы верхнего уровня, лямбды или другого локального тела,
    нет необходимости, чтобы определение переменной появлялось до того, как появится первая ссылка на неё, если только
    не пытаться получить значение по ссылке, пока определение не будет завершено. Так, например, ссылка на ~g~ в
    определении ~f~ ниже

#+begin_src scheme
(define f
  (lambda (x)
    (g x)))
(define g
  (lambda (x)
    (+ x x)))
#+end_src

    это нормально, но ссылка на ~g~ в определении ~q~ ниже нет.

#+begin_src scheme
(define q (g 3))
(define g
  (lambda (x)
    (+ x x)))
#+end_src

*** Lambda

#+BEGIN_VERSE
    *синтаксис:* ~(lambda formals body1 body2 ...)~
    *возвращает:* процедуру
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    Синтаксическая форма ~lambda~ используется для создания процедур. Любая операция, которая создает процедуру или
    устанавливает привязки локальных переменных, в конечном итоге определяется в терминах ~lambda~ или ~case-lambda~.

    Переменные ~formals~ являются формальными параметрами процедуры, а последовательность подвыражений ~body1 body2 ...~
    является ее телом.

    Тело может начинаться с последовательности определений, и в этом случае привязки, созданные определениями, являются
    локальными для тела. Если определения присутствуют, привязки ключевых слов используются и отбрасываются при
    раскрытии тела, а тело ракрывается в выражение ~letrec*~, сформированного из определений переменных и оставшихся
    выражений. Остальная часть описания лямбда-выражения предполагает, что это преобразование имело место, если
    необходимо, так что тело является последовательностью выражений без определений.

    Когда процедура создана, привязки всех переменных, свободно встречающихся в теле, за исключением формальных
    параметров, сохраняются вместе с процедурой. Впоследствии всякий раз, когда процедура применяется к
    последовательности фактических параметров, формальные параметры привязываются к фактическим параметрам, сохраненные
    привязки восстанавливаются, и тело выполняется.

    При применении формальные параметры, ~formals~, привязываются к фактическим параметрам следующим образом.

    + Если ~formals~ - это правильный список переменных, например, ~(x y z)~, каждая переменная связывается с
      соответствующим фактическим параметром. Выбрасывается исключение с типом ~?&assertation~, если задано
      слишком мало или слишком много фактических параметров.
    + Если ~formals~ - это одна переменная (не из списка), например, ~z~, она привязывается к списку фактических
      параметров.
    + Если ~formals~ - это неправильный список переменных, оканчивающихся переменной, например, ~(x y. z)~, каждая
      переменная, кроме последней, связывается с соответствующим фактическим параметром. Последняя переменная
      связывается со списком оставшихся фактических параметров. Выбрасывается исключение с типом ~&assertation~, если
      предоставлено слишком мало фактических параметров.

    Когда тело выполняется, выражения в теле вычисляются последовательно, и процедура возвращает значения последнего
    выражения.

    Процедуры не имеют печатного представления в обычном смысле. Системы Scheme отображают процедуры по-разному; эта
    книга использует обозначение ~#<procedure>~.

#+begin_src scheme
(lambda (x) (+ x 3)) → #<procedure>
((lambda (x) (+ x 3)) 7) → 10
((lambda (x y) (* x (+ x y))) 7 13) → 140
((lambda (f x) (f x x)) + 11) → 22
((lambda () (+ 3 4))) → 7

((lambda (x . y) (list x y))
 28 37) → (28 (37))
((lambda (x . y) (list x y))
 28 37 47 28) → (28 (37 47 28))
((lambda (x y . z) (list x y z))
 1 2 3 4) → (1 2 (3 4))
((lambda x x) 7 13) → (7 13)
#+end_src

*** Case-Lambda

    Лямбда-выражение Scheme всегда создает процедуру с фиксированным числом аргументов или с неопределенным числом
    аргументов, большим или равным определенному числу. В частности,

#+begin_src scheme
(lambda (var1 ... varn) body1 body2 ...)
#+end_src

    принимает ровно ~n~ аргументов,

#+begin_src scheme
(lambda r body1 body2 ...)
#+end_src

    принимает ноль или более аргументов, и

#+begin_src scheme
(lambda (var1 ... varn . r) body1 body2 ...)
#+end_src

    принимает ~n~ или более аргументов.

    Однако лямбда не может напрямую произвести процедуру, которая принимает, скажем, два или три аргумента. В частности,
    процедуры, которые принимают необязательные аргументы, напрямую не поддерживаются лямбда-выражением. Последняя форма
    лямбды, показанная выше, может использоваться в сочетании с проверками длины и комбинациями ~car~ и ~cdr~ для
    реализации процедур с необязательными аргументами, хотя и за счет ясности и эффективности.

    Синтаксическая форма ~case-lambda~ напрямую поддерживает процедуры с необязательными аргументами, а также процедуры
    с фиксированным или неопределенным числом аргументов. ~case-lambda~ основана на синтаксической форме ~lambda*~,
    представленной в статье «Новый подход к процедурам с переменной арностью» [fn:11].

#+BEGIN_VERSE
    *синтаксис:* ~(case-lambda clause ...)~
    *возвращает:* процедуру
    *библиотеки:* ~(rnrs control)~, ~(rnrs)~
#+END_VERSE

    ~case-lambda~ выражение состоит из набора клауз, каждая из которых напоминает лямбда-выражение. Каждая клауза имеет
    форму, представленную ниже.

#+BEGIN_EXAMPLE
[formals body1 body2 ...]
#+END_EXAMPLE

    Формальные параметры клаузы определяются ~formals~ так же, как для лямбда-выражения. Количество аргументов,
    принимаемых ~case-clause~, определяется количеством аргументов, принимаемых отдельными клаузами.

    Когда вызывается процедура, созданная с помощью ~case-lambda~, клаузы проверяются на соответствие по
    порядку. Выбирается первая клаузы, которая принимает заданное количество фактических параметров, формальные
    параметры, определенные его формальными значениями, привязываются к соответствующим фактическим параметрам, и тело
    выполняется, как описано выше для лямбды. Если ~formals~ в клаузе - это правильный список идентификаторов, то клауза
    принимает ровно столько фактических параметров, сколько формальных параметров (идентификаторов) в ~formals~. Как и в
    случае ~formals~ для ~lambda~, в ~formals~ ~case-lambda~ выражений может быть один идентификатор, в этом случае
    клауза принимает любое количество аргументов, или неправильный список идентификаторов, оканчивающийся
    идентификатором, и в этом случае клауза принимает любое количество аргументов, большее или равное количеству
    формальных параметров, исключая последний идентификатор. Если ни одна из клауз не принимает количество
    предоставленных фактических параметров, возникает исключение с типом ~&assertation~.

    Следующее определение для ~make-list~ использует ~case-lambda~ для поддержки необязательного параметра заполнителя.

#+begin_src scheme
(define make-list
  (case-lambda
    [(n) (make-list n #f)]
    [(n x)
     (do ([n n (- n 1)] [ls '() (cons x ls)])
         ((zero? n) ls))]))
#+end_src

    Процедура ~substring~ может быть расширена с помощью ~case-lambda~, чтобы принимать либо отсутствие конечного
    индекса, в этом случае по умолчанию используется конец строки, либо отсутствие начального и конечного индексов, в
    этом случае ~substring~ эквивалентна ~string-copy~:

#+begin_src scheme
(define substring1
  (case-lambda
    [(s) (substring1 s 0 (string-length s))]
    [(s start) (substring1 s start (string-length s))]
    [(s start end) (substring s start end)]))
#+end_src

    Также возможно по умолчанию использовать начальный индекс, а не конечный, если указан только один индекс:

#+begin_src scheme
(define substring2
  (case-lambda
    [(s) (substring2 s 0 (string-length s))]
    [(s end) (substring2 s 0 end)]
    [(s start end) (substring s start end)]))
#+end_src

    Можно даже потребовать, чтобы оба или ни один из начального и конечного индексов были предоставлены, просто
    опустив среднюю клаузу:

#+begin_src scheme
(define substring3
  (case-lambda
    [(s) (substring3 s 0 (string-length s))]
    [(s start end) (substring s start end)]))
#+end_src

*** Локальные связывания

#+BEGIN_VERSE
    *синтаксис:* ~(let ((var expr) ...) body1 body2 ...)~
    *возвращает:* значение последнего выражения в теле
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~let~ устанавливает привязки локальных переменных. Каждая переменная ~var~ связана со значением соответствующего
    выражения ~expr~. Тело ~let~, в котором связаны переменные, является последовательностью сабформ ~body1 body2 ...~ и
    обрабатывается и выполняется как тело лямбда-выражения.

    Формы ~let~, ~let*~, ~letrec~ и ~letrec*~ (остальные описаны после ~let~) похожи, но служат несколько разным
    целям. С ~let~, в отличие от ~let*~, ~letrec~ и ~letrec*~, выражения ~expr ...~ находятся вне области видимости
    переменных ~var ...~. Кроме того, в отличие от ~let*~ и ~letrec*~, упорядочение не подразумевается при выполнении
    выражений ~expr ...~. Они могут выполняться слева направо, справа налево или в любом другом порядке по усмотрению
    реализации. Используйте ~let~ всякий раз, когда значения не зависят от переменных, а порядок вычисления не важен.

#+begin_src scheme
(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])
  (sqrt (+ x y))) → 5.0

(let ([x 'a] [y '(b c)])
  (cons x y)) → (a b c)

(let ([x 0] [y 1])
  (let ([x y] [y x])
    (list x y))) → (1 0)
#+end_src

    Следующее определение ~let~ показывает типичное происхождение ~let~ из ~lambda~.

#+begin_src scheme
(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]))
#+end_src

    Другая форма ~let~, именованный ~let~, описана в разделе 5.4, а полное определение ~let~ можно найти в разделе 8.4.

#+BEGIN_VERSE
    *синтаксис:* ~(let* ((var expr) ...) body1 body2 ...)~
    *возвращает:* значение последнего выражения в теле
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~let*~ аналогичен ~let~, за исключением того, что выражения ~expr ...~ вычисляются в последовательности слева
    направо, и каждое из этих выражений находится в области видимости переменных слева. Используйте ~let*~, когда
    существует линейная зависимость между значениями или когда важен порядок выполнения.

#+begin_src scheme
(let* ([x (* 5.0 5.0)]
       [y (- x (* 4.0 4.0))])
  (sqrt y)) → 3.0

(let ([x 0] [y 1])
  (let* ([x y] [y x])
    (list x y))) → (1 1)
#+end_src

    Любое выражение ~let*~ может быть преобразовано во множество вложенных выражений ~let~. Следующее определение ~let*~
    демонстрирует типичное преобразование.

#+begin_src scheme
(define-syntax let*
  (syntax-rules ()
    [(_ () e1 e2 ...)
     (let () e1 e2 ...)]
    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)
     (let ((x1 v1))
       (let* ((x2 v2) ...) e1 e2 ...))]))
#+end_src

#+BEGIN_VERSE
    *синтаксис:* ~(letrec ((var expr) ...) body1 body2 ...)~
    *возвращает:* значение последнего выражения в теле
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~letrec~ аналогичен ~let~ и ~let*~, за исключением того, что все выражения ~expr ...~ находятся в области видимости
    всех переменных ~var ...~. ~letrec~ позволяет определять взаимно рекурсивные процедуры.

#+begin_src scheme
(letrec ([sum (lambda (x)
                (if (zero? x)
                    0
                    (+ x (sum (- x 1)))))])
  (sum 5)) → 15
#+end_src

    Порядок вычисления выражений ~expr ...~ не определен, поэтому программа не должна использовать ссылки на любую из
    переменных, связанных выражением ~letrec~, до того, как будут вычислены все значения. (Вхождение переменной в
    лямбда-выражение не считается ссылкой, если только результирующая процедура не будет применена до того, как будут
    вычислены все значения.) Если это ограничение нарушается, возникает исключение с типом ~&assertation~.

    ~expr~ не должен возвращать более одного раза. То есть оно не должен возвращать как обычно, так и через вызов
    продолжения, полученного во время его выполнения, и оно не должено возвращать дважды через два вызова такого
    продолжения. Реализации не обязаны обнаруживать нарушение этого ограничения, но если они это делают, возникает
    исключение с типом ~&assertation~.

    Выберайте ~letrec~ вместо ~let~ или ~let*~, когда существует круговая зависимость между переменными и их значениями
    и когда порядок выполнения не важен. Выберайте ~letrec*~ вместо ~letrec~, когда существует циклическая зависимость,
    и привязки должны выполняться слева направо.

    Выражение формы ~letrec~

#+begin_src scheme
(letrec ((var expr) ...) body1 body2 ...)
#+end_src

    может быть выражено в терминах ~let~ и ~set!~

#+begin_src scheme
(let ((var #f) ...)
  (let ((temp expr) ...)
    (set! var temp) ...
    (let () body1 body2 ...)))
#+end_src

    где ~temp ...~ - свежие переменные, то есть переменные, которые еще не присутствуют в выражении ~letrec~, по одной
    для каждой пары ~(var expr)~. Внешнее выражение ~let~ устанавливает привязки переменных. Начальное значение,
    заданное для каждой переменной неважно, поэтому вместо ~#f~ может быть любое значение. Привязки устанавливаются
    первыми, чтобы ~expr ...~ мог содержать вхождения переменных, то есть, чтобы выражения вычислялись в области
    видимости переменных. Среднее значение ~let~ вычисляет значения и связывает их с временными переменными и ~set!~
    выражение присваивают каждой переменной соответствующее значение. Внутренний ~let~ присутствует для случая, если
    тело содержит внутренние определения.

    Определение ~letrec~, которое использует это преобразование, показано в разделе 8.3.

    Это преобразование не налагает ограничения на то, что выражения ~expr~ не должны выполнять какие-либо ссылки на
    переменные или их присваивания. Возможны более сложные преобразования, которые усиливают это ограничение и
    фактически производят более эффективный код [fn:31].

#+BEGIN_VERSE
    *синтаксис:* ~(letrec* ((var expr) ...) body1 body2 ...)~
    *возвращает:* значение последнего выражения в теле
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~letrec*~ аналогичен ~letrec~, за исключением того, что ~letrec*~ вычисляет ~expr ...~ в последовательности слева
    направо. Хотя программы по-прежнему не должны использовать ссылку на какой-либо ~var~ до того, как соответствующий
    ~expr~ будет выполнен, ссылки на ~var~ могут быть выполнены в любое время после этого, в том числе во время
    выполнения ~expr~ любого последующего связывания.

    Форма выражения ~letrec*~

#+begin_src scheme
(letrec* ((var expr) ...) body1 body2 ...)
#+end_src

    может быть выражена в терминах ~let~ и ~set!~

#+begin_src scheme
(let ((var #f) ...)
  (set! var expr) ...
  (let () body1 body2 ...))
#+end_src

    Внешнее выражение ~let~ создает связывания, каждое присваивание выполняет выражение и сразу устанавливает
    соответствующей переменной его значение по порядку, а внутренний ~let~ выполняет тело. ~let~ используется в
    последнем случае, поскольку, как и выражения, тело может содержать и внутренние определения.

#+begin_src scheme
(letrec* ([sum (lambda (x)
                 (if (zero? x)
                     0
                     (+ x (sum (- x 1)))))]
          [f (lambda () (cons n n-sum))]
          [n 15]
          [n-sum (sum n)])
  (f)) → (15 . 120)

(letrec* ([f (lambda () (lambda () g))]
          [g (f)])
  (eq? (g) g)) → #t

(letrec* ([g (f)]
          [f (lambda () (lambda () g))])
  (eq? (g) g)) → exception: attempt to reference undefined variable f
#+end_src

*** Множественные значения

#+BEGIN_VERSE
    *синтаксис:* ~(let-values ((formals expr) ...) body1 body2 ...)~
    *синтаксис:* ~(let*-values ((formals expr) ...) body1 body2 ...)~
    *возвращает:* значение последнего выражения
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~let-values~ - это удобный способ получить несколько значений и связать их с переменными. Он структурирован как
    ~let~, но в произвольной структурой левой части формальных параметров (например, ~lambda~). ~let*-values~
    аналогична, но выполняет привязки в порядке слева направо, как и в случае ~let*~. Исключение с типом ~&assertation~
    возникает, если число значений, возвращаемых выражением, не соответствует списку формальных параметров, как для
    ~lambda~ выше. Определение допустимых значений приведено в разделе 8.3.

#+begin_src scheme
(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])
  (list a b c)) → (1 2 (1 2 3))

(let*-values ([(a b) (values 1 2)] [(a b) (values b a)])
  (list a b)) → (2 1)
#+end_src

*** Объявление переменных

#+BEGIN_VERSE
    *синтаксис:* ~(define var expr)~
    *синтаксис:* ~(define var)~
    *синтаксис:* ~(define (var0 var1 ...) body1 body2 ...)~
    *синтаксис:* ~(define (var0 . varr) body1 body2 ...)~
    *синтаксис:* ~(define (var0 var1 var2 ... . varr) body1 body2 ...)~
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    В первой форме ~define~ создает новое связывание ~var~ со значением ~expr~. ~expr~ не должен возвращать более одного раза. То есть оно не должен возвращать как обычно, так и через вызов
    продолжения, полученного во время его выполнения, и оно не должено возвращать дважды через два вызова такого
    продолжения. Реализации не обязаны обнаруживать нарушение этого ограничения, но если они это делают, возникает
    исключение с типом ~&assertation~.

    Вторая форма эквивалентна ~(define var unspecified)~, где ~unspecified~ - это некоторое неопределённое
    значение. Остальные - это сокращенные формы для привязки переменных к процедурам; они идентичны следующему
    определению с точки зрения ~lambda~.

#+begin_src scheme
(define var
  (lambda formals
    body1 body2 ...))
#+end_src

    где ~formals~ - это ~(var1 ...)~, ~varr~ или ~(var1 var2 .... varr)~ для третьего, четвертого и пятого форматов.

    Определения могут появляться в начале тела библиотеки, в любом месте среди форм тела программы верхнего уровня, и в
    начале тела ~lambda~ или ~case-lambda~ или тела любой формы, полученной из ~lambda~, например, ~let~, или ~letrec*~.
    Любое тело, начинающееся с последовательности определений, преобразуется во время раскрытия макроса в выражение
    ~letrec*~, как описано в главе 8.1.

    Определения синтаксиса могут появляться вместе с определениями переменных везде, где могут появляться определения
    переменных; см. главу 8.

#+begin_src scheme
(define x 3)
x → 3

(define f
  (lambda (x y)
    (* (+ x y) 2)))
(f 5 4) → 18

(define (sum-of-squares x y)
  (+ (* x x) (* y y)))
(sum-of-squares 3 4) → 25

(define f
  (lambda (x)
    (+ x 1)))
(let ([x 2])
  (define f
    (lambda (y)
      (+ y x)))
  (f 3)) → 5
(f 3) → 4
#+end_src

    Набор определений можно сгруппировать, заключив их в форму ~begin~. Определения, сгруппированные таким образом,
    могут появляться везде, где могут появляться определения обычных переменных и синтаксиса. Они интерпретируются так,
    как будто они написаны отдельно, то есть без заключения в форму ~begin~. Эта функция позволяет синтаксическим
    расширениям раскрываться в группу определений.

#+begin_src scheme
(define-syntax multi-define-syntax
  (syntax-rules ()
    [(_ (var expr) ...)
     (begin
       (define-syntax var expr)
       ...)]))
(let ()
  (define plus
    (lambda (x y)
        (if (zero? x)
            y
            (plus (sub1 x) (add1 y)))))
  (multi-define-syntax
    (add1 (syntax-rules () [(_ e) (+ e 1)]))
    (sub1 (syntax-rules () [(_ e) (- e 1)])))
  (plus 7 8)) → 15
#+end_src

    Многие реализации поддерживают интерактивный «верхний уровень», в котором переменные и другие определения могут
    вводиться интерактивно или загружаться из файлов. Поведение этих определений верхнего уровня выходит за рамки отчета
    ~Revised6~, но касаемо того, что переменные верхнего уровня должны быть определены до того, как будут испольоваться
    или присваиваться, поведение является согласованным в большинстве реализаций. Так, например, ссылка на ~g~ в
    определении верхнего уровня для ~f~ ниже допустима, и это нормально, если ~g~ еще не определено, и предполагается,
    что ~g~ это имя переменной, которая должна быть определена в какой-то более поздний момент.

#+begin_src scheme
(define f
  (lambda (x)
    (g x)))
#+end_src

    Если за этим следует определение ~g~, до выполнения ~f~, то предположение о том, что ~g~ будет определена как
    переменная, подтверждается, и вызов ~f~ работает, как и ожидалось.

#+begin_src scheme
(define g
  (lambda (x)
    (+ x x)))
(f 3) → 6
#+end_src

    Если вместо этого g было определено как ключевое слово для синтаксического расширения, предположение о том, что ~g~
    будет связана как переменная, окажется ложным, и если ~f~ не переопределено до его вызова, реализация, вероятно,
    вызовет исключение.

*** Присваивания

#+BEGIN_VERSE
    *синтаксис:* ~(set! var expr)~
    *возвращает:* unspecified
    *библиотеки:* ~(rnrs base)~, ~(rnrs)~
#+END_VERSE

    ~set!~ не устанавливает новую привязку для ~var~, а изменяет значение существующей привязки. Сначала он вычисляет
    ~expr~, а затем присваивает ~var~ значение ~expr~. Любая последующая ссылка на ~var~ в рамках измененной привязки
    возвращает новое значение.

    Назначения не используются так часто в Scheme, как в большинстве других языков, но они полезны для реализации
    изменений состояния.

#+begin_src scheme
(define flip-flop
  (let ([state #f])
    (lambda ()
      (set! state (not state))
      state)))

(flip-flop) → #t
(flip-flop) → #f
(flip-flop) → #t
#+end_src

    Назначения также полезны для кэширования значений. В приведенном ниже примере используется метод, называемый
    мемоизацией, в котором процедура записывает значения, связанные со старыми входными значениями, поэтому нет
    необходимости пересчитывать их, чтобы реализовать быструю версию экспоненциального двукратно рекурсивного
    определения функции Фибоначчи (см. Раздел 3.2).

#+begin_src scheme
(define memoize
  (lambda (proc)
    (let ([cache '()])
      (lambda (x)
        (cond
          [(assq x cache) => cdr]
          [else
           (let ([ans (proc x)])
             (set! cache (cons (cons x ans) cache))
             ans)])))))

(define fibonacci
  (memoize
    (lambda (n)
      (if (< n 2)
          1
          (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))

(fibonacci 100) → 573147844013817084101
#+end_src

#+LATEX: \newpage
[[./images/ch5.png]]

** Control Operations

   This chapter introduces the syntactic forms and procedures that serve as control structures for Scheme programs, The
   first section covers the most basic control structure, procedure application, and the remaining sections cover
   sequencing, conditional evaluation, recursion, mapping, continuations, delayed evaluation, multiple values, and
   evaluation of programs constructed at run time.

*** Procedure Application

#+BEGIN_VERSE
    *синтаксис:* (expr0 expr1 ...)
    *возвращает:* values of applying the value of expr0 to the values of expr1 ...
#+END_VERSE

    Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in
    the first position is a procedure application. The expressions expr0 and expr1 ... are evaluated; each should
    evaluate to a single value. After each of these expressions has been evaluated, the value of expr0 is applied to the
    values of expr1 .... If expr0 does not evaluate to a procedure, or if the procedure does not accept the number of
    arguments provided, an exception with condition type &assertion is raised.

    The order in which the procedure and argument expressions are evaluated is unspecified. It may be left to right,
    right to left, or any other order. The evaluation is guaranteed to be sequential, however: whatever order is chosen,
    each expression is fully evaluated before evaluation of the next is started.

#+begin_src scheme
(+ 3 4) → 7

((if (odd? 3) + -) 6 2) → 8

((lambda (x) x) 5) → 5

(let ([f (lambda (x) (+ x x))])
  (f 8)) → 16
#+end_src

#+BEGIN_VERSE
    *процедура:* (apply procedure obj ... list)
    *возвращает:* the values of applying procedure to obj ... and the elements of list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    apply invokes procedure, passing the first obj as the first argument, the second obj as the second argument, and so
    on for each object in obj ..., and passing the elements of list in order as the remaining arguments. Thus, procedure
    is called with as many arguments as there are objs plus elements of list.

    apply is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the
    programmer from explicitly destructuring the list.

#+begin_src scheme
(apply + '(4 5)) → 9

(apply min '(6 8 3 2 5)) → 2

(apply min  5 1 3 '(6 8 3 2 5)) → 1

(apply vector 'a 'b '(c d e)) → #(a b c d e)

(define first
  (lambda (ls)
    (apply (lambda (x . y) x) ls)))
(define rest
  (lambda (ls)
    (apply (lambda (x . y) y) ls)))
(first '(a b c d)) → a
(rest '(a b c d)) → (b c d)

(apply append
  '(1 2 3)
  '((a b) (c d e) (f))) → (1 2 3 a b c d e f)
#+end_src

*** Sequencing

#+BEGIN_VERSE
    *синтаксис:* (begin expr1 expr2 ...)
    *возвращает:* the values of the last subexpression
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The expressions expr1 expr2 ... are evaluated in sequence from left to right. begin is used to sequence assignments,
    input/output, or other operations that cause side effects.

#+begin_src scheme
(define x 3)
(begin
  (set! x (+ x 1))
  (+ x x)) → 8
#+end_src

    A begin form may contain zero or more definitions in place of the expressions expr1 expr2 ..., in which case it is
    considered to be a definition and may appear only where definitions are valid.

#+begin_src scheme
(let ()
  (begin (define x 3) (define y 4))
  (+ x y)) → 7
#+end_src

    This form of begin is primarily used by syntactic extensions that must expand into multiple definitions. (See page
    101.)

    The bodies of many syntactic forms, including lambda, case-lambda, let, let*, letrec, and letrec*, as well as the
    result clauses of cond, case, and do, are treated as if they were inside an implicit begin; i.e., the expressions
    making up the body or result clause are executed in sequence, with the values of the last expression being
    returned.

#+begin_src scheme
(define swap-pair!
  (lambda (x)
    (let ([temp (car x)])
      (set-car! x (cdr x))
      (set-cdr! x temp)
      x)))
(swap-pair! (cons 'a 'b)) → (b . a)
#+end_src

*** Conditionals

#+BEGIN_VERSE
    *синтаксис:* (if test consequent alternative)
    *синтаксис:* (if test consequent)
    *возвращает:* the values of consequent or alternative depending on the value of test
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The test, consequent, and alternative subforms must be expressions. If test evaluates to a true value (anything
    other than #f), consequent is evaluated and its values are returned. Otherwise, alternative is evaluated and its
    values are returned. With the second, "one-armed," form, which has no alternative, the result is unspecified if test
    evaluates to false.

#+begin_src scheme
(let ([ls '(a b c)])
  (if (null? ls)
      '()
      (cdr ls))) → (b c)

(let ([ls '()])
  (if (null? ls)
      '()
      (cdr ls))) → ()

(let ([abs
       (lambda (x)
         (if (< x 0)
             (- 0 x)
             x))])
  (abs -4)) → 4

(let ([x -4])
  (if (< x 0)
      (list 'minus (- 0 x))
      (list 'plus 4))) → (minus 4)
#+end_src

#+BEGIN_VERSE
    *процедура:* (not obj)
    *возвращает:* #t if obj is false, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    not is equivalent to (lambda (x) (if x #f #t)).

#+begin_src scheme
(not #f) → #t
(not #t) → #f
(not '()) → #f
(not (< 4 5)) → #f
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (and expr ...)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If no subexpressions are present, the and form evaluates to #t. Otherwise, and evaluates each subexpression in
    sequence from left to right until only one subexpression remains or a subexpression returns #f. If one subexpression
    remains, it is evaluated and its values are returned. If a subexpression returns #f, and returns #f without
    evaluating the remaining subexpressions. A syntax definition of and appears on page 62.

#+begin_src scheme
(let ([x 3])
  (and (> x 2) (< x 4))) → #t

(let ([x 5])
  (and (> x 2) (< x 4))) → #f

(and #f '(a b) '(c d)) → #f
(and '(a b) '(c d) '(e f)) → (e f)
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (or expr ...)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If no subexpressions are present, the or form evaluates to #f. Otherwise, or evaluates each subexpression in
    sequence from left to right until only one subexpression remains or a subexpression returns a value other than
    #f. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns a value
    other than #f, or returns that value without evaluating the remaining subexpressions. A syntax definition of or
    appears on page 63.

#+begin_src scheme
(let ([x 3])
  (or (< x 2) (> x 4))) → #f

(let ([x 5])
  (or (< x 2) (> x 4))) → #t

(or #f '(a b) '(c d)) → (a b)
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (cond clause1 clause2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    Each clause but the last must take one of the forms below.

#+begin_src scheme
(test)
(test expr1 expr2 ...)
(test => expr)
#+end_src

    The last clause may be in any of the above forms, or it may be an "else clause" of the form

#+begin_src scheme
(else expr1 expr2 ...)
#+end_src

    Each test is evaluated in order until one evaluates to a true value or until all of the tests have been
    evaluated. If the first clause whose test evaluates to a true value is in the first form given above, the value of
    test is returned.

    If the first clause whose test evaluates to a true value is in the second form given above, the expressions expr1
    expr2... are evaluated in sequence and the values of the last expression are returned.

    If the first clause whose test evaluates to a true value is in the third form given above, the expression expr is
    evaluated. The value should be a procedure of one argument, which is applied to the value of test. The values of
    this application are returned.

    If none of the tests evaluates to a true value and an else clause is present, the expressions expr1 expr2 ... of the
    else clause are evaluated in sequence and the values of the last expression are returned.

    If none of the tests evaluates to a true value and no else clause is present, the value or values are unspecified.

    See page 305 for a syntax definition of cond.

#+begin_src scheme
(let ([x 0])
  (cond
    [(< x 0) (list 'minus (abs x))]
    [(> x 0) (list 'plus x)]
    [else (list 'zero x)])) → (zero 0)

(define select
  (lambda (x)
    (cond
      [(not (symbol? x))]
      [(assq x '((a . 1) (b . 2) (c . 3))) => cdr]
      [else 0])))

(select 3) → #t
(select 'b) → 2
(select 'e) → 0
#+end_src

#+BEGIN_VERSE
    *синтаксис:* else
    *синтаксис:* =>
    *библиотеки:* (rnrs base), (rnrs exceptions), (rnrs)
#+END_VERSE

    These identifiers are auxiliary keywords for cond. Both also serve as auxiliary keywords for guard, and else also
    serves as an auxiliary keyword for case. It is a syntax violation to reference these identifiers except in contexts
    where they are recognized as auxiliary keywords.

#+BEGIN_VERSE
    *синтаксис:* (when test-expr expr1 expr2 ...)
    *синтаксис:* (unless test-expr expr1 expr2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs control), (rnrs)
#+END_VERSE

    For when, if test-expr evaluates to a true value, the expressions expr1 expr2 ... are evaluated in sequence, and the
    values of the last expression are returned. If test-expr evaluates to false, none of the other expressions are
    evaluated, and the value or values of when are unspecified.

    For unless, if test-expr evaluates to false, the expressions expr1 expr2 ... are evaluated in sequence, and the
    values of the last expression are returned. If test-expr evaluates to a true value, none of the other expressions
    are evaluated, and the value or values of unless are unspecified.

    A when or unless expression is usually clearer than the corresponding "one-armed" if expression.

#+begin_src scheme
(let ([x -4] [sign 'plus])
  (when (< x 0)
    (set! x (- 0 x))
    (set! sign 'minus))
  (list sign x)) → (minus 4)

(define check-pair
  (lambda (x)
    (unless (pair? x)
      (syntax-violation 'check-pair "invalid argument" x))
    x))

(check-pair '(a b c)) → (a b c)
#+end_src

    when may be defined as follows:

#+begin_src scheme
(define-syntax when
  (syntax-rules ()
    [(_ e0 e1 e2 ...)
     (if e0 (begin e1 e2 ...))]))
#+end_src

    unless may be defined as follows:

#+begin_src scheme
(define-syntax unless
  (syntax-rules ()
    [(_ e0 e1 e2 ...)
     (if (not e0) (begin e1 e2 ...))]))
#+end_src

or in terms of when as follows:

#+begin_src scheme
(define-syntax unless
  (syntax-rules ()
    [(_ e0 e1 e2 ...)
     (when (not e0) e1 e2 ...)]))
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (case expr0 clause1 clause2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    Each clause but the last must take the form

#+begin_src scheme
((key ...) expr1 expr2 ...)
#+end_src

    where each key is a datum distinct from the other keys. The last clause may be in the above form or it may be an
    else clause of the form

#+begin_src scheme
(else expr1 expr2 ...)
#+end_src

    expr0 is evaluated and the result is compared (using eqv?) against the keys of each clause in order. If a clause
    containing a matching key is found, the expressions expr1 expr2 ... are evaluated in sequence and the values of the
    last expression are returned.

    If none of the clauses contains a matching key and an else clause is present, the expressions expr1 expr2 ... of the
    else clause are evaluated in sequence and the values of the last expression are returned.

    If none of the clauses contains a matching key and no else clause is present, the value or values are unspecified.

    See page 306 for a syntax definition of case.

#+begin_src scheme
(let ([x 4] [y 5])
  (case (+ x y)
    [(1 3 5 7 9) 'odd]
    [(0 2 4 6 8) 'even]
    [else 'out-of-range])) → odd
#+end_src

*** Recursion and Iteration

#+BEGIN_VERSE
    *синтаксис:* (let name ((var expr) ...) body1 body2 ...)
    *возвращает:* values of the final body expression
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    This form of let, called named let, is a general-purpose iteration and recursion construct. It is similar to the
    more common form of let (see Section 4.4) in the binding of the variables var ... to the values of expr ... within
    the body body1 body2 ..., which is processed and evaluated like a lambda body. In addition, the variable name is
    bound within the body to a procedure that may be called to recur or iterate; the arguments to the procedure become
    the new values of the variables var ....

    A named let expression of the form

#+begin_src scheme
(let name ((var expr) ...)
  body1 body2 ...)
#+end_src

    can be rewritten with letrec as follows.

#+begin_src scheme
((letrec ((name (lambda (var ...) body1 body2 ...)))
   name)
 expr ...)
#+end_src

    A syntax definition of let that implements this transformation and handles unnamed let as well can be found on
    page 312.

    The procedure divisors defined below uses named let to compute the nontrivial divisors of a nonnegative integer.

#+begin_src scheme
(define divisors
  (lambda (n)
    (let f ([i 2])
      (cond
        [(>= i n) '()]
        [(integer? (/ n i)) (cons i (f (+ i 1)))]
        [else (f (+ i 1))]))))

(divisors 5) → ()
(divisors 32) → (2 4 8 16)
#+end_src

    The version above is non-tail-recursive when a divisor is found and tail-recursive when a divisor is not found. The
    version below is fully tail-recursive. It builds up the list in reverse order, but this is easy to remedy, if
    desired, by reversing the list on exit.

#+begin_src scheme
(define divisors
  (lambda (n)
    (let f ([i 2] [ls '()])
      (cond
        [(>= i n) ls]
        [(integer? (/ n i)) (f (+ i 1) (cons i ls))]
        [else (f (+ i 1) ls)]))))
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (do ((var init update) ...) (test result ...) expr ...)
    *возвращает:* the values of the last result expression
    *библиотеки:* (rnrs control), (rnrs)
#+END_VERSE

    do allows a common restricted form of iteration to be expressed succinctly. The variables var ... are bound
    initially to the values of init ... and are rebound on each subsequent iteration to the values of update .... The
    expressions test, update ..., expr ..., and result ... are all within the scope of the bindings established for var
    ....

    On each step, the test expression test is evaluated. If the value of test is true, iteration ceases, the expressions
    result ... are evaluated in sequence, and the values of the last expression are returned. If no result expressions
    are present, the value or values of the do expression are unspecified.

    If the value of test is false, the expressions expr ... are evaluated in sequence, the expressions update ... are
    evaluated, new bindings for var ... to the values of update ... are created, and iteration continues.

    The expressions expr ... are evaluated only for effect and are often omitted entirely. Any update expression may be
    omitted, in which case the effect is the same as if the update were simply the corresponding var.

    Although looping constructs in most languages require that the loop iterands be updated via assignment, do requires
    the loop iterands var ... to be updated via rebinding. In fact, no side effects are involved in the evaluation of a
    do expression unless they are performed explicitly by its subexpressions.

    See page 313 for a syntax definition of do.

    The definitions of factorial and fibonacci below are straightforward translations of the tail-recursive named-let
    versions given in Section 3.2.

#+begin_src scheme
(define factorial
  (lambda (n)
    (do ([i n (- i 1)] [a 1 (* a i)])
        ((zero? i) a))))

(factorial 10) → 3628800

(define fibonacci
  (lambda (n)
    (if (= n 0)
        0
        (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
            ((= i 1) a1)))))

(fibonacci 6) → 8
#+end_src

    The definition of divisors below is similar to the tail-recursive definition of divisors given with the description
    of named let above.

#+begin_src scheme
(define divisors
  (lambda (n)
    (do ([i 2 (+ i 1)]
         [ls '()
             (if (integer? (/ n i))
                 (cons i ls)
                 ls)])
        ((>= i n) ls))))
#+end_src

    The definition of scale-vector! below, which scales each element of a vector v by a constant k, demonstrates a
    nonempty do body.

#+begin_src scheme
(define scale-vector!
  (lambda (v k)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i (* (vector-ref v i) k))))))

(define vec (vector 1 2 3 4 5))
(scale-vector! vec 2)
vec → #(2 4 6 8 10)
#+end_src

*** Mapping and Folding

    When a program must recur or iterate over the elements of a list, a mapping or folding operator is often more
    convenient. These operators abstract away from null checks and explicit recursion by applying a procedure to the
    elements of the list one by one. A few mapping operators are also available for vectors and strings.

#+BEGIN_VERSE
    *процедура:* (map procedure list1 list2 ...)
    *возвращает:* list of results
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    map applies procedure to corresponding elements of the lists list1 list2 ... and returns a list of the resulting
    values. The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are
    lists, should return a single value, and should not mutate the list arguments.

#+begin_src scheme
(map abs '(1 -2 3 -4 5 -6)) → (1 2 3 4 5 6)

(map (lambda (x y) (* x y))
     '(1 2 3 4)
     '(8 7 6 5)) → (8 14 18 20)
#+end_src

    While the order in which the applications themselves occur is not specified, the order of the values in the output
    list is the same as that of the corresponding values in the input lists.

    map might be defined as follows.

#+begin_src scheme
(define map
  (lambda (f ls . more)
    (if (null? more)
        (let map1 ([ls ls])
          (if (null? ls)
              '()
              (cons (f (car ls))
                    (map1 (cdr ls)))))
        (let map-more ([ls ls] [more more])
          (if (null? ls)
              '()
              (cons
                (apply f (car ls) (map car more))
                (map-more (cdr ls) (map cdr more))))))))
#+end_src

    No error checking is done by this version of map; f is assumed to be a procedure and the other arguments are assumed
    to be proper lists of the same length. An interesting feature of this definition is that map uses itself to pull out
    the cars and cdrs of the list of input lists; this works because of the special treatment of the single-list case.

#+BEGIN_VERSE
    *процедура:* (for-each procedure list1 list2 ...)
    *возвращает:* unspecified
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    for-each is similar to map except that for-each does not create and return a list of the resulting values, and
    for-each guarantees to perform the applications in sequence over the elements from left to right. procedure should
    accept as many arguments as there are lists and should not mutate the list arguments. for-each may be defined
    without error checks as follows.

#+begin_src scheme
(define for-each
  (lambda (f ls . more)
    (do ([ls ls (cdr ls)] [more more (map cdr more)])
        ((null? ls))
      (apply f (car ls) (map car more)))))

(let ([same-count 0])
  (for-each
    (lambda (x y)
      (when (= x y)
        (set! same-count (+ same-count 1))))
    '(1 2 3 4 5 6)
    '(2 3 3 4 7 6))
  same-count) → 3
#+end_src

#+BEGIN_VERSE
    *процедура:* (exists procedure list1 list2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are lists
    and should not mutate the list arguments. If the lists are empty, exists returns #f. Otherwise, exists applies
    procedure to corresponding elements of the lists list1 list2 ... in sequence until either the lists each have only
    one element or procedure returns a true value t. In the former case, exists tail-calls procedure, applying it to the
    remaining element of each list. In the latter case, exists returns t.

#+begin_src scheme
(exists symbol? '(1.0 #\a "hi" '())) → #f

(exists member
        '(a b c)
        '((c b) (b a) (a c))) → (b a)

(exists (lambda (x y z) (= (+ x y) z))
        '(1 2 3 4)
        '(1.2 2.3 3.4 4.5)
        '(2.3 4.4 6.4 8.6)) → #t
#+end_src

    exists may be defined (somewhat inefficiently and without error checks) as follows:

#+begin_src scheme
(define exists
  (lambda (f ls . more)
    (and (not (null? ls))
      (let exists ([x (car ls)] [ls (cdr ls)] [more more])
        (if (null? ls)
            (apply f x (map car more))
            (or (apply f x (map car more))
                (exists (car ls) (cdr ls) (map cdr more))))))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (for-all procedure list1 list2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are lists
    and should not mutate the list arguments. If the lists are empty, for-all returns #t. Otherwise, for-all applies
    procedure to corresponding elements of the lists list1 list2 ... in sequence until either the lists each have only
    one element left or procedure returns #f. In the former case, for-all tail-calls procedure, applying it to the
    remaining element of each list. In the latter case, for-all returns #f.

#+begin_src scheme
(for-all symbol? '(a b c d)) → #t

(for-all =
         '(1 2 3 4)
         '(1.0 2.0 3.0 4.0)) → #t

(for-all (lambda (x y z) (= (+ x y) z))
         '(1 2 3 4)
         '(1.2 2.3 3.4 4.5)
         '(2.2 4.3 6.5 8.5)) → #f
#+end_src

    for-all may be defined (somewhat inefficiently and without error checks) as follows:

#+begin_src scheme
(define for-all
  (lambda (f ls . more)
    (or (null? ls)
      (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
        (if (null? ls)
            (apply f x (map car more))
            (and (apply f x (map car more))
                 (for-all (car ls) (cdr ls) (map cdr more))))))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (fold-left procedure obj list1 list2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    The list arguments should all have the same length. procedure should accept one more argument than the number of
    list arguments and return a single value. It should not mutate the list arguments.

    fold-left returns obj if the list arguments are empty. If they are not empty, fold-left applies procedure to obj and
    the cars of list1 list2 ..., then recurs with the value returned by procedure in place of obj and the cdr of each
    list in place of the list.

#+begin_src scheme
(fold-left cons '() '(1 2 3 4)) → ((((() . 1) . 2) . 3) . 4)

(fold-left
  (lambda (a x) (+ a (* x x)))
  0 '(1 2 3 4 5)) → 55

(fold-left
  (lambda (a . args) (append args a))
  '(question)
  '(that not to)
  '(is to be)
  '(the be: or)) → (to be or not to be: that is the question)
#+end_src

#+BEGIN_VERSE
    *процедура:* (fold-right procedure obj list1 list2 ...)
    *возвращает:* see below
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    The list arguments should all have the same length. procedure should accept one more argument than the number of
    list arguments and return a single value. It should not mutate the list arguments.

    fold-right returns obj if the list arguments are empty. If they are not empty, fold-right recurs with the cdr of
    each list replacing the list, then applies procedure to the cars of list1 list2 ... and the result returned by the
    recursion.

#+begin_src scheme
(fold-right cons '() '(1 2 3 4)) → (1 2 3 4)

(fold-right
  (lambda (x a) (+ a (* x x)))
  0 '(1 2 3 4 5)) → 55

(fold-right
  (lambda (x y a) (cons* x y a))   → (parting is such sweet sorrow
  '((with apologies))                gotta go see ya tomorrow
  '(parting such sorrow go ya)       (with apologies))
  '(is sweet gotta see tomorrow))
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-map procedure vector1 vector1 ...)
    *возвращает:* vector of results
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    vector-map applies procedure to corresponding elements of vector1 vector2 ... and returns a vector of the resulting
    values. The vectors vector1 vector2 ... must be of the same length, and procedure should accept as many arguments as
    there are vectors and return a single value.

#+begin_src scheme
(vector-map abs '#(1 -2 3 -4 5 -6)) → #(1 2 3 4 5 6)
(vector-map (lambda (x y) (* x y))
  '#(1 2 3 4)
  '#(8 7 6 5)) → #(8 14 18 20)
#+end_src

    While the order in which the applications themselves occur is not specified, the order of the values in the output
    vector is the same as that of the corresponding values in the input vectors.

#+BEGIN_VERSE
    *процедура:* (vector-for-each procedure vector1 vector2 ...)
    *возвращает:* unspecified
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    vector-for-each is similar to vector-map except that vector-for-each does not create and return a vector of the
    resulting values, and vector-for-each guarantees to perform the applications in sequence over the elements from left
    to right.

#+begin_src scheme
(let ([same-count 0])
  (vector-for-each
    (lambda (x y)
      (when (= x y)
        (set! same-count (+ same-count 1))))
    '#(1 2 3 4 5 6)
    '#(2 3 3 4 7 6))
  same-count) → 3
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-for-each procedure string1 string2 ...)
    *возвращает:* unspecified
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    string-for-each is similar to for-each and vector-for-each except that the inputs are strings rather than lists or
    vectors.

#+begin_src scheme
(let ([ls '()])
  (string-for-each
    (lambda r (set! ls (cons r ls)))
    "abcd"
    "===="
    "1234")
  (map list->string (reverse ls))) → ("a=1" "b=2" "c=3" "d=4")
#+end_src

*** Continuations

    Continuations in Scheme are procedures that represent the remainder of a computation from a given point in the
    computation. They may be obtained with call-with-current-continuation, which can be abbreviated to call/cc.

#+BEGIN_VERSE
    *процедура:* (call/cc procedure)
    *процедура:* (call-with-current-continuation procedure)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    These procedures are the same. The shorter name is often used for the obvious reason that it requires fewer
    keystrokes to type.

    call/cc obtains its continuation and passes it to procedure, which should accept one argument. The continuation
    itself is represented by a procedure. Each time this procedure is applied to zero or more values, it returns the
    values to the continuation of the call/cc application. That is, when the continuation procedure is called, it
    returns its arguments as the values of the application of call/cc.

    If procedure returns normally when passed the continuation procedure, the values returned by call/cc are the values
    returned by procedure.

    Continuations allow the implementation of nonlocal exits, backtracking [14,29], coroutines [16], and multitasking
    [10,32].

    The example below illustrates the use of a continuation to perform a nonlocal exit from a loop.

#+begin_src scheme
(define member
  (lambda (x ls)
    (call/cc
      (lambda (break)
        (do ([ls ls (cdr ls)])
            ((null? ls) #f)
          (when (equal? x (car ls))
            (break ls)))))))

(member 'd '(a b c)) → #f
(member 'b '(a b c)) → (b c)
#+end_src

    Additional examples are given in Sections 3.3 and 12.11.

    The current continuation is typically represented internally as a stack of procedure activation records, and
    obtaining the continuation involves encapsulating the stack within a procedural object. Since an encapsulated stack
    has indefinite extent, some mechanism must be used to preserve the stack contents indefinitely. This can be done
    with surprising ease and efficiency and with no impact on programs that do not use continuations [17].

#+BEGIN_VERSE
    *процедура:* (dynamic-wind in body out)
    *возвращает:* values resulting from the application of body
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    dynamic-wind offers "protection" from continuation invocation. It is useful for performing tasks that must be
    performed whenever control enters or leaves body, either normally or by continuation application.

    The three arguments in, body, and out must be procedures and should accept zero arguments, i.e., they should be
    thunks. Before applying body, and each time body is entered subsequently by the application of a continuation
    created within body, the in thunk is applied. Upon normal exit from body and each time body is exited by the
    application of a continuation created outside body, the out thunk is applied.

    Thus, it is guaranteed that in is invoked at least once. In addition, if body ever returns, out is invoked at least
    once.

    The following example demonstrates the use of dynamic-wind to be sure that an input port is closed after processing,
    regardless of whether the processing completes normally.

#+begin_src scheme
(let ([p (open-input-file "input-file")])
  (dynamic-wind
    (lambda () #f)
    (lambda () (process p))
    (lambda () (close-port p))))
#+end_src

    Common Lisp provides a similar facility (unwind-protect) for protection from nonlocal exits. This is often
    sufficient. unwind-protect provides only the equivalent to out, however, since Common Lisp does not support fully
    general continuations. Here is how unwind-protect might be specified with dynamic-wind.

#+begin_src scheme
(define-syntax unwind-protect
  (syntax-rules ()
    [(_ body cleanup ...)
     (dynamic-wind
       (lambda () #f)
       (lambda () body)
       (lambda () cleanup ...))]))

((call/cc
   (let ([x 'a])
     (lambda (k)
       (unwind-protect
         (k (lambda () x))
         (set! x 'b)))))) → b
#+end_src

    Some Scheme implementations support a controlled form of assignment known as fluid binding, in which a variable
    takes on a temporary value during a given computation and reverts to the old value after the computation has
    completed. The syntactic form fluid-let defined below in terms of dynamic-wind permits the fluid binding of a single
    variable x to the value of an expression e within a the body b1 b2 ....

#+begin_src scheme
(define-syntax fluid-let
  (syntax-rules ()
    [(_ ((x e)) b1 b2 ...)
     (let ([y e])
       (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
         (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))
#+end_src

    Implementations that support fluid-let typically extend it to allow an indefinite number of (x e) pairs, as with
    let.

    If no continuations are invoked within the body of a fluid-let, the behavior is the same as if the variable were
    simply assigned the new value on entry and assigned the old value on return.

#+begin_src scheme
(let ([x 3])
  (+ (fluid-let ([x 5])
       x)
     x)) → 8
#+end_src

    A fluid-bound variable also reverts to the old value if a continuation created outside of the fluid-let is invoked.

#+begin_src scheme
(let ([x 'a])
  (let ([f (lambda () x)])
    (cons (call/cc
            (lambda (k)
              (fluid-let ([x 'b])
                (k (f)))))
          (f)))) → (b . a)
#+end_src

    If control has left a fluid-let body, either normally or by the invocation of a continuation, and control reenters
    the body by the invocation of a continuation, the temporary value of the fluid-bound variable is
    reinstated. Furthermore, any changes to the temporary value are maintained and reflected upon reentry.

#+begin_src scheme
(define reenter #f)
(define x 0)
(fluid-let ([x 1])
  (call/cc (lambda (k) (set! reenter k)))
  (set! x (+ x 1))
  x) → 2
x → 0
(reenter '*) → 3
(reenter '*) → 4
x → 0
#+end_src

    A library showing how dynamic-wind might be implemented were it not already built in is given below. In addition to
    defining dynamic-wind, the code defines a version of call/cc that does its part to support dynamic-wind.

#+begin_src scheme
(library (dynamic-wind)
  (export dynamic-wind call/cc
    (rename (call/cc call-with-current-continuation)))
  (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))

  (define winders '())

  (define common-tail
    (lambda (x y)
      (let ([lx (length x)] [ly (length y)])
        (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
             [y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])
            ((eq? x y) x)))))

  (define do-wind
    (lambda (new)
      (let ([tail (common-tail new winders)])
        (let f ([ls winders])
          (if (not (eq? ls tail))
              (begin
                (set! winders (cdr ls))
                ((cdar ls))
                (f (cdr ls)))))
        (let f ([ls new])
          (if (not (eq? ls tail))
              (begin
                (f (cdr ls))
                ((caar ls))
                (set! winders ls)))))))

  (define call/cc
    (lambda (f)
      (rnrs:call/cc
        (lambda (k)
          (f (let ([save winders])
               (lambda (x)
                 (unless (eq? save winders) (do-wind save))
                 (k x))))))))

  (define dynamic-wind
    (lambda (in body out)
      (in)
      (set! winders (cons (cons in out) winders))
      (let-values ([ans* (body)])
        (set! winders (cdr winders))
        (out)
        (apply values ans*)))))
#+end_src

    Together, dynamic-wind and call/cc manage a list of winders. A winder is a pair of in and out thunks established by
    a call to dynamic-wind. Whenever dynamic-wind is invoked, the in thunk is invoked, a new winder containing the in
    and out thunks is placed on the winders list, the body thunk is invoked, the winder is removed from the winders
    list, and the out thunk is invoked. This ordering ensures that the winder is on the winders list only when control
    has passed through in and not yet entered out. Whenever a continuation is obtained, the winders list is saved, and
    whenever the continuation is invoked, the saved winders list is reinstated. During reinstatement, the out thunk of
    each winder on the current winders list that is not also on the saved winders list is invoked, followed by the in
    thunk of each winder on the saved winders list that is not also on the current winders list. The winders list is
    updated incrementally, again to ensure that a winder is on the current winders list only if control has passed
    through its in thunk and not entered its out thunk.

    The test (not (eq? save winders)) performed in call/cc is not strictly necessary but makes invoking a continuation
    less costly whenever the saved winders list is the same as the current winders list.

*** Delayed Evaluation

    The syntactic form delay and the procedure force may be used in combination to implement lazy evaluation. An
    expression subject to lazy evaluation is not evaluated until its value is required and, once evaluated, is never
    reevaluated.

#+BEGIN_VERSE
    *синтаксис:* (delay expr)
    *возвращает:* a promise
    *процедура:* (force promise)
    *возвращает:* result of forcing promise
    *библиотеки:* (rnrs r5rs)
#+END_VERSE

    The first time a promise created by delay is forced (with force), it evaluates expr, "remembering" the resulting
    value. Thereafter, each time the promise is forced, it returns the remembered value instead of reevaluating expr.

    delay and force are typically used only in the absence of side effects, e.g., assignments, so that the order of
    evaluation is unimportant.

    The benefit of using delay and force is that some amount of computation might be avoided altogether if it is delayed
    until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams. The
    example below shows how a stream abstraction may be built with delay and force. A stream is a promise that, when
    forced, returns a pair whose cdr is a stream.

#+begin_src scheme
(define stream-car
  (lambda (s)
    (car (force s))))

(define stream-cdr
  (lambda (s)
    (cdr (force s))))

(define counters
  (let next ([n 1])
    (delay (cons n (next (+ n 1))))))

(stream-car counters) → 1

(stream-car (stream-cdr counters)) → 2

(define stream-add
  (lambda (s1 s2)
    (delay (cons
             (+ (stream-car s1) (stream-car s2))
             (stream-add (stream-cdr s1) (stream-cdr s2))))))

(define even-counters
  (stream-add counters counters))

(stream-car even-counters) → 2

(stream-car (stream-cdr even-counters)) → 4

#+end_src

    delay may be defined by

#+begin_src scheme
(define-syntax delay
  (syntax-rules ()
    [(_ expr) (make-promise (lambda () expr))]))
#+end_src

    where make-promise might be defined as follows.

#+begin_src scheme
(define make-promise
  (lambda (p)
    (let ([val #f] [set? #f])
      (lambda ()
        (unless set?
          (let ([x (p)])
            (unless set?
              (set! val x)
              (set! set? #t))))
        val))))
#+end_src

    With this definition of delay, force simply invokes the promise to force evaluation or to retrieve the saved value.

#+begin_src scheme
(define force
  (lambda (promise)
    (promise)))
#+end_src

    The second test of the variable set? in make-promise is necessary in the event that, as a result of applying p, the
    promise is recursively forced. Since a promise must always return the same value, the result of the first
    application of p to complete is returned.

    Whether delay and force handle multiple return values is unspecified; the implementation given above does not, but
    the following version does, with the help of call-with-values and apply.

#+begin_src scheme
(define make-promise
  (lambda (p)
    (let ([vals #f] [set? #f])
      (lambda ()
        (unless set?
          (call-with-values p
            (lambda x
              (unless set?
                (set! vals x)
                (set! set? #t)))))
        (apply values vals)))))

(define p (delay (values 1 2 3)))
(force p) → 1
           2
           3
(call-with-values (lambda () (force p)) +) → 6
#+end_src

    Neither implementation is quite right, since force must raise an exception with condition type &assertion if its
    argument is not a promise. Since distinguishing procedures created by make-promise from other procedures is
    impossible, force cannot do so reliably. The following reimplementation of make-promise and force represents
    promises as records of the type promise to allow force to make the required check.

#+begin_src scheme
(define-record-type promise
  (fields (immutable p) (mutable vals) (mutable set?))
  (protocol (lambda (new) (lambda (p) (new p #f #f)))))

(define force
  (lambda (promise)
    (unless (promise? promise)
      (assertion-violation 'promise "invalid argument" promise))
    (unless (promise-set? promise)
      (call-with-values (promise-p promise)
        (lambda x
          (unless (promise-set? promise)
            (promise-vals-set! promise x)
            (promise-set?-set! promise #t)))))
    (apply values (promise-vals promise))))
#+end_src

*** Multiple Values

    While all Scheme primitives and most user-defined procedures return exactly one value, some programming problems are
    best solved by returning zero values, more than one value, or even a variable number of values. For example, a
    procedure that partitions a list of values into two sublists needs to return two values. While it is possible for
    the producer of multiple values to package them into a data structure and for the consumer to extract them, it is
    often cleaner to use the built-in multiple-values interface. This interface consists of two procedures: values and
    call-with-values. The former produces multiple values and the latter links procedures that produce multiple-value
    values with procedures that consume them.

#+BEGIN_VERSE
    *процедура:* (values obj ...)
    *возвращает:* obj ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The procedure values accepts any number of arguments and simply passes (returns) the arguments to its continuation.

#+begin_src scheme
(values) →

(values 1) → 1

(values 1 2 3) → 1
                2
                3

(define head&tail
  (lambda (ls)
    (values (car ls) (cdr ls))))

(head&tail '(a b c)) → a
                      (b c)
#+end_src

#+BEGIN_VERSE
    *процедура:* (call-with-values producer consumer)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    producer and consumer must be procedures. call-with-values applies consumer to the values returned by invoking
    producer without arguments.

#+begin_src scheme
(call-with-values
  (lambda () (values 'bond 'james))
  (lambda (x y) (cons y x))) → (james . bond)

(call-with-values values list) → '()
#+end_src

    In the second example, values itself serves as the producer. It receives no arguments and thus returns no
    values. list is thus applied to no arguments and so returns the empty list.

    The procedure dxdy defined below computes the change in x and y coordinates for a pair of points whose coordinates
    are represented by (x . y) pairs.

#+begin_src scheme
(define dxdy
  (lambda (p1 p2)
    (values (- (car p2) (car p1))
            (- (cdr p2) (cdr p1)))))

(dxdy '(0 . 0) '(0 . 5)) → 0
                          5
#+end_src

    dxdy can be used to compute the length and slope of a segment represented by two endpoints.

#+begin_src scheme
(define segment-length
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))

(define segment-slope
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy) (/ dy dx)))))

(segment-length '(1 . 4) '(4 . 8)) → 5
(segment-slope '(1 . 4) '(4 . 8)) → 4/3
#+end_src

    We can of course combine these to form one procedure that returns two values.

#+begin_src scheme
(define describe-segment
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy)
        (values
          (sqrt (+ (* dx dx) (* dy dy)))
          (/ dy dx))))))

(describe-segment '(1 . 4) '(4 . 8)) → 5
                                     → 4/3
#+end_src

    The example below employs multiple values to divide a list nondestructively into two sublists of alternating
    elements.

#+begin_src scheme
(define split
  (lambda (ls)
    (if (or (null? ls) (null? (cdr ls)))
        (values ls '())
        (call-with-values
          (lambda () (split (cddr ls)))
          (lambda (odds evens)
            (values (cons (car ls) odds)
                    (cons (cadr ls) evens)))))))

(split '(a b c d e f)) → (a c e)
                        (b d f)
#+end_src

    At each level of recursion, the procedure split returns two values: a list of the odd-numbered elements from the
    argument list and a list of the even-numbered elements.

    The continuation of a call to values need not be one established by a call to call-with-values, nor must only values
    be used to return to a continuation established by call-with-values. In particular, (values e) and e are equivalent
    expressions. For example:

#+begin_src scheme
(+ (values 2) 4) → 6

(if (values #t) 1 2) → 1

(call-with-values
  (lambda () 4)
  (lambda (x) x)) → 4
#+end_src

    Similarly, values may be used to pass any number of values to a continuation that ignores the values, as in the
    following.

#+begin_src scheme
(begin (values 1 2 3) 4) → 4
#+end_src

    Because a continuation may accept zero or more than one value, continuations obtained via call/cc may accept zero or
    more than one argument.

#+begin_src scheme
(call-with-values
  (lambda ()
    (call/cc (lambda (k) (k 2 3))))
  (lambda (x y) (list x y))) → (2 3)
#+end_src

    The behavior is unspecified when a continuation expecting exactly one value receives zero values or more than one
    value. For example, the behavior of each of the following expressions is unspecified. Some implementations raise an
    exception, while others silently suppress additional values or supply defaults for missing values.

#+begin_src scheme
(if (values 1 2) 'x 'y)

(+ (values) 5)
#+end_src

    Programs that wish to force extra values to be ignored in particular contexts can do so easily by calling
    call-with-values explicitly. A syntactic form, which we might call first, can be defined to abstract the discarding
    of more than one value when only one is desired.

#+begin_src scheme
(define-syntax first
  (syntax-rules ()
    [(_ expr)
     (call-with-values
       (lambda () expr)
       (lambda (x . y) x))]))

(if (first (values #t #f)) 'a 'b) → a
#+end_src

    Since implementations are required to raise an exception with condition type &assertion if a procedure does not
    accept the number of arguments passed to it, each of the following raises an exception.

#+begin_src scheme
(call-with-values
  (lambda () (values 2 3 4))
  (lambda (x y) x))

(call-with-values
  (lambda () (call/cc (lambda (k) (k 0))))
  (lambda (x y) x))
#+end_src

    Since producer is most often a lambda expression, it is often convenient to use a syntactic extension that
    suppresses the lambda expression in the interest of readability.

#+begin_src scheme
(define-syntax with-values
  (syntax-rules ()
    [(_ expr consumer)
     (call-with-values (lambda () expr) consumer)]))

(with-values (values 1 2) list) → (1 2)
(with-values (split '(1 2 3 4))
  (lambda (odds evens)
    evens)) → (2 4)
#+end_src

    If the consumer is also a lambda expression, the multiple-value variants of let and let* described in Section 4.5
    are usually even more convenient.

#+begin_src scheme
(let-values ([(odds evens) (split '(1 2 3 4))])
  evens) → (2 4)

(let-values ([ls (values 'a 'b 'c)])
  ls) → (a b c)
#+end_src

    Many standard syntactic forms and procedures pass along multiple values. Most of these are "automatic," in the sense
    that nothing special must be done by the implementation to make this happen. The usual expansion of let into a
    direct lambda call automatically propagates multiple values produced by the body of the let. Other operators must be
    coded specially to pass along multiple values. The call-with-port procedure (page 7.6), for example, calls its
    procedure argument, then closes the port argument before returning the procedure's values, so it must save the
    values temporarily. This is easily accomplished via let-values, apply, and values:

#+begin_src scheme
(define call-with-port
  (lambda (port proc)
    (let-values ([val* (proc port)])
      (close-port port)
      (apply values val*))))
#+end_src

    If this seems like too much overhead when a single value is returned, the code can use call-with-values and
    case-lambda to handle the single-value case more efficiently:

#+begin_src scheme
(define call-with-port
  (lambda (port proc)
    (call-with-values (lambda () (proc port))
      (case-lambda
        [(val) (close-port port) val]
        [val* (close-port port) (apply values val*)]))))
#+end_src

    The definitions of values and call-with-values (and concomitant redefinition of call/cc) in the library below
    demonstrate that the multiple-return-values interface could be implemented in Scheme if it were not already built
    in. No error checking can be done, however, for the case in which more than one value is returned to a single-value
    context, such as the test part of an if expression.

#+begin_src scheme
(library (mrvs)
  (export call-with-values values call/cc
    (rename (call/cc call-with-current-continuation)))
  (import
    (rename
      (except (rnrs) values call-with-values)
      (call/cc rnrs:call/cc)))

  (define magic (cons 'multiple 'values))

  (define magic?
    (lambda (x)
      (and (pair? x) (eq? (car x) magic))))

  (define call/cc
    (lambda (p)
      (rnrs:call/cc
        (lambda (k)
          (p (lambda args
               (k (apply values args))))))))

  (define values
    (lambda args
      (if (and (not (null? args)) (null? (cdr args)))
          (car args)
          (cons magic args))))

  (define call-with-values
    (lambda (producer consumer)
      (let ([x (producer)])
        (if (magic? x)
            (apply consumer (cdr x))
            (consumer x))))))
#+end_src

    Multiple values can be implemented more efficiently [2], but this code serves to illustrate the meanings of the
    operators and may be used to provide multiple values in older, nonstandard implementations that do not support
    them.

*** Eval

    Scheme's eval procedure allows programmers to write programs that construct and evaluate other programs. This
    ability to do run-time meta programming should not be overused but is handy when needed.

#+BEGIN_VERSE
    *процедура:* (eval obj environment)
    *возвращает:* values of the Scheme expression represented by obj in environment
    *библиотеки:* (rnrs eval)
#+END_VERSE

    If obj does not represent a syntactically valid expression, eval raises an exception with condition type
    &syntax. The environments returned by environment, scheme-report-environment, and null-environment are
    immutable. Thus, eval also raises an exception with condition type &syntax if an assignment to any of the variables
    in the environment appears within the expression.

#+begin_src scheme
(define cons 'not-cons)
(eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) → (3 . 4)

(define lambda 'not-lambda)
(eval '(lambda (x) x) (environment '(rnrs))) → #<procedure>

(eval '(cons 3 4) (environment)) → exception
#+end_src

#+BEGIN_VERSE
    *процедура:* (environment import-spec ...)
    *возвращает:* an environment
    *библиотеки:* (rnrs eval)
#+END_VERSE

    environment returns an environment formed from the combined bindings of the given import specifiers. Each
    import-spec must be an s-expression representing a valid import specifier (see Chapter 10).

#+begin_src scheme
(define env (environment '(rnrs) '(prefix (rnrs lists) $)))
(eval '($cons* 3 4 (* 5 8)) env) → (3 4 . 40)
#+end_src

#+BEGIN_VERSE
    *процедура:* (null-environment version)
    *процедура:* (scheme-report-environment version)
    *возвращает:* an R5RS compatibility environment
    *библиотеки:* (rnrs r5rs)
#+END_VERSE

    version must be the exact integer 5.

    null-environment returns an environment containing bindings for the keywords whose meanings are defined by the
    Revised5 Report on Scheme, along with bindings for the auxiliary keywords else, =>, ..., and _.

    scheme-report-environment returns an environment containing the same keyword bindings as the environment returned by
    null-environment along with bindings for the variables whose meanings are defined by the Revised5 Report on Scheme,
    except those not defined by the Revised6 Report: load, interaction-environment, transcript-on, transcript-off, and
    char-ready?.

    The bindings for each of the identifiers in the environments returned by these procedures are those of the
    corresponding Revised6 Report library, so this does not provide full backward compatibility, even if the excepted
    identifier bindings are not used.

#+LATEX: \newpage
[[./images/ch6.png]]

** Operations on Objects

   This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors,
   bytevectors, symbols, booleans, hashtables, and enumerations. The first section covers constant objects and
   quotation. The second section describes generic equivalence predicates for comparing two objects and predicates for
   determining the type of an object. Later sections describe procedures that deal primarily with one of the object
   types mentioned above. There is no section treating operations on procedures, since the only operation defined
   specifically for procedures is application, and this is described in Chapter 5. Operations on ports are covered in
   the more general discussion of input and output in Chapter 7. A mechanism for defining new data types is described in
   Chapter 9.

*** Constants and Quotation

#+BEGIN_VERSE
    *синтаксис:* constant
    *возвращает:* constant
#+END_VERSE

    constant is any self-evaluating constant, i.e., a number, boolean, character, string, or bytevector. Constants are
    immutable; see the note in the description of quote below.

#+begin_src scheme
3.2 → 3.2
#f → #f
#\c → #\c
"hi" → "hi"
#vu8(3 4 5) → #vu8(3 4 5)
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (quote obj)
    *синтаксис:* 'obj
    *возвращает:* obj
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    'obj is equivalent to (quote obj). The abbreviated form is converted into the longer form by the Scheme reader (see
    read).

    quote inhibits the normal evaluation rule for obj, allowing obj to be employed as data. Although any Scheme object
    may be quoted, quotation is not necessary for self-evaluating constants, i.e., numbers, booleans, characters,
    strings, and bytevectors.

    Quoted and self-evaluating constants are immutable. That is, programs should not alter a constant via set-car!,
    string-set!, etc., and implementations are permitted to raise an exception with condition type &assertion if such an
    alteration is attempted. If an attempt to alter an immutable object is undetected, the behavior of the program is
    unspecified. An implementation may choose to share storage among different constants to save space.

#+begin_src scheme
(+ 2 3) → 5
'(+ 2 3) → (+ 2 3)
(quote (+ 2 3)) → (+ 2 3)
'a → a
'cons → cons
'() → ()
'7 → 7
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (quasiquote obj ...)
    *синтаксис:* `obj
    *синтаксис:* (unquote obj ...)
    *синтаксис:* ,obj
    *синтаксис:* (unquote-splicing obj ...)
    *синтаксис:* ,@obj
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    `obj is equivalent to (quasiquote obj), ,obj is equivalent to (unquote obj), and ,@obj is equivalent to
    (unquote-splicing obj). The abbreviated forms are converted into the longer forms by the Scheme reader (see read).

    quasiquote is similar to quote, but it allows parts of the quoted text to be "unquoted." Within a quasiquote
    expression, unquote and unquote-splicing subforms are evaluated, and everything else is quoted, i.e., left
    unevaluated. The value of each unquote subform is inserted into the output in place of the unquote form, while the
    value of each unquote-splicing subform is spliced into the surrounding list or vector structure. unquote and
    unquote-splicing are valid only within quasiquote expressions.

    quasiquote expressions may be nested, with each quasiquote introducing a new level of quotation and each unquote or
    unquote-splicing taking away a level of quotation. An expression nested within n quasiquote expressions must be
    within n unquote or unquote-splicing expressions to be evaluated.

#+begin_src scheme
`(+ 2 3) → (+ 2 3)

`(+ 2 ,(* 3 4)) → (+ 2 12)
`(a b (,(+ 2 3) c) d) → (a b (5 c) d)
`(a b ,(reverse '(c d e)) f g) → (a b (e d c) f g)
(let ([a 1] [b 2])
  `(,a . ,b)) → (1 . 2)

`(+ ,@(cdr '(* 2 3))) → (+ 2 3)
`(a b ,@(reverse '(c d e)) f g) → (a b e d c f g)
(let ([a 1] [b 2])
  `(,a ,@b)) → (1 . 2)
`#(,@(list 1 2 3)) → #(1 2 3)

'`,(cons 'a 'b) → `,(cons 'a 'b)
`',(cons 'a 'b) → '(a . b)

#+end_src

    unquote and unquote-splicing forms with zero or more than one subform are valid only in splicing (list or vector)
    contexts. (unquote obj ...) is equivalent to (unquote obj) ..., and (unquote-splicing obj ...) is equivalent to
    (unquote-splicing obj) .... These forms are primarily useful as intermediate forms in the output of the quasiquote
    expander. They support certain useful nested quasiquotation idioms [3], such as ,@,@, which has the effect of a
    doubly indirect splicing when used within a doubly nested and doubly evaluated quasiquote expression.

#+begin_src scheme
`(a (unquote) b) → (a b)
`(a (unquote (+ 3 3)) b) → (a 6 b)
`(a (unquote (+ 3 3) (* 3 3)) b) → (a 6 9 b)

(let ([x '(m n)]) ``(a ,@,@x f)) → `(a (unquote-splicing m n) f)
(let ([x '(m n)])
  (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
        (environment '(rnrs)))) → (a b c d e f)
#+end_src

    unquote and unquote-splicing are auxiliary keywords for quasiquote. It is a syntax violation to reference these
    identifiers except in contexts where they are recognized as auxiliary keywords.

*** Generic Equivalence and Type Predicates

    This section describes the basic Scheme predicates (procedures returning one of the boolean values #t or #f) for
    determining the type of an object or the equivalence of two objects. The equivalence predicates eq?, eqv?, and
    equal? are discussed first, followed by the type predicates.

#+BEGIN_VERSE
    *процедура:* (eq? obj1 obj2)
    *возвращает:* #t if obj1 and obj2 are identical, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    In most Scheme systems, two objects are considered identical if they are represented internally by the same pointer
    value and distinct (not identical) if they are represented internally by different pointer values, although other
    criteria, such as time-stamping, are possible.

    Although the particular rules for object identity vary somewhat from system to system, the following rules always
    hold.

    + Two objects of different types (booleans, the empty list, pairs, numbers, characters, strings, vectors, symbols,
      and procedures) are distinct.
    + Two objects of the same type with different contents or values are distinct.
    + The boolean object #t is identical to itself wherever it appears, and #f is identical to itself wherever it
      appears, but #t and #f are distinct.
    + The empty list () is identical to itself wherever it appears.
    + Two symbols are identical if and only if they have the same name (by string=?).
    + A constant pair, vector, string, or bytevector is identical to itself, as is a pair, vector, string, or bytevector
      created by an application of cons, vector, string, make-bytevector, etc. Two pairs, vectors, strings, or
      bytevectors created by different applications of cons, vector, string, make-bytevector, etc., are distinct. One
      consequence is that cons, for example, may be used to create a unique object distinct from all other objects.
    + Two procedures that may behave differently are distinct. A procedure created by an evaluation of a lambda
      expression is identical to itself. Two procedures created by the same lambda expression at different times, or by
      similar lambda expressions, may or may not be distinct.

    eq? cannot be used to compare numbers and characters reliably. Although every inexact number is distinct from every
    exact number, two exact numbers, two inexact numbers, or two characters with the same value may or may not be
    identical.

    Since constant objects are immutable, i.e., programs should not modify them via vector-set!, set-car!, or any other
    structure mutation operation, all or portions of different quoted constants or self-evaluating literals may be
    represented internally by the same object. Thus, eq? may return #t when applied to equal parts of different
    immutable constants.

    eq? is most often used to compare symbols or to check for pointer equivalence of allocated objects, e.g., pairs,
    vectors, or record instances.

#+begin_src scheme
(eq? 'a 3) → #f
(eq? #t 't) → #f
(eq? "abc" 'abc) → #f
(eq? "hi" '(hi)) → #f
(eq? #f '()) → #f

(eq? 9/2 7/2) → #f
(eq? 3.4 53344) → #f
(eq? 3 3.0) → #f
(eq? 1/3 #i1/3) → #f

(eq? 9/2 9/2) → unspecified
(eq? 3.4 (+ 3.0 .4)) → unspecified
(let ([x (* 12345678987654321 2)])
  (eq? x x)) → unspecified

(eq? #\a #\b) → #f
(eq? #\a #\a) → unspecified
(let ([x (string-ref "hi" 0)])
  (eq? x x)) → unspecified

(eq? #t #t) → #t
(eq? #f #f) → #t
(eq? #t #f) → #f
(eq? (null? '()) #t) → #t
(eq? (null? '(a)) #f) → #t

(eq? (cdr '(a)) '()) → #t

(eq? 'a 'a) → #t
(eq? 'a 'b) → #f
(eq? 'a (string->symbol "a")) → #t

(eq? '(a) '(b)) → #f
(eq? '(a) '(a)) → unspecified
(let ([x '(a . b)]) (eq? x x)) → #t
(let ([x (cons 'a 'b)])
  (eq? x x)) → #t
(eq? (cons 'a 'b) (cons 'a 'b)) → #f

(eq? "abc" "cba") → #f
(eq? "abc" "abc") → unspecified
(let ([x "hi"]) (eq? x x)) → #t
(let ([x (string #\h #\i)]) (eq? x x)) → #t
(eq? (string #\h #\i)
     (string #\h #\i)) → #f

(eq? '#vu8(1) '#vu8(1)) → unspecified
(eq? '#vu8(1) '#vu8(2)) → #f
(let ([x (make-bytevector 10 0)])
  (eq? x x)) → #t
(let ([x (make-bytevector 10 0)])
  (eq? x (make-bytevector 10 0))) → #f

(eq? '#(a) '#(b)) → #f
(eq? '#(a) '#(a)) → unspecified
(let ([x '#(a)]) (eq? x x)) → #t
(let ([x (vector 'a)])
  (eq? x x)) → #t
(eq? (vector 'a) (vector 'a)) → #f

(eq? car car) → #t
(eq? car cdr) → #f
(let ([f (lambda (x) x)])
  (eq? f f)) → #t
(let ([f (lambda () (lambda (x) x))])
  (eq? (f) (f))) → unspecified
(eq? (lambda (x) x) (lambda (y) y)) → unspecified

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eq? (f 0) (f 0))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (eqv? obj1 obj2)
    *возвращает:* #t if obj1 and obj2 are equivalent, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    eqv? is similar to eq? except eqv? is guaranteed to return #t for two characters that are considered equal by char=?
    and two numbers that are (a) considered equal by = and (b) cannot be distinguished by any other operation besides
    eq? and eqv?. A consequence of (b) is that (eqv? -0.0 +0.0) is #f even though (= -0.0 +0.0) is #t in systems that
    distinguish -0.0 and +0.0, such as those based on IEEE floating-point arithmetic. This is because operations such as
    / can expose the difference:

#+begin_src scheme
(/ 1.0 -0.0) → -inf.0
(/ 1.0 +0.0) → +inf.0
#+end_src

    Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they are not considered equivalent by eqv? if
    -0.0 and 0.0 have different representations.

#+begin_src scheme
(= 3.0+0.0i 3.0) → #t
(eqv? 3.0+0.0i 3.0) → #f
#+end_src

    The boolean value returned by eqv? is not specified when the arguments are NaNs.

#+begin_src scheme
(eqv? +nan.0 (/ 0.0 0.0)) → unspecified
#+end_src

    eqv? is less implementation-dependent but generally more expensive than eq?.

#+begin_src scheme
(eqv? 'a 3) → #f
(eqv? #t 't) → #f
(eqv? "abc" 'abc) → #f
(eqv? "hi" '(hi)) → #f
(eqv? #f '()) → #f

(eqv? 9/2 7/2) → #f
(eqv? 3.4 53344) → #f
(eqv? 3 3.0) → #f
(eqv? 1/3 #i1/3) → #f

(eqv? 9/2 9/2) → #t
(eqv? 3.4 (+ 3.0 .4)) → #t
(let ([x (* 12345678987654321 2)])
  (eqv? x x)) → #t

(eqv? #\a #\b) → #f
(eqv? #\a #\a) → #t
(let ([x (string-ref "hi" 0)])
  (eqv? x x)) → #t

(eqv? #t #t) → #t
(eqv? #f #f) → #t
(eqv? #t #f) → #f
(eqv? (null? '()) #t) → #t
(eqv? (null? '(a)) #f) → #t

(eqv? (cdr '(a)) '()) → #t

(eqv? 'a 'a) → #t
(eqv? 'a 'b) → #f
(eqv? 'a (string->symbol "a")) → #t

(eqv? '(a) '(b)) → #f
(eqv? '(a) '(a)) → unspecified
(let ([x '(a . b)]) (eqv? x x)) → #t
(let ([x (cons 'a 'b)])
  (eqv? x x)) → #t
(eqv? (cons 'a 'b) (cons 'a 'b)) → #f

(eqv? "abc" "cba") → #f
(eqv? "abc" "abc") → unspecified
(let ([x "hi"]) (eqv? x x)) → #t
(let ([x (string #\h #\i)]) (eqv? x x)) → #t
(eqv? (string #\h #\i)
      (string #\h #\i)) → #f

(eqv? '#vu8(1) '#vu8(1)) → unspecified
(eqv? '#vu8(1) '#vu8(2)) → #f
(let ([x (make-bytevector 10 0)])
  (eqv? x x)) → #t
(let ([x (make-bytevector 10 0)])
  (eqv? x (make-bytevector 10 0))) → #f

(eqv? '#(a) '#(b)) → #f
(eqv? '#(a) '#(a)) → unspecified
(let ([x '#(a)]) (eqv? x x)) → #t
(let ([x (vector 'a)])
  (eqv? x x)) → #t
(eqv? (vector 'a) (vector 'a)) → #f

(eqv? car car) → #t
(eqv? car cdr) → #f
(let ([f (lambda (x) x)])
  (eqv? f f)) → #t
(let ([f (lambda () (lambda (x) x))])
  (eqv? (f) (f))) → unspecified
(eqv? (lambda (x) x) (lambda (y) y)) → unspecified

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eqv? (f 0) (f 0))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (equal? obj1 obj2)
    *возвращает:* #t if obj1 and obj2 have the same structure and contents, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    Two objects are equal if they are equivalent according to eqv?, strings that are string=?, bytevectors that are
    bytevector=?, pairs whose cars and cdrs are equal, or vectors of the same length whose corresponding elements are
    equal.

    equal? is required to terminate even for cyclic arguments and return #t "if and only if the (possibly infinite)
    unfoldings of its arguments into regular trees are equal as ordered trees" [24]. In essence, two values are
    equivalent, in the sense of equal?, if the structure of the two objects cannot be distinguished by any composition
    of pair and vector accessors along with the eqv?, string=?, and bytevector=? procedures for comparing data at the
    leaves.

    Implementing equal? efficiently is tricky [1], and even with a good implementation, it is likely to be more
    expensive than either eqv? or eq?.

#+begin_src scheme
(equal? 'a 3) → #f
(equal? #t 't) → #f
(equal? "abc" 'abc) → #f
(equal? "hi" '(hi)) → #f
(equal? #f '()) → #f

(equal? 9/2 7/2) → #f
(equal? 3.4 53344) → #f
(equal? 3 3.0) → #f
(equal? 1/3 #i1/3) → #f

(equal? 9/2 9/2) → #t
(equal? 3.4 (+ 3.0 .4)) → #t
(let ([x (* 12345678987654321 2)])
  (equal? x x)) → #t

(equal? #\a #\b) → #f
(equal? #\a #\a) → #t
(let ([x (string-ref "hi" 0)])
  (equal? x x)) → #t

(equal? #t #t) → #t
(equal? #f #f) → #t
(equal? #t #f) → #f
(equal? (null? '()) #t) → #t
(equal? (null? '(a)) #f) → #t

(equal? (cdr '(a)) '()) → #t

(equal? 'a 'a) → #t
(equal? 'a 'b) → #f
(equal? 'a (string->symbol "a")) → #t

(equal? '(a) '(b)) → #f
(equal? '(a) '(a)) → #t
(let ([x '(a . b)]) (equal? x x)) → #t
(let ([x (cons 'a 'b)])
  (equal? x x)) → #t
(equal? (cons 'a 'b) (cons 'a 'b)) → #t

(equal? "abc" "cba") → #f
(equal? "abc" "abc") → #t
(let ([x "hi"]) (equal? x x)) → #t
(let ([x (string #\h #\i)]) (equal? x x)) → #t
(equal? (string #\h #\i)
        (string #\h #\i)) → #t

(equal? '#vu8(1) '#vu8(1)) → #t
(equal? '#vu8(1) '#vu8(2)) → #f
(let ([x (make-bytevector 10 0)])
  (equal? x x)) → #t
(let ([x (make-bytevector 10 0)])
  (equal? x (make-bytevector 10 0))) → #t

(equal? '#(a) '#(b)) → #f
(equal? '#(a) '#(a)) → #t
(let ([x '#(a)]) (equal? x x)) → #t
(let ([x (vector 'a)])
  (equal? x x)) → #t
(equal? (vector 'a) (vector 'a)) → #t

(equal? car car) → #t
(equal? car cdr) → #f
(let ([f (lambda (x) x)])
  (equal? f f)) → #t
(let ([f (lambda () (lambda (x) x))])
  (equal? (f) (f))) → unspecified
(equal? (lambda (x) x) (lambda (y) y)) → unspecified

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (equal? (f 0) (f 0))) → #f

(equal?
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    x)
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    (cons x x))) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (boolean? obj)
    *возвращает:* #t if obj is either #t or #f, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    boolean? is equivalent to (lambda (x) (or (eq? x #t) (eq? x #f))).

#+begin_src scheme
(boolean? #t) → #t
(boolean? #f) → #t
(or (boolean? 't) (boolean? '())) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (null? obj)
    *возвращает:* #t if obj is the empty list, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    null? is equivalent to (lambda (x) (eq? x '())).

#+begin_src scheme
(null? '()) → #t
(null? '(a)) → #f
(null? (cdr '(a))) → #t
(null? 3) → #f
(null? #f) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (pair? obj)
    *возвращает:* #t if obj is a pair, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(pair? '(a b c)) → #t
(pair? '(3 . 4)) → #t
(pair? '()) → #f
(pair? '#(a b)) → #f
(pair? 3) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (number? obj)
    *возвращает:* #t if obj is a number object, #f otherwise
    *процедура:* (complex? obj)
    *возвращает:* #t if obj is a complex number object, #f otherwise
    *процедура:* (real? obj)
    *возвращает:* #t if obj is a real number object, #f otherwise
    *процедура:* (rational? obj)
    *возвращает:* #t if obj is a rational number object, #f otherwise
    *процедура:* (integer? obj)
    *возвращает:* #t if obj is an integer object, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any
    complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real
    numbers are typically rational as well.

    The real?, rational?, and integer? predicates do not recognize as real, rational, or integer complex numbers with
    inexact zero imaginary parts.

#+begin_src scheme
(integer? 1901) → #t
(rational? 1901) → #t
(real? 1901) → #t
(complex? 1901) → #t
(number? 1901) → #t

(integer? -3.0) → #t
(rational? -3.0) → #t
(real? -3.0) → #t
(complex? -3.0) → #t
(number? -3.0) → #t

(integer? 7+0i) → #t
(rational? 7+0i) → #t
(real? 7+0i) → #t
(complex? 7+0i) → #t
(number? 7+0i) → #t

(integer? -2/3) → #f
(rational? -2/3) → #t
(real? -2/3) → #t
(complex? -2/3) → #t
(number? -2/3) → #t

(integer? -2.345) → #f
(rational? -2.345) → #t
(real? -2.345) → #t
(complex? -2.345) → #t
(number? -2.345) → #t

(integer? 7.0+0.0i) → #f
(rational? 7.0+0.0i) → #f
(real? 7.0+0.0i) → #f
(complex? 7.0+0.0i) → #t
(number? 7.0+0.0i) → #t

(integer? 3.2-2.01i) → #f
(rational? 3.2-2.01i) → #f
(real? 3.2-2.01i) → #f
(complex? 3.2-2.01i) → #t
(number? 3.2-2.01i) → #t

(integer? 'a) → #f
(rational? '(a b c)) → #f
(real? "3") → #f
(complex? '#(1 2)) → #f
(number? #\a) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (real-valued? obj)
    *возвращает:* #t if obj is a real number, #f otherwise
    *процедура:* (rational-valued? obj)
    *возвращает:* #t if obj is a rational number, #f otherwise
    *процедура:* (integer-valued? obj)
    *возвращает:* #t if obj is an integer, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    These predicates are similar to real?, rational?, and integer?, but treat as real, rational, or integral complex
    numbers with inexact zero imaginary parts.

#+begin_src scheme
(integer-valued? 1901) → #t
(rational-valued? 1901) → #t
(real-valued? 1901) → #t

(integer-valued? -3.0) → #t
(rational-valued? -3.0) → #t
(real-valued? -3.0) → #t

(integer-valued? 7+0i) → #t
(rational-valued? 7+0i) → #t
(real-valued? 7+0i) → #t

(integer-valued? -2/3) → #f
(rational-valued? -2/3) → #t
(real-valued? -2/3) → #t

(integer-valued? -2.345) → #f
(rational-valued? -2.345) → #t
(real-valued? -2.345) → #t

(integer-valued? 7.0+0.0i) → #t
(rational-valued? 7.0+0.0i) → #t
(real-valued? 7.0+0.0i) → #t

(integer-valued? 3.2-2.01i) → #f
(rational-valued? 3.2-2.01i) → #f
(real-valued? 3.2-2.01i) → #f
#+end_src

    As with real?, rational?, and integer?, these predicates return #f for all non-numeric values.

#+begin_src scheme
(integer-valued? 'a) → #f
(rational-valued? '(a b c)) → #f
(real-valued? "3") → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (char? obj)
    *возвращает:* #t if obj is a character, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(char? 'a) → #f
(char? 97) → #f
(char? #\a) → #t
(char? "a") → #f
(char? (string-ref (make-string 1) 0)) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (string? obj)
    *возвращает:* #t if obj is a string, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(string? "hi") → #t
(string? 'hi) → #f
(string? #\h) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector? obj)
    *возвращает:* #t if obj is a vector, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(vector? '#()) → #t
(vector? '#(a b c)) → #t
(vector? (vector 'a 'b 'c)) → #t
(vector? '()) → #f
(vector? '(a b c)) → #f
(vector? "abc") → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (symbol? obj)
    *возвращает:* #t if obj is a symbol, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(symbol? 't) → #t
(symbol? "t") → #f
(symbol? '(t)) → #f
(symbol? #\t) → #f
(symbol? 3) → #f
(symbol? #t) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (procedure? obj)
    *возвращает:* #t if obj is a procedure, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(procedure? car) → #t
(procedure? 'car) → #f
(procedure? (lambda (x) x)) → #t
(procedure? '(lambda (x) x)) → #f
(call/cc procedure?) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector? obj)
    *возвращает:* #t if obj is a bytevector, #f otherwise
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

#+begin_src scheme
(bytevector? #vu8()) → #t
(bytevector? '#()) → #f
(bytevector? "abc") → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable? obj)
    *возвращает:* #t if obj is a hashtable, #f otherwise
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

#+begin_src scheme
(hashtable? (make-eq-hashtable)) → #t
(hashtable? '(not a hash table)) → #f
#+end_src

*** Lists and Pairs

    The pair, or cons cell, is the most fundamental of Scheme's structured object types. The most common use for pairs
    is to build lists, which are ordered sequences of pairs linked one to the next by the cdr field. The elements of the
    list occupy the car fields of the pairs. The cdr of the last pair in a proper list is the empty list, (); the cdr of
    the last pair in an improper list can be anything other than ().

    Pairs may be used to construct binary trees. Each pair in the tree structure is an internal node of the binary tree;
    its car and cdr are the children of the node.

    Proper lists are printed as sequences of objects separated by whitespace and enclosed in parentheses. Matching pairs
    of brackets ( [ ] ) may be used in place of parentheses. For example, (1 2 3) and (a [nested list]) are proper
    lists. The empty list is written as ().

    Improper lists and trees require a slightly more complex syntax. A single pair is written as two objects separated
    by whitespace and a dot, e.g., (a . b). This is referred to as dotted-pair notation. Improper lists and trees are
    also written in dotted-pair notation; the dot appears wherever necessary, e.g., (1 2 3 . 4) or ((1 . 2) . 3). Proper
    lists may be written in dotted-pair notation as well. For example, (1 2 3) may be written as (1 . (2 . (3 . ()))).

    It is possible to create a circular list or a cyclic graph by destructively altering the car or cdr field of a pair,
    using set-car! or set-cdr!. Such lists are not considered proper lists.

    Procedures that accept a list argument are required to detect that the list is improper only to the extent that they
    actually traverse the list far enough either (a) to attempt to operate on a non-list tail or (b) to loop
    indefinitely due to a circularity. For example, member need not detect that a list is improper if it actually finds
    the element being sought, and list-ref need never detect circularities, because its recursion is bounded by the
    index argument.

#+BEGIN_VERSE
    *процедура:* (cons obj1 obj2)
    *возвращает:* a new pair whose car and cdr are obj1 and obj2
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    cons is the pair constructor procedure. obj1 becomes the car and obj2 becomes the cdr of the new pair.

#+begin_src scheme
(cons 'a '()) → (a)
(cons 'a '(b c)) → (a b c)
(cons 3 4) → (3 . 4)
#+end_src

#+BEGIN_VERSE
    *процедура:* (car pair)
    *возвращает:* the car of pair
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The empty list is not a pair, so the argument must not be the empty list.

#+begin_src scheme
(car '(a)) → a
(car '(a b c)) → a
(car (cons 3 4)) → 3
#+end_src

#+BEGIN_VERSE
    *процедура:* (cdr pair)
    *возвращает:* the cdr of pair
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The empty list is not a pair, so the argument must not be the empty list.

#+begin_src scheme
(cdr '(a)) → ()
(cdr '(a b c)) → (b c)
(cdr (cons 3 4)) → 4
#+end_src

#+BEGIN_VERSE
    *процедура:* (set-car! pair obj)
    *возвращает:* unspecified
    *библиотеки:* (rnrs mutable-pairs)
#+END_VERSE

    set-car! changes the car of pair to obj.

#+begin_src scheme
(let ([x (list 'a 'b 'c)])
  (set-car! x 1)
  x) → (1 b c)
#+end_src

#+BEGIN_VERSE
    *процедура:* (set-cdr! pair obj)
    *возвращает:* unspecified
    *библиотеки:* (rnrs mutable-pairs)
#+END_VERSE

    set-cdr! changes the cdr of pair to obj.

#+begin_src scheme
(let ([x (list 'a 'b 'c)])
  (set-cdr! x 1)
  x) → (a . 1)
#+end_src

#+BEGIN_VERSE
    *процедура:* (caar pair)
    *процедура:* (cadr pair)  →
    *процедура:* (cddddr pair)
    *возвращает:* the caar, cadr, ..., or cddddr of pair
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    These procedures are defined as the composition of up to four cars and cdrs. The a's and d's between the c and r
    represent the application of car or cdr in order from right to left. For example, the procedure cadr applied to a
    pair yields the car of the cdr of the pair and is equivalent to (lambda (x) (car (cdr x))).

#+begin_src scheme
(caar '((a))) → a
(cadr '(a b c)) → b
(cdddr '(a b c d)) → (d)
(cadadr '(a (b c))) → c
#+end_src

#+BEGIN_VERSE
    *процедура:* (list obj ...)
    *возвращает:* a list of obj ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    list is equivalent to (lambda x x).

#+begin_src scheme
(list) → ()
(list 1 2 3) → (1 2 3)
(list 3 2 1) → (3 2 1)
#+end_src

#+BEGIN_VERSE
    *процедура:* (cons* obj ... final-obj)
    *возвращает:* a list of obj ... terminated by final-obj
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    If the objects obj ... are omitted, the result is simply final-obj. Otherwise, a list of obj ... is constructed, as
    with list, except that the final cdr field is final-obj instead of (). If final-obj is not a list, the result is an
    improper list.

#+begin_src scheme
(cons* '()) → ()
(cons* '(a b)) → (a b)
(cons* 'a 'b 'c) → (a b . c)
(cons* 'a 'b '(c d)) → (a b c d)
#+end_src

#+BEGIN_VERSE
    *процедура:* (list? obj)
    *возвращает:* #t if obj is a proper list, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    list? must return #f for all improper lists, including cyclic lists. A definition of list? is shown on page 67.

#+begin_src scheme
(list? '()) → #t
(list? '(a b c)) → #t
(list? 'a) → #f
(list? '(3 . 4)) → #f
(list? 3) → #f
(let ([x (list 'a 'b 'c)])
  (set-cdr! (cddr x) x)
  (list? x)) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (length list)
    *возвращает:* the number of elements in list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    length may be defined as follows, using an adaptation of the hare and tortoise algorithm used for the definition of
    list? on page 67.

#+begin_src scheme
(define length
  (lambda (x)
    (define improper-list
      (lambda ()
        (assertion-violation 'length "not a proper list" x)))

    (let f ([h x] [t x] [n 0])
      (if (pair? h)
          (let ([h (cdr h)])
            (if (pair? h)
                (if (eq? h t)
                    (improper-list)
                    (f (cdr h) (cdr t) (+ n 2)))
                (if (null? h)
                    (+ n 1)
                    (improper-list))))
          (if (null? h)
              n
              (improper-list))))))

(length '()) → 0
(length '(a b c)) → 3
(length '(a b . c)) → exception
(length
  (let ([ls (list 'a 'b)])
    (set-cdr! (cdr ls) ls) → exception
    ls))
(length
  (let ([ls (list 'a 'b)])
    (set-car! (cdr ls) ls) → 2
    ls))
#+end_src

#+BEGIN_VERSE
    *процедура:* (list-ref list n)
    *возвращает:* the nth element (zero-based) of list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of list. list-ref may be defined without error checks as follows.

#+begin_src scheme
(define list-ref
  (lambda (ls n)
    (if (= n 0)
        (car ls)
        (list-ref (cdr ls) (- n 1)))))

(list-ref '(a b c) 0) → a
(list-ref '(a b c) 1) → b
(list-ref '(a b c) 2) → c
#+end_src

#+BEGIN_VERSE
    *процедура:* (list-tail list n)
    *возвращает:* the nth tail (zero-based) of list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than or equal to the length of list. The result is not a copy; the tail
    is eq? to the nth cdr of list (or to list itself, if n is zero).

    list-tail may be defined without error checks as follows.

#+begin_src scheme
(define list-tail
  (lambda (ls n)
    (if (= n 0)
        ls
        (list-tail (cdr ls) (- n 1)))))

(list-tail '(a b c) 0) → (a b c)
(list-tail '(a b c) 2) → (c)
(list-tail '(a b c) 3) → ()
(list-tail '(a b c . d) 2) → (c . d)
(list-tail '(a b c . d) 3) → d
(let ([x (list 1 2 3)])
  (eq? (list-tail x 2)
       (cddr x))) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (append)
    *процедура:* (append list ... obj)
    *возвращает:* the concatenation of the input lists
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    append returns a new list consisting of the elements of the first list followed by the elements of the second list,
    the elements of the third list, and so on. The new list is made from new pairs for all arguments but the last; the
    last (which need not be a list) is merely placed at the end of the new structure. append may be defined without
    error checks as follows.

#+begin_src scheme
(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))

(append '(a b c) '()) → (a b c)
(append '() '(a b c)) → (a b c)
(append '(a b) '(c d)) → (a b c d)
(append '(a b) 'c) → (a b . c)
(let ([x (list 'b)])
  (eq? x (cdr (append '(a) x)))) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (reverse list)
    *возвращает:* a new list containing the elements of list in reverse order
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    reverse may be defined without error checks as follows.

#+begin_src scheme
(define reverse
  (lambda (ls)
    (let rev ([ls ls] [new '()])
      (if (null? ls)
          new
          (rev (cdr ls) (cons (car ls) new))))))

(reverse '()) → ()
(reverse '(a b c)) → (c b a)
#+end_src

#+BEGIN_VERSE
    *процедура:* (memq obj list)
    *процедура:* (memv obj list)
    *процедура:* (member obj list)
    *возвращает:* the first tail of list whose car is equivalent to obj, or #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    These procedures traverse the argument list in order, comparing the elements of list against obj. If an object
    equivalent to obj is found, the tail of the list whose first element is that object is returned. If the list
    contains more than one object equivalent to obj, the first tail whose first element is equivalent to obj is
    returned. If no object equivalent to obj is found, #f is returned. The equivalence test for memq is eq?, for memv is
    eqv?, and for member is equal?.

    These procedures are most often used as predicates, but their names do not end with a question mark because they
    return a useful true value in place of #t. memq may be defined without error checks as follows.

#+begin_src scheme
(define memq
  (lambda (x ls)
    (cond
      [(null? ls) #f]
      [(eq? (car ls) x) ls]
      [else (memq x (cdr ls))])))
#+end_src

    memv and member may be defined similarly, with eqv? and equal? in place of eq?.

#+begin_src scheme
(memq 'a '(b c a d e)) → (a d e)
(memq 'a '(b c d e g)) → #f
(memq 'a '(b a c a d a)) → (a c a d a)

(memv 3.4 '(1.2 2.3 3.4 4.5)) → (3.4 4.5)
(memv 3.4 '(1.3 2.5 3.7 4.9)) → #f
(let ([ls (list 'a 'b 'c)])
  (set-car! (memv 'b ls) 'z)
  ls) → (a z c)

(member '(b) '((a) (b) (c))) → ((b) (c))
(member '(d) '((a) (b) (c))) → #f
(member "b" '("a" "b" "c")) → ("b" "c")

(let ()
  (define member?
    (lambda (x ls)
      (and (member x ls) #t)))
  (member? '(b) '((a) (b) (c)))) → #t

(define count-occurrences
  (lambda (x ls)
    (cond
      [(memq x ls) =>
       (lambda (ls)
         (+ (count-occurrences x (cdr ls)) 1))]
      [else 0])))

(count-occurrences 'a '(a b c d a)) → 2
#+end_src

#+BEGIN_VERSE
    *процедура:* (memp procedure list)
    *возвращает:* the first tail of list for whose car procedure returns true, or #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    procedure should accept one argument and return a single value. It should not modify list.

#+begin_src scheme
(memp odd? '(1 2 3 4)) → (1 2 3 4)
(memp even? '(1 2 3 4)) → (2 3 4)
(let ([ls (list 1 2 3 4)])
  (eq? (memp odd? ls) ls)) → #t
(let ([ls (list 1 2 3 4)])
  (eq? (memp even? ls) (cdr ls))) → #t
(memp odd? '(2 4 6 8)) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (remq obj list)
    *процедура:* (remv obj list)
    *процедура:* (remove obj list)
    *возвращает:* a list containing the elements of list with all occurrences of obj removed
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    These procedures traverse the argument list, removing any objects that are equivalent to obj. The elements remaining
    in the output list are in the same order as they appear in the input list. If a tail of list (including list itself)
    contains no occurrences of obj, the corresponding tail of the result list may be the same (by eq?) as the tail of
    the input list.

    The equivalence test for remq is eq?, for remv is eqv?, and for remove is equal?.

#+begin_src scheme
(remq 'a '(a b a c a d)) → (b c d)
(remq 'a '(b c d)) → (b c d)

(remv 1/2 '(1.2 1/2 0.5 3/2 4)) → (1.2 0.5 3/2 4)

(remove '(b) '((a) (b) (c))) → ((a) (c))
#+end_src

#+BEGIN_VERSE
    *процедура:* (remp procedure list)
    *возвращает:* a list of the elements of list for which procedure returns #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    procedure should accept one argument and return a single value. It should not modify list.

    remp applies procedure to each element of list and returns a list containing only the elements for which procedure
    returns #f. The elements of the returned list appear in the same order as they appeared in the original list.

#+begin_src scheme
(remp odd? '(1 2 3 4)) → (2 4)
(remp
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) → (-5 15 14 -20 0 -9)
#+end_src

#+BEGIN_VERSE
    *процедура:* (filter procedure list)
    *возвращает:* a list of the elements of list for which procedure returns true
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    procedure should accept one argument and return a single value. It should not modify list.

    filter applies procedure to each element of list and returns a new list containing only the elements for which
    procedure returns true. The elements of the returned list appear in the same order as they appeared in the original
    list.

#+begin_src scheme
(filter odd? '(1 2 3 4)) → (1 3)
(filter
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) → (3 6)
#+end_src

#+BEGIN_VERSE
    *процедура:* (partition procedure list)
    *возвращает:* see below
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    procedure should accept one argument and return a single value. It should not modify list.

    partition applies procedure to each element of list and returns two values: a new list containing only the elements
    for which procedure returns true, and a new list containing only the elements for which procedure returns #f. The
    elements of the returned lists appear in the same order as they appeared in the original list.

#+begin_src scheme
(partition odd? '(1 2 3 4)) → (1 3)
                             (2 4)
(partition
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) → (3 6)
                             (-5 15 14 -20 0 -9)
#+end_src

    The values returned by partition can be obtained by calling filter and remp separately, but this would require two
    calls to procedure for each element of list.

#+BEGIN_VERSE
    *процедура:* (find procedure list)
    *возвращает:* the first element of list for which procedure returns true, or #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    procedure should accept one argument and return a single value. It should not modify list.

    find traverses the argument list in order, applying procedure to each element in turn. If procedure returns a true
    value for a given element, find returns that element without applying procedure to the remaining elements. If
    procedure returns #f for each element of list, find returns #f.

    If a program must distinguish between finding #f in the list and finding no element at all, memp should be used
    instead.

#+begin_src scheme
(find odd? '(1 2 3 4)) → 1
(find even? '(1 2 3 4)) → 2
(find odd? '(2 4 6 8)) → #f
(find not '(1 a #f 55)) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (assq obj alist)
    *процедура:* (assv obj alist)
    *процедура:* (assoc obj alist)
    *возвращает:* first element of alist whose car is equivalent to obj, or #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    The argument alist must be an association list. An association list is a proper list whose elements are key-value
    pairs of the form (key . value). Associations are useful for storing information (values) associated with certain
    objects (keys).

    These procedures traverse the association list, testing each key for equivalence with obj. If an equivalent key is
    found, the key-value pair is returned. Otherwise, #f is returned.

    The equivalence test for assq is eq?, for assv is eqv?, and for assoc is equal?. assq may be defined without error
    checks as follows.

#+begin_src scheme
(define assq
  (lambda (x ls)
    (cond
      [(null? ls) #f]
      [(eq? (caar ls) x) (car ls)]
      [else (assq x (cdr ls))])))
#+end_src

    assv and assoc may be defined similarly, with eqv? and equal? in place of eq?.

#+begin_src scheme
(assq 'b '((a . 1) (b . 2))) → (b . 2)
(cdr (assq 'b '((a . 1) (b . 2)))) → 2
(assq 'c '((a . 1) (b . 2))) → #f

(assv 2/3 '((1/3 . 1) (2/3 . 2))) → (2/3 . 2)
(assv 2/3 '((1/3 . a) (3/4 . b))) → #f

(assoc '(a) '(((a) . a) (-1 . b))) → ((a) . a)
(assoc '(a) '(((b) . b) (a . c))) → #f

(let ([alist (list (cons 2 'a) (cons 3 'b))])
  (set-cdr! (assv 3 alist) 'c)
  alist) → ((2 . a) (3 . c))
#+end_src

    The interpreter given in Section 12.7 represents environments as association lists and uses assq for both variable
    lookup and assignment.

#+BEGIN_VERSE
    *процедура:* (assp procedure alist)
    *возвращает:* first element of alist for whose car procedure returns true, or #f
    *библиотеки:* (rnrs lists), (rnrs)
#+END_VERSE

    alist must be an association list. An association list is a proper list whose elements are key-value pairs of the
    form (key . value). procedure should accept one argument and return a single value. It should not modify list.

#+begin_src scheme
(assp odd? '((1 . a) (2 . b))) → (1 . a)
(assp even? '((1 . a) (2 . b))) → (2 . b)
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp odd? ls) (car ls))) → #t
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp even? ls) (cadr ls))) → #t
(assp odd? '((2 . b))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (list-sort predicate list)
    *возвращает:* a list containing the elements of list sorted according to predicate
    *библиотеки:* (rnrs sorting), (rnrs)
#+END_VERSE

    predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its
    second in the sorted list. That is, if predicate is applied to two elements x and y, where x appears after y in the
    input list, it should return true only if x should appear before y in the output list. If this constraint is met,
    list-sort performs a stable sort, i.e., two elements are reordered only when necessary according to
    predicate. Duplicate elements are not removed. This procedure may call predicate up to nlogn times, where n is the
    length of list.

#+begin_src scheme
(list-sort < '(3 4 2 1 2 5)) → (1 2 2 3 4 5)
(list-sort > '(0.5 1/2)) → (0.5 1/2)
(list-sort > '(1/2 0.5)) → (1/2 0.5)
(list->string
  (list-sort char>?
    (string->list "hello"))) → "ollhe"
#+end_src

*** Numbers

    Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This
    classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real
    numbers are complex. The predicates integer?, rational?, real?, and complex? described in Section 6.2 are used to
    determine into which of these classes a number falls.

    A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive
    the number and the inputs to these operations. The predicates exact? and inexact? may be used to determine the
    exactness of a number. Most operations on numbers in Scheme are exactness preserving: if given exact operands they
    return exact values, and if given inexact operands or a combination of exact and inexact operands they return
    inexact values.

    Exact integer and rational arithmetic is typically supported to arbitrary precision; the size of an integer or of
    the denominator or numerator of a ratio is limited only by system storage constraints. Although other
    representations are possible, inexact numbers are typically represented by floating-point numbers supported by the
    host computer's hardware or by system software. Complex numbers are typically represented as ordered pairs
    (real-part, imag-part), where real-part and imag-part are exact integers, exact rationals, or floating-point
    numbers.

    Scheme numbers are written in a straightforward manner not much different from ordinary conventions for writing
    numbers. An exact integer is normally written as a sequence of numerals preceded by an optional sign. For example,
    3, +19, -100000, and 208423089237489374 all represent exact integers.

    An exact rational number is normally written as two sequences of numerals separated by a slash (/) and preceded by
    an optional sign. For example, 3/4, -6/5, and 1/1208203823 are all exact rational numbers. A ratio is reduced
    immediately to lowest terms when it is read and may in fact reduce to an exact integer.

    Inexact real numbers are normally written in either floating-point or scientific notation. Floating-point notation
    consists of a sequence of numerals followed by a decimal point and another sequence of numerals, all preceded by an
    optional sign. Scientific notation consists of an optional sign, a sequence of numerals, an optional decimal point
    followed by a second string of numerals, and an exponent; an exponent is written as the letter e followed by an
    optional sign and a sequence of numerals. For example, 1.0 and -200.0 are valid inexact integers, and 1.5, 0.034,
    -10e-10 and 1.5e-5 are valid inexact rational numbers. The exponent is the power of ten by which the number
    preceding the exponent should be scaled, so that 2e3 is equivalent to 2000.0.

    A mantissa width |w may appear as the suffix of a real number or the real components of a complex number written in
    floating-point or scientific notation. The mantissa width w represents the number of significant bits in the
    representation of the number. The mantissa width defaults to 53, the number of significant bits in a normalized IEEE
    double floating-point number, or more. For denormalized IEEE double floating-point numbers, the mantissa width is
    less than 53. If an implementation cannot represent a number with the mantissa width specified, it uses a
    representation with at least as many significant bits as requested if possible, otherwise it uses its representation
    with the largest mantissa width.

    Exact and inexact real numbers are written as exact or inexact integers or rational numbers; no provision is made in
    the syntax of Scheme numbers for nonrational real numbers, i.e., irrational numbers.

    Complex numbers may be written in either rectangular or polar form. In rectangular form, a complex number is written
    as x+yi or x-yi, where x is an integer, rational, or real number and y is an unsigned integer, rational, or real
    number. The real part, x, may be omitted, in which case it is assumed to be zero. For example, 3+4i, 3.2-3/4i, +i,
    and -3e-5i are complex numbers written in rectangular form. In polar form, a complex number is written as x@y, where
    x and y are integer, rational, or real numbers. For example, 1.1@1.764 and -1@-1/2 are complex numbers written in
    polar form.

    The syntaxes +inf.0 and -inf.0 represent inexact real numbers that represent positive and negative infinity. The
    syntaxes +nan.0 and -nan.0 represent an inexact "not-a-number" (NaN) value. Infinities may be produced by dividing
    inexact positive and negative values by inexact zero, and NaNs may also be produced by dividing inexact zero by
    inexact zero, among other ways.

    The exactness of a numeric representation may be overridden by preceding the representation by either #e or #i. #e
    forces the number to be exact, and #i forces it to be inexact. For example, 1, #e1, 1/1, #e1/1, #e1.0, and #e1e0 all
    represent the exact integer 1, and #i3/10, 0.3, #i0.3, and 3e-1 all represent the inexact rational 0.3.

    Numbers are written by default in base 10, although the special prefixes #b (binary), #o (octal), #d (decimal), and
    #x (hexadecimal) can be used to specify base 2, base 8, base 10, or base 16. For radix 16, the letters a through f
    or A through F serve as the additional numerals required to express digit values 10 through 15. For example, #b10101
    is the binary equivalent of 2110, #o72 is the octal equivalent of 5810, and #xC7 is the hexadecimal equivalent
    of 19910. Numbers written in floating-point and scientific notations are always written in base 10.

    If both are present, radix and exactness prefixes may appear in either order.

    A Scheme implementation may support more than one size of internal representation for inexact quantities. The
    exponent markers s (short), f (single), d (double), and l (long) may appear in place of the default exponent marker
    e to override the default size for numbers written in scientific notation. In implementations that support multiple
    representations, the default size has at least as much precision as double.

    A precise grammar for Scheme numbers is given on page 459.

    Any number can be written in a variety of different ways, but the system printer (invoked by put-datum, write, and
    display) and number->string express numbers in a compact form, using the fewest number of digits necessary to retain
    the property that, when read, the printed number is identical to the original number.

    The remainder of this section describes "generic arithmetic" procedures that operate on numbers. The two sections
    that follow this section describe operations specific to fixnums and flonums, which are representations of exact,
    fixed-precision integer values and inexact real values.

    The types of numeric arguments accepted by the procedures in this section are implied by the names given to the
    arguments: num for complex numbers (that is, all numbers), real for real numbers, rat for rational numbers, and int
    for integers. If a real, rat, or int is required, the argument must be considered real, rational, or integral by
    real?, rational?, or integer?, i.e., the imaginary part of the number must be exactly zero. Where exact integers are
    required, the name exint is used. In each case, a suffix may appear on the name, e.g., int2.

#+BEGIN_VERSE
    *процедура:* (exact? num)
    *возвращает:* #t if num is exact, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(exact? 1) → #t
(exact? -15/16) → #t
(exact? 2.01) → #f
(exact? #i77) → #f
(exact? #i2/3) → #f
(exact? 1.0-2i) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (inexact? num)
    *возвращает:* #t if num is inexact, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(inexact? -123) → #f
(inexact? #i123) → #t
(inexact? 1e23) → #t
(inexact? +i) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (= num1 num2 num3 ...)
    *процедура:* (< real1 real2 real3 ...)
    *процедура:* (> real1 real2 real3 ...)
    *процедура:* (<= real1 real2 real3 ...)
    *процедура:* (>= real1 real2 real3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The predicate = returns #t if its arguments are equal. The predicate < returns #t if its arguments are monotonically
    increasing, i.e., each argument is greater than the preceding ones, while > returns #t if its arguments are
    monotonically decreasing. The predicate <= returns #t if its arguments are monotonically nondecreasing, i.e., each
    argument is not less than the preceding ones, while >= returns #t if its arguments are monotonically nonincreasing.

    As implied by the names of the arguments, = is defined for complex arguments while the other relational predicates
    are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are
    equal. Comparisons involving NaNs always return #f.

#+begin_src scheme
(= 7 7) → #t
(= 7 9) → #f

(< 2e3 3e2) → #f
(<= 1 2 3 3 4 5) → #t
(<= 1 2 3 4 5) → #t

(> 1 2 2 3 3 4) → #f
(>= 1 2 2 3 3 4) → #f

(= -1/2 -0.5) → #t
(= 2/3 .667) → #f
(= 7.2+0i 7.2) → #t
(= 7.2-3i 7) → #f

(< 1/2 2/3 3/4) → #t
(> 8 4.102 2/3 -5) → #t

(let ([x 0.218723452])
  (< 0.210 x 0.220)) → #t

(let ([i 1] [v (vector 'a 'b 'c)])
  (< -1 i (vector-length v))) → #t

(apply < '(1 2 3 4)) → #t
(apply > '(4 3 3 2)) → #f

(= +nan.0 +nan.0) → #f
(< +nan.0 +nan.0) → #f
(> +nan.0 +nan.0) → #f
(>= +inf.0 +nan.0) → #f
(>= +nan.0 -inf.0) → #f
(> +nan.0 0.0) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (+ num ...)
    *возвращает:* the sum of the arguments num ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    When called with no arguments, + returns 0.

#+begin_src scheme
(+) → 0
(+ 1 2) → 3
(+ 1/2 2/3) → 7/6
(+ 3 4 5) → 12
(+ 3.0 4) → 7.0
(+ 3+4i 4+3i) → 7+7i
(apply + '(1 2 3 4 5)) → 15
#+end_src

#+BEGIN_VERSE
    *процедура:* (- num)
    *возвращает:* the additive inverse of num
    *процедура:* (- num1 num2 num3 ...)
    *возвращает:* the difference between num1 and the sum of num2 num3 ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(- 3) → -3
(- -2/3) → 2/3
(- 4 3.0) → 1.0
(- 3.25+4.25i 1/4+1/4i) → 3.0+4.0i
(- 4 3 2 1) → -2
#+end_src

#+BEGIN_VERSE
    *процедура:* (* num ...)
    *возвращает:* the product of the arguments num ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    When called with no arguments, * returns 1.

#+begin_src scheme
(*) → 1
(* 3.4) → 3.4
(* 1 1/2) → 1/2
(* 3 4 5.5) → 66.0
(* 1+2i 3+4i) → -5+10i
(apply * '(1 2 3 4 5)) → 120
#+end_src

#+BEGIN_VERSE
    *процедура:* (/ num)
    *возвращает:* the multiplicative inverse of num
    *процедура:* (/ num1 num2 num3 ...)
    *возвращает:* the result of dividing num1 by the product of num2 num3 ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(/ -17) → -1/17
(/ 1/2) → 2
(/ .5) → 2.0
(/ 3 4) → 3/4
(/ 3.0 4) → .75
(/ -5+10i 3+4i) → 1+2i
(/ 60 5 4 3 2) → 1/2
#+end_src

#+BEGIN_VERSE
    *процедура:* (zero? num)
    *возвращает:* #t if num is zero, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    zero? is equivalent to (lambda (x) (= x 0)).

#+begin_src scheme
(zero? 0) → #t
(zero? 1) → #f
(zero? (- 3.0 3.0)) → #t
(zero? (+ 1/2 1/2)) → #f
(zero? 0+0i) → #t
(zero? 0.0-0.0i) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (positive? real)
    *возвращает:* #t if real is greater than zero, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    positive? is equivalent to (lambda (x) (> x 0)).

#+begin_src scheme
(positive? 128) → #t
(positive? 0.0) → #f
(positive? 1.8e-15) → #t
(positive? -2/3) → #f
(positive? .001-0.0i) → exception: not a real number
#+end_src

#+BEGIN_VERSE
    *процедура:* (negative? real)
    *возвращает:* #t if real is less than zero, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    negative? is equivalent to (lambda (x) (< x 0)).

#+begin_src scheme
(negative? -65) → #t
(negative? 0) → #f
(negative? -0.0121) → #t
(negative? 15/16) → #f
(negative? -7.0+0.0i) → exception: not a real number
#+end_src

#+BEGIN_VERSE
    *процедура:* (even? int)
    *возвращает:* #t if int is even, #f otherwise
    *процедура:* (odd? int)
    *возвращает:* #t if int is odd, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(even? 0) → #t
(even? 1) → #f
(even? 2.0) → #t
(even? -120762398465) → #f
(even? 2.0+0.0i) → exception: not an integer

(odd? 0) → #f
(odd? 1) → #t
(odd? 2.0) → #f
(odd? -120762398465) → #t
(odd? 2.0+0.0i) → exception: not an integer
#+end_src

#+BEGIN_VERSE
    *процедура:* (finite? real)
    *возвращает:* #t if real is finite, #f otherwise
    *процедура:* (infinite? real)
    *возвращает:* #t if real is infinite, #f otherwise
    *процедура:* (nan? real)
    *возвращает:* #t if real is a NaN, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(finite? 2/3) → #t
(infinite? 2/3) → #f
(nan? 2/3) → #f

(finite? 3.1415) → #t
(infinite? 3.1415) → #f
(nan? 3.1415) → #f

(finite? +inf.0) → #f
(infinite? -inf.0) → #t
(nan? -inf.0) → #f

(finite? +nan.0) → #f
(infinite? +nan.0) → #f
(nan? +nan.0) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (quotient int1 int2)
    *возвращает:* the integer quotient of int1 and int2
    *процедура:* (remainder int1 int2)
    *возвращает:* the integer remainder of int1 and int2
    *процедура:* (modulo int1 int2)
    *возвращает:* the integer modulus of int1 and int2
    *библиотеки:* (rnrs r5rs)
#+END_VERSE

    The result of remainder has the same sign as int1, while the result of modulo has the same sign as int2.

#+begin_src scheme
(quotient 45 6) → 7
(quotient 6.0 2.0) → 3.0
(quotient 3.0 -2) → -1.0

(remainder 16 4) → 0
(remainder 5 2) → 1
(remainder -45.0 7) → -3.0
(remainder 10.0 -3.0) → 1.0
(remainder -17 -9) → -8

(modulo 16 4) → 0
(modulo 5 2) → 1
(modulo -45.0 7) → 4.0
(modulo 10.0 -3.0) → -2.0
(modulo -17 -9) → -8
#+end_src

#+BEGIN_VERSE
    *процедура:* (div x1 x2)
    *процедура:* (mod x1 x2)
    *процедура:* (div-and-mod x1 x2)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If x1 and x2 are exact, x2 must not be zero. These procedures implement number-theoretic integer division, with the
    div operation being related to quotient and the mod operation being related to remainder or modulo, but in both
    cases extended to handle real numbers.

    The value nd of (div x1 x2) is an integer, and the value xm of (mod x1 x2) is a real number such that x1 = nd · x2 +
    xm and 0 ≤ xm < |x2|. In situations where the implementation cannot represent the mathematical results prescribed by
    these equations as a number object, div and mod return an unspecified number or raise an exception with condition
    type &implementation-restriction.

    The div-and-mod procedure behaves as if defined as follows.

#+begin_src scheme
(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))
#+end_src

    That is, unless it raises an exception in the circumstance described above, it returns two values: the result of
    calling div on the two arguments and the result of calling mod on the two arguments.

#+begin_src scheme
(div 17 3) → 5
(mod 17 3) → 2
(div -17 3) → -6
(mod -17 3) → 1
(div 17 -3) → -5
(mod 17 -3) → 2
(div -17 -3) → 6
(mod -17 -3) → 1

(div-and-mod 17.5 3) → 5.0
                      2.5
#+end_src

#+BEGIN_VERSE
    *процедура:* (div0 x1 x2)
    *процедура:* (mod0 x1 x2)
    *процедура:* (div0-and-mod0 x1 x2)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If x1 and x2 are exact, x2 must not be zero. These procedures are similar to div, mod, and div-and-mod, but
    constrain the "mod" value differently, which also affects the "div" value. The value nd of (div0 x1 x2) is an
    integer, and the value xm of (mod0 x1 x2) is a real number such that x1 = nd · x2 + xm and -|x2/2| ≤ xm < |x2/2|. In
    situations where the implementation cannot represent the mathematical results prescribed by these equations as a
    number object, div0 and mod0 return an unspecified number or raise an exception with condition type
    &implementation-restriction.

    The div0-and-mod0 procedure behaves as if defined as follows.

#+begin_src scheme
(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))
#+end_src

    That is, unless it raises an exception in the circumstance described above, it returns two values: the result of
    calling div0 on the two arguments and the result of calling mod0 on the two arguments.

#+begin_src scheme
(div0 17 3) → 6
(mod0 17 3) → -1
(div0 -17 3) → -6
(mod0 -17 3) → 1
(div0 17 -3) → -6
(mod0 17 -3) → -1
(div0 -17 -3) → 6
(mod0 -17 -3) → 1

(div0-and-mod0 17.5 3) → 6.0
                        -0.5
#+end_src

#+BEGIN_VERSE
    *процедура:* (truncate real)
    *возвращает:* the integer closest to real toward zero
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If real is an infinity or NaN, truncate returns real.

#+begin_src scheme
(truncate 19) → 19
(truncate 2/3) → 0
(truncate -2/3) → 0
(truncate 17.3) → 17.0
(truncate -17/2) → -8
#+end_src

#+BEGIN_VERSE
    *процедура:* (floor real)
    *возвращает:* the integer closest to real toward →
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If real is an infinity or NaN, floor returns real.

#+begin_src scheme
(floor 19) → 19
(floor 2/3) → 0
(floor -2/3) → -1
(floor 17.3) → 17.0
(floor -17/2) → -9
#+end_src

#+BEGIN_VERSE
    *процедура:* (ceiling real)
    *возвращает:* the integer closest to real toward →
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If real is an infinity or NaN, ceiling returns real.

#+begin_src scheme
(ceiling 19) → 19
(ceiling 2/3) → 1
(ceiling -2/3) → 0
(ceiling 17.3) → 18.0
(ceiling -17/2) → -8
#+end_src

#+BEGIN_VERSE
    *процедура:* (round real)
    *возвращает:* the integer closest to real
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If real is exactly between two integers, the closest even integer is returned. If real is an infinity or NaN, round
    returns real.

#+begin_src scheme
(round 19) → 19
(round 2/3) → 1
(round -2/3) → -1
(round 17.3) → 17.0
(round -17/2) → -8
(round 2.5) → 2.0
(round 3.5) → 4.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (abs real)
    *возвращает:* the absolute value of real
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    abs is equivalent to (lambda (x) (if (< x 0) (- x) x)). abs and magnitude (see page 183) are identical for real
    inputs.

#+begin_src scheme
(abs 1) → 1
(abs -3/4) → 3/4
(abs 1.83) → 1.83
(abs -0.093) → 0.093
#+end_src

#+BEGIN_VERSE
    *процедура:* (max real1 real2 ...)
    *возвращает:* the maximum of real1 real2 ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(max 4 -7 2 0 -6) → 4
(max 1/2 3/4 4/5 5/6 6/7) → 6/7
(max 1.5 1.3 -0.3 0.4 2.0 1.8) → 2.0
(max 5 2.0) → 5.0
(max -5 -2.0) → -2.0
(let ([ls '(7 3 5 2 9 8)])
  (apply max ls)) → 9
#+end_src

#+BEGIN_VERSE
    *процедура:* (min real1 real2 ...)
    *возвращает:* the minimum of real1 real2 ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(min 4 -7 2 0 -6) → -7
(min 1/2 3/4 4/5 5/6 6/7) → 1/2
(min 1.5 1.3 -0.3 0.4 2.0 1.8) → -0.3
(min 5 2.0) → 2.0
(min -5 -2.0) → -5.0
(let ([ls '(7 3 5 2 9 8)])
  (apply min ls)) → 2
#+end_src

#+BEGIN_VERSE
    *процедура:* (gcd int ...)
    *возвращает:* the greatest common divisor of its arguments int ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The result is always nonnegative, i.e., factors of -1 are ignored. When called with no arguments, gcd returns 0.

#+begin_src scheme
(gcd) → 0
(gcd 34) → 34
(gcd 33.0 15.0) → 3.0
(gcd 70 -42 28) → 14
#+end_src

#+BEGIN_VERSE
    *процедура:* (lcm int ...)
    *возвращает:* the least common multiple of its arguments int ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The result is always nonnegative, i.e., common multiples of -1 are ignored. Although lcm should probably return
    → when called with no arguments, it is defined to return 1. If one or more of the arguments is 0, lcm
    returns 0.

#+begin_src scheme
(lcm) → 1
(lcm 34) → 34
(lcm 33.0 15.0) → 165.0
(lcm 70 -42 28) → 420
(lcm 17.0 0) → 0.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (expt num1 num2)
    *возвращает:* num1 raised to the num2 power
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If both arguments are 0, expt returns 1.

#+begin_src scheme
(expt 2 10) → 1024
(expt 2 -10) → 1/1024
(expt 2 -10.0) → 9.765625e-4
(expt -1/2 5) → -1/32
(expt 3.0 3) → 27.0
(expt +i 2) → -1
#+end_src

#+BEGIN_VERSE
    *процедура:* (inexact num)
    *возвращает:* an inexact representation of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If num is already inexact, it is returned unchanged. If no inexact representation for num is supported by the
    implementation, an exception with condition type &implementation-violation may be raised. inexact may also return
    +inf.0 or -inf.0 for inputs whose magnitude exceeds the range of the implementation's inexact number
    representations.

#+begin_src scheme
(inexact 3) → 3.0
(inexact 3.0) → 3.0
(inexact -1/4) → -.25
(inexact 3+4i) → 3.0+4.0i
(inexact (expt 10 20)) → 1e20
#+end_src

#+BEGIN_VERSE
    *процедура:* (exact num)
    *возвращает:* an exact representation of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If num is already exact, it is returned unchanged. If no exact representation for num is supported by the
    implementation, an exception with condition type &implementation-violation may be raised.

#+begin_src scheme
(exact 3.0) → 3
(exact 3) → 3
(exact -.25) → -1/4
(exact 3.0+4.0i) → 3+4i
(exact 1e20) → 100000000000000000000
#+end_src

#+BEGIN_VERSE
    *процедура:* (exact->inexact num)
    *возвращает:* an inexact representation of num
    *процедура:* (inexact->exact num)
    *возвращает:* an exact representation of num
    *библиотеки:* (rnrs r5rs)
#+END_VERSE

    These are alternative names for inexact and exact, supported for compatibility with the Revised5 Report.

#+BEGIN_VERSE
    *процедура:* (rationalize real1 real2)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    rationalize returns the simplest rational number that differs from real1 by no more than real2. A rational number q1
    = n1/m1 is simpler than another rational number q2 = n2/m2 if |n1| ≤ |n2| and |m1| ≤ |m2| and either |n1| < |n2|
    or |m1| < |m2|.

#+begin_src scheme
(rationalize 3/10 1/10) → 1/3
(rationalize .3 1/10) → 0.3333333333333333
(eqv? (rationalize .3 1/10) #i1/3) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (numerator rat)
    *возвращает:* the numerator of rat
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If rat is an integer, the numerator is rat.

#+begin_src scheme
(numerator 9) → 9
(numerator 9.0) → 9.0
(numerator 0.0) → 0.0
(numerator 2/3) → 2
(numerator -9/4) → -9
(numerator -2.25) → -9.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (denominator rat)
    *возвращает:* the denominator of rat
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If rat is an integer, including zero, the denominator is one.

#+begin_src scheme
(denominator 9) → 1
(denominator 9.0) → 1.0
(denominator 0) → 1
(denominator 0.0) → 1.0
(denominator 2/3) → 3
(denominator -9/4) → 4
(denominator -2.25) → 4.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (real-part num)
    *возвращает:* the real component of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If num is real, real-part returns num.

#+begin_src scheme
(real-part 3+4i) → 3
(real-part -2.3+0.7i) → -2.3
(real-part -i) → 0
(real-part 17.2) → 17.2
(real-part -17/100) → -17/100
#+end_src

#+BEGIN_VERSE
    *процедура:* (imag-part num)
    *возвращает:* the imaginary component of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If num is real, imag-part returns exact zero.

#+begin_src scheme
(imag-part 3+4i) → 4
(imag-part -2.3+0.7i) → 0.7
(imag-part -i) → -1
(imag-part -2.5) → 0
(imag-part -17/100) → 0
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-rectangular real1 real2)
    *возвращает:* a complex number with real component real1 and imaginary component real2
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(make-rectangular -2 7) → -2+7i
(make-rectangular 2/3 -1/2) → 2/3-1/2i
(make-rectangular 3.2 5.3) → 3.2+5.3i
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-polar real1 real2)
    *возвращает:* a complex number with magnitude real1 and angle real2
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(make-polar 2 0) → 2
(make-polar 2.0 0.0) → 2.0+0.0i
(make-polar 1.0 (asin -1.0)) → 0.0-1.0i
(eqv? (make-polar 7.2 -0.588) 7.2@-0.588) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (angle num)
    *возвращает:* the angle part of the polar representation of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The range of the result is → (exclusive) to → (inclusive).

#+begin_src scheme
(angle 7.3@1.5708) → 1.5708
(angle 5.2) → 0.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (magnitude num)
    *возвращает:* the magnitude of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    magnitude and abs (see page 178) are identical for real arguments. The magnitude of a complex number x + yi is
    →.

#+begin_src scheme
(magnitude 1) → 1
(magnitude -3/4) → 3/4
(magnitude 1.83) → 1.83
(magnitude -0.093) → 0.093
(magnitude 3+4i) → 5
(magnitude 7.25@1.5708) → 7.25
#+end_src

#+BEGIN_VERSE
    *процедура:* (sqrt num)
    *возвращает:* the principal square root of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    Implementations are encouraged, but not required, to return exact results for exact inputs to sqrt whenever
    feasible.

#+begin_src scheme
(sqrt 16) → 4
(sqrt 1/4) → 1/2
(sqrt 4.84) → 2.2
(sqrt -4.84) → 0.0+2.2i
(sqrt 3+4i) → 2+1i
(sqrt -3.0-4.0i) → 1.0-2.0i
#+end_src

#+BEGIN_VERSE
    *процедура:* (exact-integer-sqrt n)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    This procedure returns two nonnegative exact integers s and r where n = s2 + r and n < (s + 1)2.

#+begin_src scheme
(exact-integer-sqrt 0) → 0
                        0
(exact-integer-sqrt 9) → 3
                       → 0
(exact-integer-sqrt 19) → 4
                        → 3
#+end_src

#+BEGIN_VERSE
    *процедура:* (exp num)
    *возвращает:* e to the num power
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(exp 0.0) → 1.0
(exp 1.0) → 2.7182818284590455
(exp -.5) → 0.6065306597126334
#+end_src

#+BEGIN_VERSE
    *процедура:* (log num)
    *возвращает:* the natural logarithm of num
    *процедура:* (log num1 num2)
    *возвращает:* the base-num2 logarithm of num1
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(log 1.0) → 0.0
(log (exp 1.0)) → 1.0
(/ (log 100) (log 10)) → 2.0
(log (make-polar (exp 2.0) 1.0)) → 2.0+1.0i

(log 100.0 10.0) → 2.0
(log .125 2.0) → -3.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (sin num)
    *процедура:* (cos num)
    *процедура:* (tan num)
    *возвращает:* the sine, cosine, or tangent of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The argument is specified in radians.

#+begin_src scheme
(sin 0.0) → 0.0
(cos 0.0) → 1.0
(tan 0.0) → 0.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (asin num)
    *процедура:* (acos num)
    *возвращает:* the arc sine or the arc cosine of num
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The result is in radians. The arc sine and arc cosine of a complex number z are defined as follows.

[[./images/17.png]]

[[./images/18.png]]

#+begin_src scheme
(define pi (* (asin 1) 2))
(= (* (acos 0) 2) pi) → #t

#+end_src

#+BEGIN_VERSE
    *процедура:* (atan num)
    *процедура:* (atan real1 real2)
    *возвращает:* see below
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    When passed a single complex argument num (the first form), atan returns the arc tangent of num. The arc tangent of
    a complex number z is defined as follows.

[[./images/19.png]]

    When passed two real arguments (the second form), atan is equivalent to (lambda (y x) (angle (make-rectangular x
    y))).

#+begin_src scheme
(define pi (* (atan 1) 4))
(= (* (atan 1.0 0.0) 2) pi) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-not exint)
    *возвращает:* the bitwise not of exint
    *процедура:* (bitwise-and exint ...)
    *возвращает:* the bitwise and of exint ...
    *процедура:* (bitwise-ior exint ...)
    *возвращает:* the bitwise inclusive or of exint ...
    *процедура:* (bitwise-xor exint ...)
    *возвращает:* the bitwise exclusive or of exint ...
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

#+begin_src scheme
(bitwise-not 0) → -1
(bitwise-not 3) → -4

(bitwise-and #b01101 #b00111) → #b00101
(bitwise-ior #b01101 #b00111) → #b01111
(bitwise-xor #b01101 #b00111) → #b01010
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-if exint1 exint2 exint3)
    *возвращает:* the bitwise "if" of its arguments
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

    For each bit set in exint1, the corresponding bit of the result is taken from exint2, and for each bit not set in
    exint1, the corresponding bit of the result is taken from x3.

#+begin_src scheme
(bitwise-if #b101010 #b111000 #b001100) → #b101100
#+end_src

    bitwise-if might be defined as follows:

#+begin_src scheme
(define bitwise-if
  (lambda (exint1 exint2 exint3)
    (bitwise-ior
      (bitwise-and exint1 exint2)
      (bitwise-and (bitwise-not exint1) exint3))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-bit-count exint)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    For nonnegative inputs, bitwise-bit-count returns the number of bits set in the two's complement representation of
    exint. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not
    set in the two's complement representation of exint, which is equivalent to (bitwise-not (bitwise-bit-count
    (bitwise-not exint))).

#+begin_src scheme
(bitwise-bit-count #b00000) → 0
(bitwise-bit-count #b00001) → 1
(bitwise-bit-count #b00100) → 1
(bitwise-bit-count #b10101) → 3

(bitwise-bit-count -1) → -1
(bitwise-bit-count -2) → -2
(bitwise-bit-count -4) → -3
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-length exint)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    This procedure returns the number of bits of the smallest two's complement representation of exint, not including
    the sign bit for negative numbers. For 0 bitwise-length returns 0.

#+begin_src scheme
(bitwise-length #b00000) → 0
(bitwise-length #b00001) → 1
(bitwise-length #b00100) → 3
(bitwise-length #b00110) → 3

(bitwise-length -1) → 0
(bitwise-length -6) → 3
(bitwise-length -9) → 4
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-first-bit-set exint)
    *возвращает:* the index of the least significant bit set in exint
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    The input is treated as if represented in two's complement, even if it is not represented that way internally.

    If exint is 0, bitwise-first-bit-set returns -1.

#+begin_src scheme
(bitwise-first-bit-set #b00000) → -1
(bitwise-first-bit-set #b00001) → 0
(bitwise-first-bit-set #b01100) → 2

(bitwise-first-bit-set -1) → 0
(bitwise-first-bit-set -2) → 1
(bitwise-first-bit-set -3) → 0
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-bit-set? exint1 exint2)
    *возвращает:* #t if bit exint2 of exint1 is set, #f otherwise
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. The two's
    complement representation of a nonnegative number conceptually extends to the left (toward more significant bits)
    with an infinite number of zero bits, and the two's complement representation of a negative number conceptually
    extends to the left with an infinite number of one bits. Thus, exact integers can be used to represent arbitrarily
    large sets, where 0 is the empty set, -1 is the universe, and bitwise-bit-set? is used to test for membership.

#+begin_src scheme
(bitwise-bit-set? #b01011 0) → #t
(bitwise-bit-set? #b01011 2) → #f

(bitwise-bit-set? -1 0) → #t
(bitwise-bit-set? -1 20) → #t
(bitwise-bit-set? -3 1) → #f

(bitwise-bit-set? 0 5000) → #f
(bitwise-bit-set? -1 5000) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-copy-bit exint1 exint2 exint3)
    *возвращает:* exint1 with bit exint2 replaced by exint3
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. exint3 must be
    0 or 1. This procedure effectively clears or sets the specified bit depending on the value of exint3. exint1 is
    treated as if represented in two's complement, even if it is not represented that way internally.

#+begin_src scheme
(bitwise-copy-bit #b01110 0 1) → #b01111
(bitwise-copy-bit #b01110 2 0) → #b01010
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-bit-field exint1 exint2 exint3)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the number
    represented by extracting from exint1 the sequence of bits from exint2 (inclusive) to exint3 (exclusive). exint1 is
    treated as if represented in two's complement, even if it is not represented that way internally.

#+begin_src scheme
(bitwise-bit-field #b10110 0 3) → #b00110
(bitwise-bit-field #b10110 1 3) → #b00011
(bitwise-bit-field #b10110 2 3) → #b00001
(bitwise-bit-field #b10110 3 3) → #b00000
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-copy-bit-field exint1 exint2 exint3 exint4)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns exint1
    with the n bits from exint2 (inclusive) to exint3 (exclusive) replaced by the low-order n bits of exint4. exint1 and
    exint4 are treated as if represented in two's complement, even if they are not represented that way internally.

#+begin_src scheme
(bitwise-copy-bit-field #b10000 0 3 #b10101) → #b10101
(bitwise-copy-bit-field #b10000 1 3 #b10101) → #b10010
(bitwise-copy-bit-field #b10000 2 3 #b10101) → #b10100
(bitwise-copy-bit-field #b10000 3 3 #b10101) → #b10000
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-arithmetic-shift-right exint1 exint2)
    *возвращает:* exint1 arithmetically shifted right by exint2 bits
    *процедура:* (bitwise-arithmetic-shift-left exint1 exint2)
    *возвращает:* exint1 shifted left by exint2 bits
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 must be nonnegative. exint1 is treated as if represented in two's complement, even if it is not represented
    that way internally.

#+begin_src scheme
(bitwise-arithmetic-shift-right #b10000 3) → #b00010
(bitwise-arithmetic-shift-right -1 1) → -1
(bitwise-arithmetic-shift-right -64 3) → -8

(bitwise-arithmetic-shift-left #b00010 2) → #b01000
(bitwise-arithmetic-shift-left -1 2) → -4
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-arithmetic-shift exint1 exint2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    If exint2 is negative, bitwise-arithmetic-shift returns the result of arithmetically shifting exint1 right by
    -exint2 bits. Otherwise, bitwise-arithmetic-shift returns the result of shifting exint1 left by exint2 bits. exint1
    is treated as if represented in two's complement, even if it is not represented that way internally.

#+begin_src scheme
(bitwise-arithmetic-shift #b10000 -3) → #b00010
(bitwise-arithmetic-shift -1 -1) → -1
(bitwise-arithmetic-shift -64 -3) → -8
(bitwise-arithmetic-shift #b00010 2) → #b01000
(bitwise-arithmetic-shift -1 2) → -4
#+end_src

    Thus, bitwise-arithmetic-shift behaves as if defined as follows.

#+begin_src scheme
(define bitwise-arithmetic-shift
  (lambda (exint1 exint2)
    (if (< exint2 0)
        (bitwise-arithmetic-shift-right exint1 (- exint2))
        (bitwise-arithmetic-shift-left exint1 exint2))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-rotate-bit-field exint1 exint2 exint3 exint4)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2, exint3, and exint4 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns
    the result of shifting the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive) left by (mod
    exint4 (- exint3 exint2)) bits, with the bits shifted out of the range inserted at the bottom end of the
    range. exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+begin_src scheme
(bitwise-rotate-bit-field #b00011010 0 5 3) → #b00010110
(bitwise-rotate-bit-field #b01101011 2 7 3) → #b01011011
#+end_src

#+BEGIN_VERSE
    *процедура:* (bitwise-reverse-bit-field exint1 exint2 exint3)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic bitwise), (rnrs)
#+END_VERSE

    exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the result
    of reversing the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive). exint1 is treated as if
    represented in two's complement, even if it is not represented that way internally.

#+begin_src scheme
(bitwise-reverse-bit-field #b00011010 0 5) → #b00001011
(bitwise-reverse-bit-field #b01101011 2 7) → #b00101111
#+end_src

#+BEGIN_VERSE
    *процедура:* (string->number string)
    *процедура:* (string->number string radix)
    *возвращает:* the number represented by string, or #f
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    If string is a valid representation of a number, that number is returned, otherwise #f is returned. The number is
    interpreted in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix defaults
    to 10. Any radix specifier within string, e.g., #x, overrides the radix argument.

#+begin_src scheme
(string->number "0") → 0
(string->number "3.4e3") → 3400.0
(string->number "#x#e-2e2") → -738
(string->number "#e-2e2" 16) → -738
(string->number "#i15/16") → 0.9375
(string->number "10" 16) → 16
#+end_src

#+BEGIN_VERSE
    *процедура:* (number->string num)
    *процедура:* (number->string num radix)
    *процедура:* (number->string num radix precision)
    *возвращает:* an external representation of num as a string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The num is expressed in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix
    defaults to 10. In any case, no radix specifier appears in the resulting string.

    The external representation is such that, when converted back into a number using string->number, the resulting
    numeric value is equivalent to num. That is, for all inputs:

#+begin_src scheme
(eqv? (string->number
        (number->string num radix)
        radix)
      num)
#+end_src

    returns #t. An exception with condition type &implementation-restriction is raised if this is not possible.

    If precision is provided, it must be an exact positive integer, num must be inexact, and radix must be 10. In this
    case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa
    width m, where m is the least possible value greater than or equal to precision that makes the expression above
    true.

    If radix is 10, inexact values of num are expressed using the fewest number of significant digits possible [5]
    without violating the above restriction.

#+begin_src scheme
(number->string 3.4) → "3.4"
(number->string 1e2) → "100.0"
(number->string 1e-23) → "1e-23"
(number->string -7/2) → "-7/2"
(number->string 220/9 16) → "DC/9"
#+end_src

*** Fixnums

    Fixnums represent exact integers in the fixnum range, which is required to be a closed range [-2w-1,2w-1 - 1], where
    w (the fixnum width) is at least 24. The implementation-specific value of w may be determined via the procedure
    fixnum-width, and the endpoints of the range may be determined via the procedures least-fixnum and greatest-fixnum.

    The names of arithmetic procedures that operate only on fixnums begin with the prefix "fx" to set them apart from
    their generic counterparts.

    Procedure arguments required to be fixnums are named fx, possibly with a suffix, e.g., fx2.

    Unless otherwise specified, the numeric values of fixnum-specific procedures are fixnums. If the value of a fixnum
    operation should be a fixnum, but the mathematical result would be outside the fixnum range, an exception with
    condition type &implementation-restriction is raised.

    Bit and shift operations on fixnums assume that fixnums are represented in two's complement, even if they are not
    represented that way internally.

#+BEGIN_VERSE
    *процедура:* (fixnum? obj)
    *возвращает:* #t if obj is a fixnum, #f otherwise
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fixnum? 0) → #t
(fixnum? -1) → #t
(fixnum? (- (expt 2 23))) → #t
(fixnum? (- (expt 2 23) 1)) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (least-fixnum)
    *возвращает:* the least (most negative) fixnum supported by the implementation
    *процедура:* (greatest-fixnum)
    *возвращает:* the greatest (most positive) fixnum supported by the implementation
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fixnum? (- (least-fixnum) 1)) → #f
(fixnum? (least-fixnum)) → #t
(fixnum? (greatest-fixnum)) → #t
(fixnum? (+ (greatest-fixnum) 1)) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (fixnum-width)
    *возвращает:* the implementation-dependent fixnum width
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    As described in the lead-in to this section, the fixnum width determines the size of the fixnum range and must be at
    least 24.

#+begin_src scheme
(define w (fixnum-width))
(= (least-fixnum) (- (expt 2 (- w 1)))) → #t
(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) → #t
(>= w 24) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (fx=? fx1 fx2 fx3 ...)
    *процедура:* (fx<? fx1 fx2 fx3 ...)
    *процедура:* (fx>? fx1 fx2 fx3 ...)
    *процедура:* (fx<=? fx1 fx2 fx3 ...)
    *процедура:* (fx>=? fx1 fx2 fx3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    The predicate fx=? returns #t if its arguments are equal. The predicate fx<? returns #t if its arguments are
    monotonically increasing, i.e., each argument is greater than the preceding ones, while fx>? returns #t if its
    arguments are monotonically decreasing. The predicate fx<=? returns #t if its arguments are monotonically
    nondecreasing, i.e., each argument is not less than the preceding ones, while fx>=? returns #t if its arguments are
    monotonically nonincreasing.

#+begin_src scheme
(fx=? 0 0) → #t
(fx=? -1 1) → #f
(fx<? (least-fixnum) 0 (greatest-fixnum)) → #t
(let ([x 3]) (fx<=? 0 x 9)) → #t
(fx>? 5 4 3 2 1) → #t
(fx<=? 1 3 2) → #f
(fx>=? 0 0 (least-fixnum)) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxzero? fx)
    *возвращает:* #t if fx is zero, #f otherwise
    *процедура:* (fxpositive? fx)
    *возвращает:* #t if fx is greater than zero, #f otherwise
    *процедура:* (fxnegative? fx)
    *возвращает:* #t if fx is less than zero, #f otherwise
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fxzero? is equivalent to (lambda (x) (fx=? x 0)), fxpositive? is equivalent to (lambda (x) (fx>? x 0)), and
    fxnegative? to (lambda (x) (fx<? x 0)).

#+begin_src scheme
(fxzero? 0) → #t
(fxzero? 1) → #f

(fxpositive? 128) → #t
(fxpositive? 0) → #f
(fxpositive? -1) → #f

(fxnegative? -65) → #t
(fxnegative? 0) → #f
(fxnegative? 1) → #f
#+end_src

#+BEGIN_VERSE
*процедура:* (fxeven? fx)
*возвращает:* #t if fx is even, #f otherwise
*процедура:* (fxodd? fx)
*возвращает:* #t if fx is odd, #f otherwise
*библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fxeven? 0) → #t
(fxeven? 1) → #f
(fxeven? -1) → #f
(fxeven? -10) → #t

(fxodd? 0) → #f
(fxodd? 1) → #t
(fxodd? -1) → #t
(fxodd? -10) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxmin fx1 fx2 ...)
    *возвращает:* the minimum of fx1 fx2 ...
    *процедура:* (fxmax fx1 fx2 ...)
    *возвращает:* the maximum of fx1 fx2 ...
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fxmin 4 -7 2 0 -6) → -7

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmin ls)) → 2

(fxmax 4 -7 2 0 -6) → 4

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmax ls)) → 9
#+end_src

#+BEGIN_VERSE
    *процедура:* (fx+ fx1 fx2)
    *возвращает:* the sum of fx1 and fx2
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fx+ -3 4) → 1
#+end_src

#+BEGIN_VERSE
    *процедура:* (fx- fx)
    *возвращает:* the additive inverse of fx
    *процедура:* (fx- fx1 fx2)
    *возвращает:* the difference between fx1 and fx2
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fx- 3) → -3
(fx- -3 4) → -7
#+end_src

#+BEGIN_VERSE
    *процедура:* (fx* fx1 fx2)
    *возвращает:* the product of fx1 and fx2
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fx* -3 4) → -12
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxdiv fx1 fx2)
    *процедура:* (fxmod fx1 fx2)
    *процедура:* (fxdiv-and-mod fx1 fx2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 must not be zero. These are fixnum-specific versions of the generic div, mod, and div-and-mod.

#+begin_src scheme
(fxdiv 17 3) → 5
(fxmod 17 3) → 2
(fxdiv -17 3) → -6
(fxmod -17 3) → 1
(fxdiv 17 -3) → -5
(fxmod 17 -3) → 2
(fxdiv -17 -3) → 6
(fxmod -17 -3) → 1

(fxdiv-and-mod 17 3) → 5
                               2
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxdiv0 fx1 fx2)
    *процедура:* (fxmod0 fx1 fx2)
    *процедура:* (fxdiv0-and-mod0 fx1 fx2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 must not be zero. These are fixnum-specific versions of the generic div0, mod0, and div0-and-mod0.

#+begin_src scheme
(fxdiv0 17 3) → 6
(fxmod0 17 3) → -1
(fxdiv0 -17 3) → -6
(fxmod0 -17 3) → 1
(fxdiv0 17 -3) → -6
(fxmod0 17 -3) → -1
(fxdiv0 -17 -3) → 6
(fxmod0 -17 -3) → 1

(fxdiv0-and-mod0 17 3) → 6
                                 -1
#+end_src

#+BEGIN_VERSE
    *процедура:* (fx+/carry fx1 fx2 fx3)
    *процедура:* (fx-/carry fx1 fx2 fx3)
    *процедура:* (fx*/carry fx1 fx2 fx3)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These
    alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They
    can be used to implement portable code for multiple-precision arithmetic.

    These procedures return the two fixnum values of the following computations. For fx+/carry:

#+begin_src scheme
(let* ([s (+ fx1 fx2 fx3)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))
#+end_src

    for fx-/carry:

#+begin_src scheme
(let* ([d (- fx1 fx2 fx3)]
       [d0 (mod0 d (expt 2 (fixnum-width)))]
       [d1 (div0 d (expt 2 (fixnum-width)))])
  (values d0 d1))
#+end_src

    and for fx*/carry:

#+begin_src scheme
(let* ([s (+ (* fx1 fx2) fx3)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxnot fx)
    *возвращает:* the bitwise not of fx
    *процедура:* (fxand fx ...)
    *возвращает:* the bitwise and of fx ...
    *процедура:* (fxior fx ...)
    *возвращает:* the bitwise inclusive or of fx ...
    *процедура:* (fxxor fx ...)
    *возвращает:* the bitwise exclusive or of fx ...
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fxnot 0) → -1
(fxnot 3) → -4

(fxand #b01101 #b00111) → #b00101
(fxior #b01101 #b00111) → #b01111
(fxxor #b01101 #b00111) → #b01010
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxif fx1 fx2 fx3)
    *возвращает:* the bitwise "if" of its arguments
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    For each bit set in fx1, the corresponding bit of the result is taken from fx2, and for each bit not set in fx1, the
    corresponding bit of the result is taken from x3.

#+begin_src scheme
(fxif #b101010 #b111000 #b001100) → #b101100
#+end_src

    fxif might be defined as follows:

#+begin_src scheme
(define fxif
  (lambda (fx1 fx2 fx3)
    (fxior (fxand fx1 fx2)
           (fxand (fxnot fx1) fx3))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxbit-count fx)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    For nonnegative inputs, fxbit-count returns the number of bits set in the two's complement representation of fx. For
    negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in fx,
    which is equivalent to (fxnot (fxbit-count (fxnot fx))).

#+begin_src scheme
(fxbit-count #b00000) → 0
(fxbit-count #b00001) → 1
(fxbit-count #b00100) → 1
(fxbit-count #b10101) → 3

(fxbit-count -1) → -1
(fxbit-count -2) → -2
(fxbit-count -4) → -3
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxlength fx)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    This procedure returns the number of bits of the smallest two's complement representation of fx, not including the
    sign bit for negative numbers. For 0 fxlength returns 0.

#+begin_src scheme
(fxlength #b00000) → 0
(fxlength #b00001) → 1
(fxlength #b00100) → 3
(fxlength #b00110) → 3

(fxlength -1) → 0
(fxlength -6) → 3
(fxlength -9) → 4
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxfirst-bit-set fx)
    *возвращает:* the index of the least significant bit set in fx
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    If fx is 0, fxfirst-bit-set returns -1.

#+begin_src scheme
(fxfirst-bit-set #b00000) → -1
(fxfirst-bit-set #b00001) → 0
(fxfirst-bit-set #b01100) → 2

(fxfirst-bit-set -1) → 0
(fxfirst-bit-set -2) → 1
(fxfirst-bit-set -3) → 0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxbit-set? fx1 fx2)
    *возвращает:* #t if bit fx2 of fx1 is set, #f otherwise
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 must be nonnegative. It is taken as a zero-based index for the bits in the two's complement representation of
    fx1, with the sign bit virtually replicated an infinite number of positions to the left.

#+begin_src scheme
(fxbit-set? #b01011 0) → #t
(fxbit-set? #b01011 2) → #f

(fxbit-set? -1 0) → #t
(fxbit-set? -1 20) → #t
(fxbit-set? -3 1) → #f
(fxbit-set? 0 (- (fixnum-width) 1)) → #f
(fxbit-set? -1 (- (fixnum-width) 1)) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxcopy-bit fx1 fx2 fx3)
    *возвращает:* fx1 with bit fx2 replaced by fx3
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 must be nonnegative and less than the value of (- (fixnum-width) 1). fx3 must be 0 or 1. This procedure
    effectively clears or sets the specified bit depending on the value of fx3.

#+begin_src scheme
(fxcopy-bit #b01110 0 1) → #b01111
(fxcopy-bit #b01110 2 0) → #b01010
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxbit-field fx1 fx2 fx3)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than
    fx3. This procedure returns the number represented by extracting from fx1 the sequence of bits from fx2 (inclusive)
    to fx3 (exclusive).

#+begin_src scheme
(fxbit-field #b10110 0 3) → #b00110
(fxbit-field #b10110 1 3) → #b00011
(fxbit-field #b10110 2 3) → #b00001
(fxbit-field #b10110 3 3) → #b00000
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxcopy-bit-field fx1 fx2 fx3 fx4)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than
    fx3. This procedure returns fx1 with n bits from fx2 (inclusive) to fx3 (exclusive) replaced by the low-order n bits
    of x4.

#+begin_src scheme
(fxcopy-bit-field #b10000 0 3 #b10101) → #b10101
(fxcopy-bit-field #b10000 1 3 #b10101) → #b10010
(fxcopy-bit-field #b10000 2 3 #b10101) → #b10100
(fxcopy-bit-field #b10000 3 3 #b10101) → #b10000
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxarithmetic-shift-right fx1 fx2)
    *возвращает:* fx1 arithmetically shifted right by fx2 bits
    *процедура:* (fxarithmetic-shift-left fx1 fx2)
    *возвращает:* fx1 shifted left by fx2 bits
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 must be nonnegative and less than the value of (fixnum-width).

#+begin_src scheme
(fxarithmetic-shift-right #b10000 3) → #b00010
(fxarithmetic-shift-right -1 1) → -1
(fxarithmetic-shift-right -64 3) → -8

(fxarithmetic-shift-left #b00010 2) → #b01000
(fxarithmetic-shift-left -1 2) → -4
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxarithmetic-shift fx1 fx2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    The absolute value of fx2 must be less than the value of (fixnum-width). If fx2 is negative, fxarithmetic-shift
    returns the result of arithmetically shifting fx1 right by fx2 bits. Otherwise, fxarithmetic-shift returns the
    result of shifting fx1 left by fx2 bits.

#+begin_src scheme
(fxarithmetic-shift #b10000 -3) → #b00010
(fxarithmetic-shift -1 -1) → -1
(fxarithmetic-shift -64 -3) → -8
(fxarithmetic-shift #b00010 2) → #b01000
(fxarithmetic-shift -1 2) → -4
#+end_src

    Thus, fxarithmetic-shift behaves as if defined as follows.

#+begin_src scheme
(define fxarithmetic-shift
  (lambda (fx1 fx2)
    (if (fx<? fx2 0)
        (fxarithmetic-shift-right fx1 (fx- fx2))
        (fxarithmetic-shift-left fx1 fx2))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxrotate-bit-field fx1 fx2 fx3 fx4)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2, fx3, and fx4 must be nonnegative and less than the value of (fixnum-width), fx2 must not be greater than fx3,
    and fx4 must not be greater than the difference between fx3 and fx2.

    This procedure returns the result of shifting the bits of fx1 from bit fx2 (inclusive) through bit fx3 (exclusive)
    left by fx4 bits, with the bits shifted out of the range inserted at the bottom end of the range.

#+begin_src scheme
(fxrotate-bit-field #b00011010 0 5 3) → #b00010110
(fxrotate-bit-field #b01101011 2 7 3) → #b01011011
#+end_src

#+BEGIN_VERSE
    *процедура:* (fxreverse-bit-field fx1 fx2 fx3)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic fixnums), (rnrs)
#+END_VERSE

    fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than
    fx3. This procedure returns the result of reversing the bits of fx1 from bit fx2 (inclusive) through bit fx3
    (exclusive).

#+begin_src scheme
(fxreverse-bit-field #b00011010 0 5) → #b00001011
(fxreverse-bit-field #b01101011 2 7) → #b00101111
#+end_src

*** Flonums

    Flonums represent inexact real numbers. Implementations are required to represent as a flonum any inexact real
    number whose lexical syntax contains no vertical bar and no exponent marker other than e, but are not required to
    represent any other inexact real number as a flonum.

    Implementations typically use the IEEE double-precision floating-point representation for flonums, but
    implementations are not required to do so or even to use a floating-point representation of any sort, despite the
    name "flonum."

    This section describes operations on flonums. Flonum-specific procedure names begin with the prefix "fl" to set them
    apart from their generic counterparts.

    Procedure arguments required to be flonums are named fl, possibly with suffix, e.g., fl2. Unless otherwise
    specified, the numeric values of flonum-specific procedures are flonums.

#+BEGIN_VERSE
    *процедура:* (flonum? obj)
    *возвращает:* #t if obj is a flonum, otherwise #f
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flonum? 0) → #f
(flonum? 3/4) → #f
(flonum? 3.5) → #t
(flonum? .02) → #t
(flonum? 1e10) → #t
(flonum? 3.0+0.0i) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (fl=? fl1 fl2 fl3 ...)
    *процедура:* (fl<? fl1 fl2 fl3 ...)
    *процедура:* (fl>? fl1 fl2 fl3 ...)
    *процедура:* (fl<=? fl1 fl2 fl3 ...)
    *процедура:* (fl>=? fl1 fl2 fl3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    The predicate fl=? returns #t if its arguments are equal. The predicate fl<? returns #t if its arguments are
    monotonically increasing, i.e., each argument is greater than the preceding ones, while fl>? returns #t if its
    arguments are monotonically decreasing. The predicate fl<=? returns #t if its arguments are monotonically
    nondecreasing, i.e., each argument is not less than the preceding ones, while fl>=? returns #t if its arguments are
    monotonically nonincreasing. When passed only one argument, each of these predicates returns #t.

    Comparisons involving NaNs always return #f.

#+begin_src scheme
(fl=? 0.0 0.0) → #t
(fl<? -1.0 0.0 1.0) → #t
(fl>? -1.0 0.0 1.0) → #f
(fl<=? 0.0 3.0 3.0) → #t
(fl>=? 4.0 3.0 3.0) → #t
(fl<? 7.0 +inf.0) → #t
(fl=? +nan.0 0.0) → #f
(fl=? +nan.0 +nan.0) → #f
(fl<? +nan.0 +nan.0) → #f
(fl<=? +nan.0 +inf.0) → #f
(fl>=? +nan.0 +inf.0) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (flzero? fl)
    *возвращает:* #t if fl is zero, #f otherwise
    *процедура:* (flpositive? fl)
    *возвращает:* #t if fl is greater than zero, #f otherwise
    *процедура:* (flnegative? fl)
    *возвращает:* #t if fl is less than zero, #f otherwise
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    flzero? is equivalent to (lambda (x) (fl=? x 0.0)), flpositive? is equivalent to (lambda (x) (fl>? x 0.0)), and
    flnegative? to (lambda (x) (fl<? x 0.0)).

    Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.

#+begin_src scheme
(flzero? 0.0) → #t
(flzero? 1.0) → #f

(flpositive? 128.0) → #t
(flpositive? 0.0) → #f
(flpositive? -1.0) → #f

(flnegative? -65.0) → #t
(flnegative? 0.0) → #f
(flnegative? 1.0) → #f

(flzero? -0.0) → #t
(flnegative? -0.0) → #f

(flnegative? +nan.0) → #f
(flzero? +nan.0) → #f
(flpositive? +nan.0) → #f

(flnegative? +inf.0) → #f
(flnegative? -inf.0) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (flinteger? fl)
    *возвращает:* #t if fl is integer, #f otherwise
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flinteger? 0.0) → #t
(flinteger? -17.0) → #t
(flinteger? +nan.0) → #f
(flinteger? +inf.0) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (flfinite? fl)
    *возвращает:* #t if fl is finite, #f otherwise
    *процедура:* (flinfinite? fl)
    *возвращает:* #t if fl is infinite, #f otherwise
    *процедура:* (flnan? fl)
    *возвращает:* #t if fl is a NaN, #f otherwise
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flfinite? 3.1415) → #t
(flinfinite? 3.1415) → #f
(flnan? 3.1415) → #f

(flfinite? +inf.0) → #f
(flinfinite? -inf.0) → #t
(flnan? -inf.0) → #f

(flfinite? +nan.0) → #f
(flinfinite? +nan.0) → #f
(flnan? +nan.0) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (fleven? fl-int)
    *возвращает:* #t if fl-int is even, #f otherwise
    *процедура:* (flodd? fl-int)
    *возвращает:* #t if fl-int is odd, #f otherwise
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    fl-int must be an integer-valued flonum.

#+begin_src scheme
(fleven? 0.0) → #t
(fleven? 1.0) → #f
(fleven? -1.0) → #f
(fleven? -10.0) → #t

(flodd? 0.0) → #f
(flodd? 1.0) → #t
(flodd? -1.0) → #t
(flodd? -10.0) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (flmin fl1 fl2 ...)
    *возвращает:* the minimum of fl1 fl2 ...
    *процедура:* (flmax fl1 fl2 ...)
    *возвращает:* the maximum of fl1 fl2 ...
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flmin 4.2 -7.5 2.0 0.0 -6.4) → -7.5

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmin ls)) → 2.6

(flmax 4.2 -7.5 2.0 0.0 -6.4) → 4.2

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmax ls)) → 8.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fl+ fl ...)
    *возвращает:* the sum of the arguments fl ...
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    When called with no arguments, fl+ returns 0.0.

#+begin_src scheme
(fl+) → 0.0
(fl+ 1.0 2.5) → 3.25
(fl+ 3.0 4.25 5.0) → 12.25
(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) → 15.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fl- fl)
    *возвращает:* the additive inverse of fl
    *процедура:* (fl- fl1 fl2 fl3 ...)
    *возвращает:* the difference between fl1 and the sum of fl2 fl3 ...
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    With an IEEE floating-point representation of flonums, the single-argument fl- is equivalent to

#+begin_src scheme
(lambda (x) (fl* -1.0 x))
#+end_src

    or

#+begin_src scheme
(lambda (x) (fl- -0.0 x))
#+end_src

    but not

#+begin_src scheme
(lambda (x) (fl- 0.0 x))
#+end_src

    since the latter returns 0.0 rather than -0.0 for 0.0.

#+begin_src scheme
(fl- 0.0) → -0.0
(fl- 3.0) → -3.0
(fl- 4.0 3.0) → 1.0
(fl- 4.0 3.0 2.0 1.0) → -2.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fl* fl ...)
    *возвращает:* the product of the arguments fl ...
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    When called with no arguments, fl* returns 1.0.

#+begin_src scheme
(fl*) → 1.0
(fl* 1.5 2.5) → 3.75
(fl* 3.0 -4.0 5.0) → -60.0
(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) → 120.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fl/ fl)
    *возвращает:* the multiplicative inverse of fl
    *процедура:* (fl/ fl1 fl2 fl3 ...)
    *возвращает:* the result of dividing fl1 by the product of fl2 fl3 ...
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(fl/ -4.0) → -0.25
(fl/ 8.0 -2.0) → -4.0
(fl/ -9.0 2.0) → -4.5
(fl/ 60.0 5.0 3.0 2.0) → 2.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fldiv fl1 fl2)
    *процедура:* (flmod fl1 fl2)
    *процедура:* (fldiv-and-mod fl1 fl2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    These are flonum-specific versions of the generic div, mod, and div-and-mod.

#+begin_src scheme
(fldiv 17.0 3.0) → 5.0
(flmod 17.0 3.0) → 2.0
(fldiv -17.0 3.0) → -6.0
(flmod -17.0 3.0) → 1.0
(fldiv 17.0 -3.0) → -5.0
(flmod 17.0 -3.0) → 2.0
(fldiv -17.0 -3.0) → 6.0
(flmod -17.0 -3.0) → 1.0

(fldiv-and-mod 17.5 3.75) → 4.0
                                    2.5
#+end_src

#+BEGIN_VERSE
    *процедура:* (fldiv0 fl1 fl2)
    *процедура:* (flmod0 fl1 fl2)
    *процедура:* (fldiv0-and-mod0 fl1 fl2)
    *возвращает:* see below
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    These are flonum-specific versions of the generic div0, mod0, and div0-and-mod0.

#+begin_src scheme
(fldiv0 17.0 3.0) → 6.0
(flmod0 17.0 3.0) → -1.0
(fldiv0 -17.0 3.0) → -6.0
(flmod0 -17.0 3.0) → 1.0
(fldiv0 17.0 -3.0) → -6.0
(flmod0 17.0 -3.0) → -1.0
(fldiv0 -17.0 -3.0) → 6.0
(flmod0 -17.0 -3.0) → 1.0

(fldiv0-and-mod0 17.5 3.75) → 5.0
                                      -1.25
#+end_src

#+BEGIN_VERSE
    *процедура:* (flround fl)
    *возвращает:* the integer closest to fl
    *процедура:* (fltruncate fl)
    *возвращает:* the integer closest to fl toward zero
    *процедура:* (flfloor fl)
    *возвращает:* the integer closest to fl toward →
    *процедура:* (flceiling fl)
    *возвращает:* the integer closest to fl toward →
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    If fl is an integer, NaN, or infinity, each of these procedures returns fl. If fl is exactly between two integers,
    flround returns the closest even integer.

#+begin_src scheme
(flround 17.3) → 17.0
(flround -17.3) → -17.0
(flround 2.5) → 2.0
(flround 3.5) → 4.0

(fltruncate 17.3) → 17.0
(fltruncate -17.3) → -17.0

(flfloor 17.3) → 17.0
(flfloor -17.3) → -18.0

(flceiling 17.3) → 18.0
(flceiling -17.3) → -17.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (flnumerator fl)
    *возвращает:* the numerator of fl
    *процедура:* (fldenominator fl)
    *возвращает:* the denominator of fl
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    If fl is an integer, including 0.0, or infinity, the numerator is fl and the denominator is 1.0.

#+begin_src scheme
(flnumerator -9.0) → -9.0
(fldenominator -9.0) → 1.0
(flnumerator 0.0) → 0.0
(fldenominator 0.0) → 1.0
(flnumerator -inf.0) → -inf.0
(fldenominator -inf.0) → 1.0
#+end_src

    The following hold for IEEE floats, but not necessarily other flonum representations.

#+begin_src scheme
(flnumerator 3.5) → 7.0
(fldenominator 3.5) → 2.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (flabs fl)
    *возвращает:* absolute value of fl
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flabs 3.2) → 3.2
(flabs -2e-20) → 2e-20
#+end_src

#+BEGIN_VERSE
    *процедура:* (flexp fl)
    *возвращает:* e to the fl power
    *процедура:* (fllog fl)
    *возвращает:* the natural logarithm of fl
    *процедура:* (fllog fl1 fl2)
    *возвращает:* the base-fl2 logarithm of fl1
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

#+begin_src scheme
(flexp 0.0) → 1.0
(flexp 1.0) → 2.7182818284590455

(fllog 1.0) → 0.0
(fllog (exp 1.0)) → 1.0
(fl/ (fllog 100.0) (fllog 10.0)) → 2.0

(fllog 100.0 10.0) → 2.0
(fllog .125 2.0) → -3.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (flsin fl)
    *возвращает:* the sine of fl
    *процедура:* (flcos fl)
    *возвращает:* the cosine of fl
    *процедура:* (fltan fl)
    *возвращает:* the tangent of fl
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)


    *процедура:* (flasin fl)
    *возвращает:* the arc sine of fl
    *процедура:* (flacos fl)
    *возвращает:* the arc cosine of fl
    *процедура:* (flatan fl)
    *возвращает:* the arc tangent of fl
    *процедура:* (flatan fl1 fl2)
    *возвращает:* the arc tangent of fl1/fl2
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)

    *процедура:* (flsqrt fl)
    *возвращает:* the principal square root of fl
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    Returns the principal square root of fl. The square root of -0.0 should be -0.0. The result for other negative
    numbers may be a NaN or some other unspecified flonum.

#+begin_src scheme
(flsqrt 4.0) → 2.0
(flsqrt 0.0) → 0.0
(flsqrt -0.0) → -0.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (flexpt fl1 fl2)
    *возвращает:* fl1 raised to the fl2 power
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    If fl1 is negative and fl2 is not an integer, the result may be a NaN or some other unspecified flonum. If fl1 and
    fl2 are both zero, the result is 1.0. If fl1 is zero and fl2 is positive, the result is zero. In other cases where
    fl1 is zero, the result may be a NaN or some other unspecified flonum.

#+begin_src scheme
(flexpt 3.0 2.0) → 9.0
(flexpt 0.0 +inf.0) → 0.0
#+end_src

#+BEGIN_VERSE
    *процедура:* (fixnum->flonum fx)
    *возвращает:* the flonum representation closest to fx
    *процедура:* (real->flonum real)
    *возвращает:* the flonum representation closest to real
    *библиотеки:* (rnrs arithmetic flonums), (rnrs)
#+END_VERSE

    fixnum->flonum is a restricted variant of inexact. real->flonum is a restricted variant of inexact when the input is
    an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest
    flonum.

#+begin_src scheme
(fixnum->flonum 0) → 0.0
(fixnum->flonum 13) → 13.0

(real->flonum -1/2) → -0.5
(real->flonum 1s3) → 1000.0
#+end_src

*** Characters

    Characters are atomic objects representing letters, digits, special symbols such as $ or -, and certain nongraphic
    control characters such as space and newline. Characters are written with a #\ prefix. For most characters, the
    prefix is followed by the character itself. The written character representation of the letter A, for example, is
    #\A. The characters newline, space, and tab may be written in this manner as well, but they can be written more
    clearly as #\newline, #\space, and #\tab. Other character names are supported as well, as defined by the grammar for
    character objects on page 457. Any Unicode character may be written with the syntax #\xn, where n consists of one or
    more hexadecimal digits and represents a valid Unicode scalar value.

    This section describes the operations that deal primarily with characters. See also the following section on strings
    and Chapter 7 on input and output for other operations relating to characters.

#+BEGIN_VERSE
    *процедура:* (char=? char1 char2 char3 ...)
    *процедура:* (char<? char1 char2 char3 ...)
    *процедура:* (char>? char1 char2 char3 ...)
    *процедура:* (char<=? char1 char2 char3 ...)
    *процедура:* (char>=? char1 char2 char3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    These predicates behave in a similar manner to the numeric predicates =, <, >, <=, and >=. For example, char=?
    returns #t when its arguments are equivalent characters, and char<? returns #t when its arguments are monotonically
    increasing character (Unicode scalar) values.

#+begin_src scheme
(char>? #\a #\b) → #f
(char<? #\a #\b) → #t
(char<? #\a #\b #\c) → #t
(let ([c #\r])
  (char<=? #\a c #\z)) → #t
(char<=? #\Z #\W) → #f
(char=? #\+ #\+) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-ci=? char1 char2 char3 ...)
    *процедура:* (char-ci<? char1 char2 char3 ...)
    *процедура:* (char-ci>? char1 char2 char3 ...)
    *процедура:* (char-ci<=? char1 char2 char3 ...)
    *процедура:* (char-ci>=? char1 char2 char3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    These predicates are identical to the predicates char=?, char<?, char>?, char<=?, and char>=? except that they are
    case-insensitive, i.e., compare the case-folded versions of their arguments. For example, char=? considers #\a and
    #\A to be distinct values; char-ci=? does not.

#+begin_src scheme
(char-ci<? #\a #\B) → #t
(char-ci=? #\W #\w) → #t
(char-ci=? #\= #\+) → #f
(let ([c #\R])
  (list (char<=? #\a c #\z)
        (char-ci<=? #\a c #\z))) → (#f #t)
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-alphabetic? char)
    *возвращает:* #t if char is a letter, #f otherwise
    *процедура:* (char-numeric? char)
    *возвращает:* #t if char is a digit, #f otherwise
    *процедура:* (char-whitespace? char)
    *возвращает:* #t if char is whitespace, #f otherwise
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric"
    property, and whitespace if has the Unicode "White_Space" property.

#+begin_src scheme
(char-alphabetic? #\a) → #t
(char-alphabetic? #\T) → #t
(char-alphabetic? #\8) → #f
(char-alphabetic? #\$) → #f

(char-numeric? #\7) → #t
(char-numeric? #\2) → #t
(char-numeric? #\X) → #f
(char-numeric? #\space) → #f

(char-whitespace? #\space) → #t
(char-whitespace? #\newline) → #t
(char-whitespace? #\Z) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-lower-case? char)
    *возвращает:* #t if char is lower case, #f otherwise
    *процедура:* (char-upper-case? char)
    *возвращает:* #t if char is upper case, #f otherwise
    *процедура:* (char-title-case? char)
    *возвращает:* #t if char is title case, #f otherwise
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property,
    and title-case if it is in the Lt general category.

#+begin_src scheme
(char-lower-case? #\r) → #t
(char-lower-case? #\R) → #f

(char-upper-case? #\r) → #f
(char-upper-case? #\R) → #t

(char-title-case? #\I) → #f
(char-title-case? #\x01C5) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-general-category char)
    *возвращает:* a symbol representing the Unicode general category of char
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    The return value is one of the symbols Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Ps, Pe, Pi, Pf, Pd, Pc, Po, Sc,
    Sm, Sk, So, Zs, Zp, Zl, Cc, Cf, Cs, Co, or Cn.

#+begin_src scheme
(char-general-category #\a) → Ll
(char-general-category #\space) → Zs
(char-general-category #\x10FFFF) → Cn
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-upcase char)
    *возвращает:* the upper-case character counterpart of char
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    If char is a lower- or title-case character and has a single upper-case counterpart, char-upcase returns the
    upper-case counterpart. Otherwise char-upcase returns char.

#+begin_src scheme
(char-upcase #\g) → #\G
(char-upcase #\G) → #\G
(char-upcase #\7) → #\7
(char-upcase #\[[./images/20.png]]) → #\[[./images/21.png]]
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-downcase char)
    *возвращает:* the lower-case character equivalent of char
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    If char is an upper- or title-case character and has a single lower-case counterpart, char-downcase returns the
    lower-case counterpart. Otherwise char-downcase returns char.

#+begin_src scheme
(char-downcase #\g) → #\g
(char-downcase #\G) → #\g
(char-downcase #\7) → #\7
(char-downcase #\[[./images/20.png]]) → #\[[./images/20.png]]
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-titlecase char)
    *возвращает:* the title-case character equivalent of char
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    If char is an upper- or lower-case character and has a single title-case counterpart, char-titlecase returns the
    title-case counterpart. Otherwise, if it is not a title-case character, has no single title-case counterpart, but
    does have a single upper-case counterpart, char-titlecase returns the upper-case counterpart. Otherwise
    char-titlecase returns char.

#+begin_src scheme
(char-titlecase #\g) → #\G
(char-titlecase #\G) → #\G
(char-titlecase #\7) → #\7
(char-titlecase #\[[./images/20.png]]) → #\[[./images/21.png]]
#+end_src

#+BEGIN_VERSE
    *процедура:* (char-foldcase char)
    *возвращает:* the case-folded character equivalent of char
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    If char has a case-folded counterpart, char-foldcase returns the case-folded counterpart. Otherwise, char-foldcase
    returns char. For most characters, (char-foldcase char) is equivalent to (char-downcase (char-upcase char)), but for
    Turkic İ and ı, char-foldcase acts as the identity.

#+begin_src scheme
(char-foldcase #\g) → #\g
(char-foldcase #\G) → #\g
(char-foldcase #\7) → #\7
(char-foldcase #\ [[./images/20.png]]) → #\[[./images/22.png]]
#+end_src

#+BEGIN_VERSE
    *процедура:* (char->integer char)
    *возвращает:* the Unicode scalar value of char as an exact integer
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(char->integer #\newline) → 10
(char->integer #\space) → 32
(- (char->integer #\Z) (char->integer #\A)) → 25
#+end_src

#+BEGIN_VERSE
    *процедура:* (integer->char n)
    *возвращает:* the character corresponding to the Unicode scalar value n
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact integer and a valid Unicode scalar value, i.e., [[./images/23.png]] or [[./images/24.png]].

#+begin_src scheme
(integer->char 48) → #\0
(integer->char #x3BB) → #\→
#+end_src

*** Strings

    Strings are sequences of characters and are often used as messages, character buffers, or containers for blocks of
    text. Scheme provides operations for creating strings, extracting characters from strings, obtaining substrings,
    concatenating strings, and altering the contents of strings.

    A string is written as a sequence of characters enclosed in double quotes, e.g., "hi there". A double quote may be
    introduced into a string by preceding it by a backward slash, e.g., "two \"quotes\" within". A backward slash may
    also be included by preceding it with a backward slash, e.g., "a \\slash". Various special characters can be
    inserted with other two-character sequences, e.g., \n for newline, \r for carriage return, and \t for tab. Any
    Unicode character may be inserted with the syntax #\xn;, where n consists of one or more hexadecimal digits and
    represents a valid Unicode scalar value. A grammar defining the precise syntax of strings is given on page 458.

    Strings are indexed by exact nonnegative integers, and the index of the first element of any string is 0. The
    highest valid index for a given string is one less than its length.

#+BEGIN_VERSE
    *процедура:* (string=? string1 string2 string3 ...)
    *процедура:* (string<? string1 string2 string3 ...)
    *процедура:* (string>? string1 string2 string3 ...)
    *процедура:* (string<=? string1 string2 string3 ...)
    *процедура:* (string>=? string1 string2 string3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    As with =, <, >, <=, and >=, these predicates express relationships among all of the arguments. For example,
    string>? determines if the lexicographic ordering of its arguments is monotonically decreasing.

    The comparisons are based on the character predicates char=? and char<?. Two strings are lexicographically
    equivalent if they are the same length and consist of the same sequence of characters according to char=?. If two
    strings differ only in length, the shorter string is considered to be lexicographically less than the longer
    string. Otherwise, the first character position at which the strings differ (by char=?) determines which string is
    lexicographically less than the other, according to char<?.

    Two-argument string=? may be defined without error checks as follows.

#+begin_src scheme
(define string=?
  (lambda (s1 s2)
    (let ([n (string-length s1)])
      (and (= (string-length s2) n)
           (let loop ([i 0])
             (or (= i n)
                 (and (char=? (string-ref s1 i) (string-ref s2 i))
                      (loop (+ i 1)))))))))
#+end_src

    Two-argument string<? may be defined without error checks as follows.

#+begin_src scheme
(define string<?
  (lambda (s1 s2)
    (let ([n1 (string-length s1)] [n2 (string-length s2)])
      (let loop ([i 0])
        (and (not (= i n2))
             (or (= i n1)
                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
                   (or (char<? c1 c2)
                       (and (char=? c1 c2)
                            (loop (+ i 1)))))))))))
#+end_src

    These definitions may be extended straightforwardly to support three or more arguments. string<=?, string>?, and
    string>=? may be defined similarly.

#+begin_src scheme
(string=? "mom" "mom") → #t
(string<? "mom" "mommy") → #t
(string>? "Dad" "Dad") → #f
(string=? "Mom and Dad" "mom and dad") → #f
(string<? "a" "b" "c") → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-ci=? string1 string2 string3 ...)
    *процедура:* (string-ci<? string1 string2 string3 ...)
    *процедура:* (string-ci>? string1 string2 string3 ...)
    *процедура:* (string-ci<=? string1 string2 string3 ...)
    *процедура:* (string-ci>=? string1 string2 string3 ...)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    These predicates are identical to string=?, string<?, string>?, string<=?, and string>=? except that they are
    case-insensitive, i.e., compare the case-folded versions of their arguments.

#+begin_src scheme
(string-ci=? "Mom and Dad" "mom and dad") → #t
(string-ci<=? "say what" "Say What!?") → #t
(string-ci>? "N" "m" "L" "k") → #t
(string-ci=? "Straße" "Strasse") → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (string char ...)
    *возвращает:* a string containing the characters char ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(string) → ""
(string #\a #\b #\c) → "abc"
(string #\H #\E #\Y #\!) → "HEY!"
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-string n)
    *процедура:* (make-string n char)
    *возвращает:* a string of length n
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. If char is supplied, the string is filled with n occurrences of char,
    otherwise the characters contained in the string are unspecified.

#+begin_src scheme
(make-string 0) → ""
(make-string 0 #\x) → ""
(make-string 5 #\x) → "xxxxx"
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-length string)
    *возвращает:* the number of characters in string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The length of a string is always an exact nonnegative integer.

#+begin_src scheme
(string-length "abc") → 3
(string-length "") → 0
(string-length "hi there") → 8
(string-length (make-string 1000000)) → 1000000
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-ref string n)
    *возвращает:* the nth character (zero-based) of string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of string.

#+begin_src scheme
(string-ref "hi there" 0) → #\h
(string-ref "hi there" 5) → #\e
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-set! string n char)
    *возвращает:* unspecified
    *библиотеки:* (rnrs mutable-strings)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of string. string-set! changes the nth element of string
    to char.

#+begin_src scheme
(let ([str (string-copy "hi three")])
  (string-set! str 5 #\e)
  (string-set! str 6 #\r)
  str) → "hi there"
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-copy string)
    *возвращает:* a new copy of string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    This procedure creates a new string with the same length and contents as string.

#+begin_src scheme
(string-copy "abc") → "abc"

(let ([str "abc"])
  (eq? str (string-copy str))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-append string ...)
    *возвращает:* a new string formed by concatenating the strings string ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(string-append) → ""
(string-append "abc" "def") → "abcdef"
(string-append "Hey " "you " "there!") → "Hey you there!"
#+end_src

    The following implementation of string-append recurs down the list of strings to compute the total length, then
    allocates the new string, then fills it up as it unwinds the recursion.

#+begin_src scheme
(define string-append
  (lambda args
    (let f ([ls args] [n 0])
      (if (null? ls)
          (make-string n)
          (let* ([s1 (car ls)]
                 [m (string-length s1)]
                 [s2 (f (cdr ls) (+ n m))])
            (do ([i 0 (+ i 1)] [j n (+ j 1)])
                ((= i m) s2)
              (string-set! s2 j (string-ref s1 i))))))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (substring string start end)
    *возвращает:* a copy of string from start (inclusive) to end (exclusive)
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    start and end must be exact nonnegative integers; start must be less than or equal to end, while end must be less
    than or equal to the length of string. If end = start, a string of length zero is returned. substring may be defined
    without error checks as follows.

#+begin_src scheme
(define substring
  (lambda (s1 m n)
    (let ([s2 (make-string (- n m))])
      (do ([j 0 (+ j 1)] [i m (+ i 1)])
          ((= i n) s2)
        (string-set! s2 j (string-ref s1 i))))))

(substring "hi there" 0 1) → "h"
(substring "hi there" 3 6) → "the"
(substring "hi there" 5 5) → ""
#+end_src

#+begin_src scheme
(let ([str "hi there"])
  (let ([end (string-length str)])
    (substring str 0 end))) → "hi there"
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-fill! string char)
    *возвращает:* unspecified
    *библиотеки:* (rnrs mutable-strings)
#+END_VERSE

    string-fill! sets every character in string to char.

#+begin_src scheme
(let ([str (string-copy "sleepy")])
  (string-fill! str #\Z)
  str) → "ZZZZZZ"
#+end_src

    string-fill! might be defined as follows:

#+begin_src scheme
(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (do ([i 0 (+ i 1)])
          ((= i n))
          (string-set! s i c)))))
#+end_src

    An alternative definition is given on page 276.

#+BEGIN_VERSE
    *процедура:* (string-upcase string)
    *возвращает:* the upper-case equivalent of string
    *процедура:* (string-downcase string)
    *возвращает:* the lower-case equivalent of string
    *процедура:* (string-foldcase string)
    *возвращает:* the case-folded equivalent of string
    *процедура:* (string-titlecase string)
    *возвращает:* the title-case equivalent of string
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value
    sequences. These mappings do not always map single characters to single characters, so the length of the result
    string may differ from the length of string. If the result string is the same as string (by string=?), string or a
    copy of string may be returned. Otherwise, the result string is newly allocated. string-foldcase does not use the
    special mappings for Turkic languages.

    string-titlecase converts the first cased character of each word in string to its title-case counterpart and
    converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode
    Standard Annex #29 [8].

#+begin_src scheme
(string-upcase "Hi") → "HI"
(string-downcase "Hi") → "hi"
(string-foldcase "Hi") → "hi"

(string-upcase "Straße") → "STRASSE"
(string-downcase "Straße") → "straße"
(string-foldcase "Straße") → "strasse"
(string-downcase "STRASSE")  → "strasse"

(string-downcase "→") → "→"

(string-titlecase "kNock KNoCK") → "Knock Knock"
(string-titlecase "who's there?") → "Who's There?"
(string-titlecase "r6rs") → "R6rs"
(string-titlecase "R6RS") → "R6rs"
#+end_src

#+BEGIN_VERSE
    *процедура:* (string-normalize-nfd string)
    *возвращает:* the Unicode normalized form D of string
    *процедура:* (string-normalize-nfkd string)
    *возвращает:* the Unicode normalized form KD of string
    *процедура:* (string-normalize-nfc string)
    *возвращает:* the Unicode normalized form C of string
    *процедура:* (string-normalize-nfkc string)
    *возвращает:* the Unicode normalized form KC of string
    *библиотеки:* (rnrs unicode), (rnrs)
#+END_VERSE

    If the result string is the same as string (by string=?), string or a copy of string may be returned. Otherwise, the
    result string is newly allocated.

#+begin_src scheme
(string-normalize-nfd "\xE9;") → "e\x301;"
(string-normalize-nfc "\xE9;") → "\xE9;"
(string-normalize-nfd "\x65;\x301;") → "e\x301;"
(string-normalize-nfc "\x65;\x301;") → "\xE9;"
#+end_src

#+BEGIN_VERSE
    *процедура:* (string->list string)
    *возвращает:* a list of the characters in string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    string->list allows a string to be converted into a list, so that Scheme's list-processing operations may be applied
    to the processing of strings. string->list may be defined without error checks as follows.

#+begin_src scheme
(define string->list
  (lambda (s)
    (do ([i (- (string-length s) 1) (- i 1)]
         [ls '() (cons (string-ref s i) ls)])
        ((< i 0) ls))))
#+end_src

#+begin_src scheme
(string->list "") → ()
(string->list "abc") → (#\a #\b #\c)
(apply char<? (string->list "abc")) → #t
(map char-upcase (string->list "abc")) → (#\A #\B #\C)
#+end_src

#+BEGIN_VERSE
    *процедура:* (list->string list)
    *возвращает:* a string of the characters in list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    list must consist entirely of characters.

    list->string is the functional inverse of string->list. A program might use both procedures together, first
    converting a string into a list, then operating on this list to produce a new list, and finally converting the new
    list back into a string.

    list->string may be defined without error checks as follows.

#+begin_src scheme
(define list->string
  (lambda (ls)
    (let ([s (make-string (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (string-set! s i (car ls))))))

(list->string '()) → ""
(list->string '(#\a #\b #\c)) → "abc"
(list->string
  (map char-upcase
       (string->list "abc"))) → "ABC"
#+end_src

*** Vectors

    Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element
    in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed
    in constant time. The length of a vector is the number of elements it contains. Vectors are indexed by exact
    nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given
    vector is one less than its length.

    As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of
    object.

    A vector is written as a sequence of objects separated by whitespace, preceded by the prefix #( and followed by
    ). For example, a vector consisting of the elements a, b, and c would be written #(a b c).

#+BEGIN_VERSE
    *процедура:* (vector obj ...)
    *возвращает:* a vector of the objects obj ...
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

#+begin_src scheme
(vector) → #()
(vector 'a 'b 'c) → #(a b c)
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-vector n)
    *процедура:* (make-vector n obj)
    *возвращает:* a vector of length n
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. If obj is supplied, each element of the vector is filled with obj;
    otherwise, the elements are unspecified.

#+begin_src scheme
(make-vector 0) → #()
(make-vector 0 '#(a)) → #()
(make-vector 5 '#(a)) → #(#(a) #(a) #(a) #(a) #(a))
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-length vector)
    *возвращает:* the number of elements in vector
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The length of a vector is always an exact nonnegative integer.

#+begin_src scheme
(vector-length '#()) → 0
(vector-length '#(a b c)) → 3
(vector-length (vector 1 '(2) 3 '#(4 5))) → 4
(vector-length (make-vector 300)) → 300
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-ref vector n)
    *возвращает:* the nth element (zero-based) of vector
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of vector.

#+begin_src scheme
(vector-ref '#(a b c) 0) → a
(vector-ref '#(a b c) 1) → b
(vector-ref '#(x y z w) 3) → w
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-set! vector n obj)
    *возвращает:* unspecified
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of vector. vector-set! changes the nth element of vector
    to obj.

#+begin_src scheme
(let ([v (vector 'a 'b 'c 'd 'e)])
  (vector-set! v 2 'x)
  v) → #(a b x d e)
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-fill! vector obj)
    *возвращает:* unspecified
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    vector-fill! replaces each element of vector with obj. It may be defined without error checks as follows.

#+begin_src scheme
(define vector-fill!
  (lambda (v x)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i x)))))

(let ([v (vector 1 2 3)])
  (vector-fill! v 0)
  v) → #(0 0 0)
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector->list vector)
    *возвращает:* a list of the elements of vector
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    vector->list provides a convenient method for applying list-processing operations to vectors. It may be defined
    without error checks as follows.

#+begin_src scheme
(define vector->list
  (lambda (s)
    (do ([i (- (vector-length s) 1) (- i 1)]
         [ls '() (cons (vector-ref s i) ls)])
        ((< i 0) ls))))

(vector->list (vector)) → ()
(vector->list '#(a b c)) → (a b c)

(let ((v '#(1 2 3 4 5)))
  (apply * (vector->list v))) → 120
#+end_src

#+BEGIN_VERSE
    *процедура:* (list->vector list)
    *возвращает:* a vector of the elements of list
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    list->vector is the functional inverse of vector->list. The two procedures are often used in combination to take
    advantage of a list-processing operation. A vector may be converted to a list with vector->list, this list processed
    in some manner to produce a new list, and the new list converted back into a vector with list->vector.

    list->vector may be defined without error checks as follows.

#+begin_src scheme
(define list->vector
  (lambda (ls)
    (let ([s (make-vector (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (vector-set! s i (car ls))))))

(list->vector '()) → #()
(list->vector '(a b c)) → #(a b c)

(let ([v '#(1 2 3 4 5)])
  (let ([ls (vector->list v)])
    (list->vector (map * ls ls)))) → #(1 4 9 16 25)
#+end_src

#+BEGIN_VERSE
    *процедура:* (vector-sort predicate vector)
    *возвращает:* a vector containing the elements of vector, sorted according to predicate
    *процедура:* (vector-sort! predicate vector)
    *возвращает:* unspecified
    *библиотеки:* (rnrs sorting), (rnrs)
#+END_VERSE

    predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its
    second in the sorted vector. That is, if predicate is applied to two elements x and y, where x appears after y in
    the input vector, the predicate should return true only if x should appear before y in the output vector. If this
    constraint is met, vector-sort performs a stable sort, i.e., two elements are reordered only when necessary
    according to predicate. vector-sort! performs the sort destructively and does not necessarily perform a stable
    sort. Duplicate elements are not removed. predicate should not have any side effects.

    vector-sort may call predicate up to nlogn times, where n is the length of vector, while vector-sort! may call the
    predicate up to n2 times. The looser bound for vector-sort! allows an implementation to use a quicksort algorithm,
    which may be faster in some cases than algorithms that have the tighter nlogn bound.

#+begin_src scheme
(vector-sort < '#(3 4 2 1 2 5)) → #(1 2 2 3 4 5)
(vector-sort > '#(0.5 1/2)) → #(0.5 1/2)
(vector-sort > '#(1/2 0.5)) → #(1/2 0.5)

(let ([v (vector 3 4 2 1 2 5)])
  (vector-sort! < v)
  v) → #(1 2 2 3 4 5)
#+end_src

*** Bytevectors

    Bytevectors are vectors of raw binary data. Although nominally organized as a sequence of exact unsigned 8-bit
    integers, a bytevector can be interpreted as a sequence of exact signed 8-bit integers, exact signed or unsigned
    16-bit, 32-bit, 64-bit, or arbitrary-precision integers, IEEE single or double floating-point numbers, or arbitrary
    combinations of the above.

    The length of a bytevector is the number of 8-bit bytes it stores, and indices into a bytevector are always given as
    byte offsets. Any data element may be aligned at any byte offset, regardless of the underlying hardware's alignment
    requirements, and may be represented using a specified endianness (see below) that differs from that prescribed by
    the hardware. Special, typically more efficient operators are provided for 16-, 32-, and 64-bit integers and single
    and double floats that are in their native format, i.e,. with the endianness of the underlying hardware and stored
    at an index that is a multiple of the size in bytes of the integer or float.

    The endianness of a multi-byte data value determines how it is laid out in memory. In big-endian format, the value
    is laid out with the more significant bytes at lower indices, while in little-endian format, the value is laid out
    with the more significant bytes at higher indices. When a bytevector procedure accepts an endianness argument, the
    argument may be the symbol big, representing the big-endian format, or the symbol little, representing the
    little-endian format. Implementations may extend these procedures to accept other endianness symbols. The native
    endianness of the implementation may be obtained via the procedure native-endianness.

    Bytevectors are written with the #vu8( prefix in place of the #( prefix for vectors, e.g., #vu8(1 2 3). The elements
    of a bytevector specified in this manner are always given as 8-bit unsigned exact integers, i.e., integers from 0 to
    255 inclusive, written using any valid syntax for such numbers. Like strings, bytevectors are self-evaluating, so
    they need not be quoted.

#+begin_src scheme
'#vu8(1 2 3) → #vu8(1 2 3)
#vu8(1 2 3) → #vu8(1 2 3)
#vu8(#x3f #x7f #xbf #xff) → #vu8(63 127 191 255)
#+end_src

#+BEGIN_VERSE
    *синтаксис:* (endianness symbol)
    *возвращает:* symbol
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    symbol must be the symbol little, the symbol big, or some other symbol recognized by the implementation as an
    endianness symbol. It is a syntax violation if symbol is not a symbol or if it is not recognized by the
    implementation as an endianness symbol.

#+begin_src scheme
(endianness little) → little
(endianness big) → big
(endianness "spam") → exception
#+end_src

#+BEGIN_VERSE
    *процедура:* (native-endianness)
    *возвращает:* a symbol naming the implementation's native endianness
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    The return value is the symbol little, the symbol big, or some other endianness symbol recognized by the
    implementation. It typically reflects the endianness of the underlying hardware.

#+begin_src scheme
(symbol? (native-endianness)) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-bytevector n)
    *процедура:* (make-bytevector n fill)
    *возвращает:* a new bytevector of length n
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    If fill is supplied, each element of the bytevector is initialized to fill; otherwise, the elements are
    unspecified. The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255
    inclusive. A negative fill value is treated as its two's complement equivalent.

#+begin_src scheme
(make-bytevector 0) → #vu8()
(make-bytevector 0 7) → #vu8()
(make-bytevector 5 7) → #vu8(7 7 7 7 7)
(make-bytevector 5 -7) → #vu8(249 249 249 249 249)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-length bytevector)
    *возвращает:* the length of bytevector in 8-bit bytes
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

#+begin_src scheme
(bytevector-length #vu8()) → 0
(bytevector-length #vu8(1 2 3)) → 3
(bytevector-length (make-bytevector 300)) → 300
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector=? bytevector1 bytevector2)
    *возвращает:* #t if the relation holds, #f otherwise
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    Two bytevectors are equal by bytevector=? if and only if they have the same length and same contents.

#+begin_src scheme
(bytevector=? #vu8() #vu8()) → #t
(bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) → #t
(bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) → #f
(bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-fill! bytevector fill)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A
    negative fill value is treated as its two's complement equivalent.

    bytevector-fill! replaces each element of bytevector with fill.

#+begin_src scheme
(let ([v (make-bytevector 6)])
  (bytevector-fill! v 255)
  v) → #vu8(255 255 255 255 255 255)

(let ([v (make-bytevector 6)])
  (bytevector-fill! v -128)
  v) → #vu8(128 128 128 128 128 128)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-copy bytevector)
    *возвращает:* a new bytevector that is a copy of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    bytevector-copy creates a new bytevector with the same length and contents as bytevector.

#+begin_src scheme
(bytevector-copy #vu8(1 127 128 255)) → #vu8(1 127 128 255)

(let ([v #vu8(1 127 128 255)])
  (eq? v (bytevector-copy v))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-copy! src src-start dst dst-start n)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    src and dst must be bytevectors. src-start, dst-start, and n must be exact nonnegative integers. The sum of
    src-start and n must not exceed the length of src, and the sum of dst-start and n must not exceed the length of
    dst.

    bytevector-copy! overwrites the n bytes of dst starting at dst-start with the n bytes of src starting at
    src-start. This works even if dst is the same bytevector as src and the source and destination locations
    overlap. That is, the destination is filled with the bytes that appeared at the source before the operation began.

#+begin_src scheme
(define v1 #vu8(31 63 95 127 159 191 223 255))
(define v2 (make-bytevector 10 0))

(bytevector-copy! v1 2 v2 1 4)
v2 → #vu8(0 95 127 159 191 0 0 0 0 0)

(bytevector-copy! v1 5 v2 7 3)
v2 → #vu8(0 95 127 159 191 0 0 191 223 255)

(bytevector-copy! v2 3 v2 0 6)
v2 → #vu8(159 191 0 0 191 223 0 191 223 255)

(bytevector-copy! v2 0 v2 1 9)
v2 → #vu8(159 159 191 0 0 191 223 0 191 223)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u8-ref bytevector n)
    *возвращает:* the 8-bit unsigned byte at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of bytevector.

    The value is returned as an exact 8-bit unsigned integer, i.e., a value in the range 0 to 255 inclusive.

#+begin_src scheme
(bytevector-u8-ref #vu8(1 127 128 255) 0) → 1
(bytevector-u8-ref #vu8(1 127 128 255) 2) → 128
(bytevector-u8-ref #vu8(1 127 128 255) 3) → 255
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-s8-ref bytevector n)
    *возвращает:* the 8-bit signed byte at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of bytevector.

    The value returned is an exact 8-bit signed integer, i.e., a value in the range -128 to 127 inclusive, and is the
    equivalent of the stored value treated as a two's complement value.

#+begin_src scheme
(bytevector-s8-ref #vu8(1 127 128 255) 0) → 1
(bytevector-s8-ref #vu8(1 127 128 255) 1) → 127
(bytevector-s8-ref #vu8(1 127 128 255) 2) → -128
(bytevector-s8-ref #vu8(1 127 128 255) 3) → -1
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u8-set! bytevector n u8)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of bytevector. u8 must be an 8-bit unsigned value, i.e.,
    a value in the range 0 to 255 inclusive.

    bytevector-u8-set! changes the 8-bit value at index n (zero-based) of bytevector to u8.

#+begin_src scheme
(let ([v (make-bytevector 5 -1)])
  (bytevector-u8-set! v 2 128)
  v) → #vu8(255 255 128 255 255)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-s8-set! bytevector n s8)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer less than the length of bytevector. s8 must be an 8-bit signed value, i.e., a
    value in the range -128 to 127 inclusive.

    bytevector-s8-set! changes the 8-bit value at index n (zero-based) of bytevector to the two's complement equivalent
    of s8.

#+begin_src scheme
(let ([v (make-bytevector 4 0)])
  (bytevector-s8-set! v 1 100)
  (bytevector-s8-set! v 2 -100)
  v) → #vu8(0 100 156 0)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector->u8-list bytevector)
    *возвращает:* a list of the 8-bit unsigned elements of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

#+begin_src scheme
(bytevector->u8-list (make-bytevector 0)) → ()
(bytevector->u8-list #vu8(1 127 128 255)) → (1 127 128 255)

(let ([v #vu8(1 2 3 255)])
  (apply * (bytevector->u8-list v))) → 1530
#+end_src

#+BEGIN_VERSE
    *процедура:* (u8-list->bytevector list)
    *возвращает:* a new bytevector of the elements of list
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    list must consist entirely of exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.

#+begin_src scheme
(u8-list->bytevector '()) → #vu8()
(u8-list->bytevector '(1 127 128 255)) → #vu8(1 127 128 255)

(let ([v #vu8(1 2 3 4 5)])
  (let ([ls (bytevector->u8-list v)])
    (u8-list->bytevector (map * ls ls)))) → #vu8(1 4 9 16 25)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u16-native-ref bytevector n)
    *возвращает:* the 16-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s16-native-ref bytevector n)
    *возвращает:* the 16-bit signed integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-u32-native-ref bytevector n)
    *возвращает:* the 32-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s32-native-ref bytevector n)
    *возвращает:* the 32-bit signed integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-u64-native-ref bytevector n)
    *возвращает:* the 64-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s64-native-ref bytevector n)
    *возвращает:* the 64-bit signed integer at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the
    number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is
    assumed.

    The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed
    values are the equivalent of the stored value treated as a two's complement value.

#+begin_src scheme
(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))
#+end_src

    If native endianness is big:

#+begin_src scheme
(bytevector-u16-native-ref v 2) → #xfe56
(bytevector-s16-native-ref v 2) → #x-1aa
(bytevector-s16-native-ref v 6) → #x7898

(bytevector-u32-native-ref v 0) → #x1234fe56
(bytevector-s32-native-ref v 0) → #x1234fe56
(bytevector-s32-native-ref v 4) → #x-23458768

(bytevector-u64-native-ref v 0) → #x1234fe56dcba7898
(bytevector-s64-native-ref v 0) → #x1234fe56dcba7898

If native endianness is little:

(bytevector-u16-native-ref v 2) → #x56fe
(bytevector-s16-native-ref v 2) → #x56fe
(bytevector-s16-native-ref v 6) → #x-6788

(bytevector-u32-native-ref v 0) → #x56fe3412
(bytevector-s32-native-ref v 0) → #x56fe3412
(bytevector-s32-native-ref v 4) → #x-67874524

(bytevector-u64-native-ref v 0) → #x9878badc56fe3412
(bytevector-s64-native-ref v 0) → #x-67874523a901cbee
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u16-native-set! bytevector n u16)
    *процедура:* (bytevector-s16-native-set! bytevector n s16)
    *процедура:* (bytevector-u32-native-set! bytevector n u32)
    *процедура:* (bytevector-s32-native-set! bytevector n s32)
    *процедура:* (bytevector-u64-native-set! bytevector n u64)
    *процедура:* (bytevector-s64-native-set! bytevector n s64)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the
    number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    n and the number of bytes occupied by the value must not exceed the length bytevector. u16 must be a 16-bit unsigned
    value, i.e., a value in the range 0 to 216 - 1 inclusive; s16 must be a 16-bit signed value, i.e., a value in the
    range -215 to 215 - 1 inclusive; u32 must be a 32-bit unsigned value, i.e., a value in the range 0 to 232 - 1
    inclusive; s32 must be a 32-bit signed value, i.e., a value in the range -231 to 231 - 1 inclusive; u64 must be a
    64-bit unsigned value, i.e., a value in the range 0 to 264 - 1 inclusive; and s64 must be a 64-bit signed value,
    i.e., a value in the range -263 to 263 - 1 inclusive. The native endianness is assumed.

    These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of
    bytevector. Negative values are stored as their two's complement equivalent.

#+begin_src scheme
(define v (make-bytevector 8 0))
(bytevector-u16-native-set! v 0 #xfe56)
(bytevector-s16-native-set! v 2 #x-1aa)
(bytevector-s16-native-set! v 4 #x7898)
#+end_src

    If native endianness is big:

    #+begin_src scheme
v → #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)
#+end_src

    If native endianness is little:

#+begin_src scheme
v → #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)
#+end_src

#+begin_src scheme
(define v (make-bytevector 16 0))
(bytevector-u32-native-set! v 0 #x1234fe56)
(bytevector-s32-native-set! v 4 #x1234fe56)
(bytevector-s32-native-set! v 8 #x-23458768)
#+end_src

    If native endianness is big:

#+begin_src scheme
v → #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56
        #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)
#+end_src

    If native endianness is little:

#+begin_src scheme
v → #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12
        #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)
#+end_src

#+begin_src scheme
(define v (make-bytevector 24 0))
(bytevector-u64-native-set! v 0 #x1234fe56dcba7898)
(bytevector-s64-native-set! v 8 #x1234fe56dcba7898)
(bytevector-s64-native-set! v 16 #x-67874523a901cbee)
#+end_src

    If native endianness is big:

#+begin_src scheme
v → #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98
        #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)
#+end_src

    If native endianness is little:

#+begin_src scheme
v → #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12
        #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u16-ref bytevector n eness)
    *возвращает:* the 16-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s16-ref bytevector n eness)
    *возвращает:* the 16-bit signed integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-u32-ref bytevector n eness)
    *возвращает:* the 32-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s32-ref bytevector n eness)
    *возвращает:* the 32-bit signed integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-u64-ref bytevector n eness)
    *возвращает:* the 64-bit unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-s64-ref bytevector n eness)
    *возвращает:* the 64-bit signed integer at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of
    bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the
    length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid
    endianness symbol naming the endianness.

    The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed
    values are the equivalent of the stored value treated as a two's complement value.

#+begin_src scheme
(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))
(bytevector-u16-ref v 0 (endianness big)) → #x1234
(bytevector-s16-ref v 1 (endianness big)) → #x34fe
(bytevector-s16-ref v 5 (endianness big)) → #x-4588

(bytevector-u32-ref v 2 'big) → #xfe56dcba
(bytevector-s32-ref v 3 'big) → #x56dcba78
(bytevector-s32-ref v 4 'big) → #x-23458768

(bytevector-u64-ref v 0 'big) → #x1234fe56dcba7898
(bytevector-s64-ref v 1 'big) → #x34fe56dcba78989a

(bytevector-u16-ref v 0 (endianness little)) → #x3412
(bytevector-s16-ref v 1 (endianness little)) → #x-1cc
(bytevector-s16-ref v 5 (endianness little)) → #x78ba

(bytevector-u32-ref v 2 'little) → #xbadc56fe
(bytevector-s32-ref v 3 'little) → #x78badc56
(bytevector-s32-ref v 4 'little) → #x-67874524

(bytevector-u64-ref v 0 'little) → #x9878badc56fe3412
(bytevector-s64-ref v 1 'little) → #x-6567874523a901cc
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-u16-set! bytevector n u16 eness)
    *процедура:* (bytevector-s16-set! bytevector n s16 eness)
    *процедура:* (bytevector-u32-set! bytevector n u32 eness)
    *процедура:* (bytevector-s32-set! bytevector n s32 eness)
    *процедура:* (bytevector-u64-set! bytevector n u64 eness)
    *процедура:* (bytevector-s64-set! bytevector n s64 eness)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of
    bytes occupied by the value must not exceed the length of bytevector. n need not be a multiple of the number of
    bytes occupied by the value. u16 must be a 16-bit unsigned value, i.e., a value in the range 0 to 216 - 1 inclusive;
    s16 must be a 16-bit signed value, i.e., a value in the range -215 to 215 - 1 inclusive; u32 must be a 32-bit
    unsigned value, i.e., a value in the range 0 to 232 - 1 inclusive; s32 must be a 32-bit signed value, i.e., a value
    in the range -231 to 231 - 1 inclusive; u64 must be a 64-bit unsigned value, i.e., a value in the range 0 to 264 - 1
    inclusive; and s64 must be a 64-bit signed value, i.e., a value in the range -263 to 263 - 1 inclusive. eness must
    be a valid endianness symbol naming the endianness.

    These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of
    bytevector. Negative values are stored as their two's complement equivalent.

#+begin_src scheme
(define v (make-bytevector 8 0))
(bytevector-u16-set! v 0 #xfe56 (endianness big))
(bytevector-s16-set! v 3 #x-1aa (endianness little))
(bytevector-s16-set! v 5 #x7898 (endianness big))
v → #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)

(define v (make-bytevector 16 0))
(bytevector-u32-set! v 0 #x1234fe56 'little)
(bytevector-s32-set! v 6 #x1234fe56 'big)
(bytevector-s32-set! v 11 #x-23458768 'little)
v → #vu8(#x56 #xfe #x34 #x12 #x0 #x0
        #x12 #x34 #xfe #x56 #x0
        #x98 #x78 #xba #xdc #x0)

(define v (make-bytevector 28 0))
(bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)
(bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)
(bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
v → #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0
        #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-uint-ref bytevector n eness size)
    *возвращает:* the size-byte unsigned integer at index n (zero-based) of bytevector
    *процедура:* (bytevector-sint-ref bytevector n eness size)
    *возвращает:* the size-byte signed integer at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive
    integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of
    bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness
    symbol naming the endianness.

    The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed
    values are the equivalent of the stored value treated as a two's complement value.

#+begin_src scheme
(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))

(bytevector-uint-ref v 0 'big 1) → #x12
(bytevector-uint-ref v 0 'little 1) → #x12
(bytevector-uint-ref v 1 'big 3) → #x34fe56
(bytevector-uint-ref v 2 'little 7) → #x9a9878badc56fe

(bytevector-sint-ref v 2 'big 1) → #x-02
(bytevector-sint-ref v 1 'little 6) → #x78badc56fe34
(bytevector-sint-ref v 2 'little 7) → #x-6567874523a902

(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) → -1
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-uint-set! bytevector n uint eness size)
    *процедура:* (bytevector-sint-set! bytevector n sint eness size)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive
    integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of
    bytevector. n need not be a multiple of the number of bytes occupied by the value. uint must be an exact integer in
    the range 0 to 2size·8 - 1 inclusive. sint must be an exact integer in the range -2size·8-1 to 2size·8-1 - 1
    inclusive. eness must be a valid endianness symbol naming the endianness.

    These procedures store the given value in the size bytes starting at index n (zero-based) of bytevector. Negative
    values are stored as their two's complement equivalent.

#+begin_src scheme
(define v (make-bytevector 5 0))
(bytevector-uint-set! v 1 #x123456 (endianness big) 3)
v → #vu8(0 #x12 #x34 #x56 0)

(define v (make-bytevector 7 -1))
(bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
v → #vu8(#xff 0 0 0 0 #x80 #xff)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector->uint-list bytevector eness size)
    *возвращает:* a new list of the size-byte unsigned elements of bytevector
    *процедура:* (bytevector->sint-list bytevector eness size)
    *возвращает:* a new list of the size-byte signed elements of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies
    the number of bytes occupied by the value. It must be a value that evenly divides the length of bytevector.

#+begin_src scheme
(bytevector->uint-list (make-bytevector 0) 'little 3) → ()

(let ([v #vu8(1 2 3 4 5 6)])
  (bytevector->uint-list v 'big 3)) → (#x010203 #x040506)

(let ([v (make-bytevector 80 -1)])
  (bytevector->sint-list v 'big 20)) → (-1 -1 -1 -1)
#+end_src

#+BEGIN_VERSE
    *процедура:* (uint-list->bytevector list eness size)
    *процедура:* (sint-list->bytevector list eness size)
    *возвращает:* a new bytevector of the elements of list
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies
    the number of bytes occupied by the value. For uint-list->bytevector, list must consist entirely of size-byte exact
    unsigned integers, i.e., values in the range 0 to 2size·8 - 1 inclusive. For sint-list->bytevector, list must
    consist entirely of size-byte exact signed integers, i.e., values in the range -2size·8-1 to 2size·8-1 - 1
    inclusive. Each value occupies size bytes in the resulting bytevector, whose length is thus size times the length of
    list.

#+begin_src scheme
(uint-list->bytevector '() 'big 25) → #vu8()
(sint-list->bytevector '(0 -1) 'big 3) → #vu8(0 0 0 #xff #xff #xff)

(define (f size)
  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
                  (- (expt 2 (- (* 8 size) 1)) 1))])
    (sint-list->bytevector ls 'little size)))
(f 6) → #vu8(#x00 #x00 #x00 #x00 #x00 #x80
            #xff #xff #xff #xff #xff #x7f)
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-ieee-single-native-ref bytevector n)
    *возвращает:* the single floating-point value at index n (zero-based) of bytevector
    *процедура:* (bytevector-ieee-double-native-ref bytevector n)
    *возвращает:* the double floating-point value at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the
    number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes
    occupied by the value must not exceed the length of bytevector. The native endianness is assumed.

    The return value is an inexact real number. Examples appear after the mutation operators below.

#+BEGIN_VERSE
    *процедура:* (bytevector-ieee-single-native-set! bytevector n x)
    *процедура:* (bytevector-ieee-double-native-set! bytevector n x)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the
    number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes
    occupied by the value must not exceed the length of bytevector. The native endianness is assumed.

    These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based)
    of bytevector.

#+begin_src scheme
(define v (make-bytevector 8 0))
(bytevector-ieee-single-native-set! v 0 .125)
(bytevector-ieee-single-native-set! v 4 -3/2)
(list
  (bytevector-ieee-single-native-ref v 0)
  (bytevector-ieee-single-native-ref v 4)) → (0.125 -1.5)

(bytevector-ieee-double-native-set! v 0 1e23)
(bytevector-ieee-double-native-ref v 0) → 1e23
#+end_src

#+BEGIN_VERSE
    *процедура:* (bytevector-ieee-single-ref bytevector n eness)
    *возвращает:* the single floating-point value at index n (zero-based) of bytevector
    *процедура:* (bytevector-ieee-double-ref bytevector n eness)
    *возвращает:* the double floating-point value at index n (zero-based) of bytevector
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of
    bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need
    not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the
    endianness.

    The return value is an inexact real number. Examples appear after the mutation operators below.

#+BEGIN_VERSE
    *процедура:* (bytevector-ieee-single-set! bytevector n x eness)
    *процедура:* (bytevector-ieee-double-set! bytevector n x eness)
    *возвращает:* unspecified
    *библиотеки:* (rnrs bytevectors), (rnrs)
#+END_VERSE

    n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of
    bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need
    not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the
    endianness.

    These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based)
    of bytevector.

#+begin_src scheme
(define v (make-bytevector 10 #xc7))
(bytevector-ieee-single-set! v 1 .125 'little)
(bytevector-ieee-single-set! v 6 -3/2 'big)
(list
  (bytevector-ieee-single-ref v 1 'little)
  (bytevector-ieee-single-ref v 6 'big)) → (0.125 -1.5)
v → #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)

(bytevector-ieee-double-set! v 1 1e23 'big)
(bytevector-ieee-double-ref v 1 'big) → 1e23
#+end_src

*** Symbols

    Symbols are used for a variety of purposes as symbolic names in Scheme programs. Strings could be used for most of
    the same purposes, but an important characteristic of symbols makes comparisons between symbols much more
    efficient. This characteristic is that two symbols with the same name are identical in the sense of eq?. The reason
    is that the Scheme reader (invoked by get-datum and read) and the procedure string->symbol catalog symbols in an
    internal symbol table and always return the same symbol whenever the same name is encountered. Thus, no
    character-by-character comparison is needed, as would be needed to compare two strings.

    The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as
    identifiers in the representation of programs, allowing fast comparison of identifiers. This property also makes
    symbols useful for a variety of other purposes. For example, symbols might be used as messages passed between
    procedures, labels for list-structured records, or names for objects stored in an association list (see assq in
    Section 6.3).

    Symbols are written without double quotes or other bracketing characters. Parentheses, double quotes, spaces, and
    most other characters with a special meaning to the Scheme reader are not allowed within the printed representation
    of a symbol. These and any other Unicode character may appear anywhere within the printed representation of a symbol
    with the syntax #\xn;, where n consists of one or more hexadecimal digits and represents a valid Unicode scalar
    value.

    The grammar for symbols on page 458 gives a precise definition of the syntax of symbols.

#+BEGIN_VERSE
    *процедура:* (symbol=? symbol1 symbol2)
    *возвращает:* #t if the two symbols are the same, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    Symbols can also be compared with eq?, which is typically more efficient than symbol=?.

#+begin_src scheme
(symbol=? 'a 'a) → #t
(symbol=? 'a (string->symbol "a")) → #t
(symbol=? 'a 'b) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (string->symbol string)
    *возвращает:* a symbol whose name is string
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    string->symbol records all symbols it creates in an internal table that it shares with the system reader. If a
    symbol whose name is equivalent to string (according to the predicate string=?) already exists in the table, this
    symbol is returned. Otherwise, a new symbol is created with string as its name; this symbol is entered into the
    table and returned.

    The effect of modifying a string after it is used as an argument to string->symbol is unspecified.

#+begin_src scheme
(string->symbol "x") → x

(eq? (string->symbol "x") 'x) → #t
(eq? (string->symbol "X") 'x) → #f

(eq? (string->symbol "x")
     (string->symbol "x")) → #t

(string->symbol "()") → \x28;\x29;
#+end_src

#+BEGIN_VERSE
    *процедура:* (symbol->string symbol)
    *возвращает:* a string, the name of symbol
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The string returned by symbol->string should be treated as immutable. Unpredictable behavior can result if a string
    passed to string->symbol is altered with string-set! or by any other means.

#+begin_src scheme
(symbol->string 'xyz) → "xyz"
(symbol->string 'Hi) → "Hi"
(symbol->string (string->symbol "()")) → "()"
#+end_src

*** Booleans

    While every Scheme object has a truth value when used in a conditional context, with every object but #f counting as
    true, Scheme provides the dedicated true value #t for use when a value of an expression should convey nothing more
    than that it is true.

#+BEGIN_VERSE
    *процедура:* (boolean=? boolean1 boolean2)
    *возвращает:* #t if the two booleans are the same, #f otherwise
    *библиотеки:* (rnrs base), (rnrs)
#+END_VERSE

    The boolean values #t and #f may also be compared with eq?, which is typically more efficient than boolean=?.

#+begin_src scheme
(boolean=? #t #t) → #t
(boolean=? #t #f) → #f
(boolean=? #t (< 3 4)) → #t
#+end_src

*** Hashtables

    Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose
    as association lists (see page  165) but are typically much faster when large numbers of associations are involved.

#+BEGIN_VERSE
    *процедура:* (make-eq-hashtable)
    *процедура:* (make-eq-hashtable size)
    *возвращает:* a new mutable eq hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable
    should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the
    existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is
    initially populated.

    An eq hashtable compares keys using the eq? (pointer equality) procedure and typically employs a hash function based
    on object addresses. Its hash and equivalence functions are suitable for any Scheme object.

#+begin_src scheme
(define ht1 (make-eq-hashtable))
(define ht2 (make-eq-hashtable 32))
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-eqv-hashtable)
    *процедура:* (make-eqv-hashtable size)
    *возвращает:* a new mutable eqv hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable
    should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the
    existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is
    initially populated.

    An eqv hashtable compares keys using the eqv? procedure and typically employs a hash function based on object
    addresses for objects that are identifiable with eq?. Its hash and equivalence functions are suitable for any Scheme
    object.

#+BEGIN_VERSE
    *процедура:* (make-hashtable hash equiv?)
    *процедура:* (make-hashtable hash equiv? size)
    *возвращает:* a new mutable hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hash and equiv? must be procedures. If size is provided, it must be a nonnegative exact integer indicating
    approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the
    hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the
    amount of rehashing that must be done as the table is initially populated.

    The new hashtable computes hash values using hash and compares keys using equiv?, neither of which should modify the
    hashtable. equiv? should compare two keys and return false only if the two keys should be distinguished. hash should
    accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called
    with arguments that equiv? does not distinguish. The hash and equiv? procedures need not accept arbitrary inputs as
    long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are
    immutable as long as the keys are not modified while they have associations stored in the table. The hashtable
    operation may call hash and equiv? once, not at all, or multiple times for each hashtable operation.

#+begin_src scheme
(define ht (make-hashtable string-hash string=?))
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-mutable? hashtable)
    *возвращает:* #t if hashtable is mutable, #f otherwise
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    Hashtables returned by one of the hashtable creation procedures above are mutable, but those created by
    hashtable-copy may be immutable. Immutable hashtables cannot be altered by any of the procedures hashtable-set!,
    hashtable-update!, hashtable-delete!, or hashtable-clear!.

#+begin_src scheme
(hashtable-mutable? (make-eq-hashtable)) → #t
(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-hash-function hashtable)
    *возвращает:* the hash function associated with hashtable
    *процедура:* (hashtable-equivalence-function hashtable)
    *возвращает:* the equivalence function associated with hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable-hash-function returns #f for eq and eqv hashtables.

#+begin_src scheme
(define ht (make-eq-hashtable))
(hashtable-hash-function ht) → #f
(eq? (hashtable-equivalence-function ht) eq?) → #t

(define ht (make-hashtable string-hash string=?))
(eq? (hashtable-hash-function ht) string-hash) → #t
(eq? (hashtable-equivalence-function ht) string=?) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (equal-hash obj)
    *процедура:* (string-hash string)
    *процедура:* (string-ci-hash string)
    *процедура:* (symbol-hash symbol)
    *возвращает:* an exact nonnegative integer hash value
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    These procedures are hash functions suitable for use with the appropriate Scheme predicate: equal? for equal-hash,
    string=? for string-hash, string-ci=? for string-ci-hash, and symbol=? (or eq?) for symbol-hash. The hash values
    returned by equal-hash, string-hash, and string-ci-hash are typically dependent on the current structure and
    contents of the input values and are thus unsuitable if keys are modified while they have associations in a
    hashtable.

#+BEGIN_VERSE
    *процедура:* (hashtable-set! hashtable key obj)
    *возвращает:* unspecified
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence
    functions. obj may be any Scheme object.

    hashtable-set! associates key with obj in hashtable, replacing the existing association, if any.

#+begin_src scheme
(define ht (make-eq-hashtable))
(hashtable-set! ht 'a 73)
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-ref hashtable key default)
    *возвращает:* see below
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    key should be an appropriate key for the hashtable's hash and equivalence functions. default may be any Scheme
    object.

    hashtable-ref returns the value associated with key in hashtable. If no value is associated with key in hashtable,
    hashtable-ref returns default.

#+begin_src scheme
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))

(define eqht (make-eq-hashtable))
(hashtable-set! eqht p1 73)
(hashtable-ref eqht p1 55) → 73
(hashtable-ref eqht p2 55) → 55

(define equalht (make-hashtable equal-hash equal?))
(hashtable-set! equalht p1 73)
(hashtable-ref equalht p1 55) → 73
(hashtable-ref equalht p2 55) → 73
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-contains? hashtable key)
    *возвращает:* #t if an association for key exists in hashtable, #f otherwise
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    key should be an appropriate key for the hashtable's hash and equivalence functions.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) → #t
(hashtable-contains? ht p2) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-update! hashtable key procedure default)
    *возвращает:* unspecified
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence
    functions. default may be any Scheme object. procedure should accept one argument, should return one value, and
    should not modify hashtable.

    hashtable-update! applies procedure to the value associated with key in hashtable, or to default if no value is
    associated with key in hashtable. If procedure returns, hashtable-update! associates key with the value returned by
    procedure, replacing the old association, if any.

    A version of hashtable-update! that does not verify that it receives arguments of the proper type might be defined
    as follows.

#+begin_src scheme
(define hashtable-update!
  (lambda (ht key proc value)
    (hashtable-set! ht key
      (proc (hashtable-ref ht key value)))))
#+end_src

    An implementation may, however, be able to implement hashtable-update! more efficiently by avoiding multiple hash
    computations and hashtable lookups.

#+begin_src scheme
(define ht (make-eq-hashtable))
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(hashtable-ref ht 'a 0) → 110
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(hashtable-ref ht 'a 0) → 220
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-delete! hashtable key)
    *возвращает:* unspecified
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence
    functions.

    hashtable-delete! drops any association for key from hashtable.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) → #t
(hashtable-delete! ht p1)
(hashtable-contains? ht p1) → #f
(hashtable-contains? ht p2) → #f
(hashtable-delete! ht p2)
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-size hashtable)
    *возвращает:* number of entries in hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-size ht) → 0
(hashtable-set! ht p1 73)
(hashtable-size ht) → 1
(hashtable-delete! ht p1)
(hashtable-size ht) → 0
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-copy hashtable)
    *процедура:* (hashtable-copy hashtable mutable?)
    *возвращает:* a new hashtable containing the same entries as hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    If mutable? is present and not false, the copy is mutable; otherwise, the copy is immutable.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(hashtable-set! ht p1 "c")
(define ht-copy (hashtable-copy ht))
(hashtable-mutable? ht-copy) → #f
(hashtable-delete! ht p1)
(hashtable-ref ht p1 #f) → #f
(hashtable-delete! ht-copy p1) → exception: not mutable
(hashtable-ref ht-copy p1 #f) → "c"
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-clear! hashtable)
    *процедура:* (hashtable-clear! hashtable size)
    *возвращает:* unspecified
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable must be a mutable hashtable. If size is provided, it must be a nonnegative exact integer.

    hashtable-clear! removes all entries from hashtable. If size is provided, the hashtable is reset to the given size,
    as if newly created by one of the hashtable creation operations with size argument size.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "first")
(hashtable-set! ht p2 "second")
(hashtable-size ht) → 2
(hashtable-clear! ht)
(hashtable-size ht) → 0
(hashtable-ref ht p1 #f) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-keys hashtable)
    *возвращает:* a vector containing the keys in hashtable
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    The keys may appear in any order in the returned vector.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-keys ht) → #((a . b) q (a . b))
#+end_src

#+BEGIN_VERSE
    *процедура:* (hashtable-entries hashtable)
    *возвращает:* two vectors: one of keys and a second of values
    *библиотеки:* (rnrs hashtables), (rnrs)
#+END_VERSE

    hashtable-entries returns two values. The first is a vector containing the keys in hashtable, and the second is a
    vector containing the corresponding values. The keys and values may appear in any order, but the order is the same
    for the keys and for the corresponding values.

#+begin_src scheme
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-entries ht) → #((a . b) q (a . b))
                        #("two" "three" "one")
#+end_src

*** Enumerations

    Enumerations are ordered sets of symbols, typically used to name and manipulate options, as with the buffer modes
    and file options that may be specified when files are created.

    *синтаксис:* (define-enumeration name (symbol ...) constructor)
    *библиотеки:* (rnrs enums), (rnrs)

    A define-enumeration form is a definition and can appear anywhere any other definition can appear.

    The define-enumeration syntax creates a new enumeration set with the specified symbols in the specified order
    forming the enumeration's universe. It defines a new syntactic form named by name that may be used to verify that a
    symbol is in the universe. If x is in the universe, (name x) evaluates to x. It is a syntax violation if x is not in
    the universe.

    define-enumeration also defines a new syntactic form named by constructor that may be used to create subsets of the
    enumeration type. If x ... are each in the universe, (constructor x ...) evaluates to an enumeration set containing
    x .... Otherwise, it is a syntax violation. The same symbol may appear more than once in x ..., but the resulting
    set contains only one occurrence of the symbol.

#+begin_src scheme
(define-enumeration weather-element
  (hot warm cold sunny rainy snowy windy)
  weather)

(weather-element hot) → hot
(weather-element fun) → syntax violation
(weather hot sunny windy) → #<enum-set>
(enum-set->list (weather rainy cold rainy)) → (cold rainy)
#+end_src

#+BEGIN_VERSE
    *процедура:* (make-enumeration symbol-list)
    *возвращает:* an enumeration set
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    This procedure creates a new enumeration type whose universe comprises the elements of symbol-list, which must be a
    list of symbols, in the order of their first appearance in the list. It returns the universe of the new enumeration
    type as an enumeration set.

#+begin_src scheme
(define positions (make-enumeration '(top bottom above top beside)))
(enum-set->list positions) → (top bottom above beside)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-constructor enum-set)
    *возвращает:* an enumeration-set construction procedure
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    This procedure returns a procedure p that may be used to create subsets of the universe of enum-set. p must be
    passed a list of symbols, and each element of the list must be an element of the universe of enum-set. The
    enumeration set returned by p contains all and only the symbols in the list it is passed. The value returned by p
    may contain elements not in enum-set if the universe of enum-set contains those elements.

#+begin_src scheme
(define e1 (make-enumeration '(one two three four)))
(define p1 (enum-set-constructor e1))
(define e2 (p1 '(one three)))
(enum-set->list e2) → (one three)
(define p2 (enum-set-constructor e2))
(define e3 (p2 '(one two four)))
(enum-set->list e3) → (one two four)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-universe enum-set)
    *возвращает:* the universe of enum-set, as an enumeration set
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

#+begin_src scheme
(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list (enum-set-universe e1)) → (a b c d)
(define e2 ((enum-set-constructor e1) '(c)))
(enum-set->list (enum-set-universe e2)) → (a b c d)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set->list enum-set)
    *возвращает:* a list of the elements of enum-set
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    The symbols in the resulting list appear in the order given to them when the enumeration type of enum-set was
    created.

#+begin_src scheme
(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list e1) → (a b c d)
(define e2 ((enum-set-constructor e1) '(d c a b)))
(enum-set->list e2) → (a b c d)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-subset? enum-set1 enum-set2)
    *возвращает:* #t if enum-set1 is a subset of enum-set2, #f otherwise
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    An enumeration set enum-set1 is a subset of an enumeration set enum-set2 if and only if the universe of enum-set1 is
    a subset of the universe of enum-set2 and each element of enum-set1 is an element of enum-set2.

#+begin_src scheme
(define e1 (make-enumeration '(a b c)))
(define e2 (make-enumeration '(a b c d e)))
(enum-set-subset? e1 e2) → #t
(enum-set-subset? e2 e1) → #f
(define e3 ((enum-set-constructor e2) '(a c)))
(enum-set-subset? e3 e1) → #f
(enum-set-subset? e3 e2) → #t
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set=? enum-set1 enum-set2)
    *возвращает:* #t if enum-set1 and enum-set2 are equivalent, #f otherwise
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    Two enumeration sets enum-set1 and enum-set2 are equivalent if each is a subset of the other.

#+begin_src scheme
(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(b d c a)))
(enum-set=? e1 e2) → #t
(define e3 ((enum-set-constructor e1) '(a c)))
(define e4 ((enum-set-constructor e2) '(a c)))
(enum-set=? e3 e4) → #t
(enum-set=? e3 e2) → #f
#+end_src

    enum-set=? could be defined in terms of enum-set-subset? as follows.

#+begin_src scheme
(define enum-set=?
  (lambda (e1 e2)
    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-member? symbol enum-set)
    *возвращает:* #t if symbol is an element of enum-set, #f otherwise
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

#+begin_src scheme
(define e1 (make-enumeration '(a b c d e)))
(define e2 ((enum-set-constructor e1) '(d b)))
(enum-set-member? 'c e1) → #t
(enum-set-member? 'c e2) → #f
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-union enum-set1 enum-set2)
    *возвращает:* the union of enum-set1 and enum-set2
    *процедура:* (enum-set-intersection enum-set1 enum-set2)
    *возвращает:* the intersection of enum-set1 and enum-set2
    *процедура:* (enum-set-difference enum-set1 enum-set2)
    *возвращает:* the difference of enum-set1 and enum-set2
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    enum-set1 and enum-set2 must have the same enumeration type. Each procedure returns a new enumeration set
    representing the union, intersection, or difference of the two sets.

#+begin_src scheme
(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a c)))
(define e3 ((enum-set-constructor e1) '(b c)))
(enum-set->list (enum-set-union e2 e3)) → (a b c)
(enum-set->list (enum-set-intersection e2 e3)) → (c)
(enum-set->list (enum-set-difference e2 e3)) → (a)
(enum-set->list (enum-set-difference e3 e2)) → (b)
(define e4 (make-enumeration '(b d c a)))
(enum-set-union e1 e4) → exception: different enumeration types
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-complement enum-set)
    *возвращает:* the complement of enum-set relative to its universe
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

#+begin_src scheme
(define e1 (make-enumeration '(a b c d)))
(enum-set->list (enum-set-complement e1)) → ()
(define e2 ((enum-set-constructor e1) '(a c)))
(enum-set->list (enum-set-complement e2)) → (b d)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-projection enum-set1 enum-set2)
    *возвращает:* the projection of enum-set1 into the universe of enum-set2
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    Any elements of enum-set1 not in the universe of enum-set2 are dropped. The result is of the same enumeration type
    as enum-set2.

#+begin_src scheme
(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(a b c d e f g)))
(define e3 ((enum-set-constructor e1) '(a d)))
(define e4 ((enum-set-constructor e2) '(a c e g)))
(enum-set->list (enum-set-projection e4 e3)) → (a c)
(enum-set->list
  (enum-set-union e3
    (enum-set-projection e4 e3))) → (a c d)
#+end_src

#+BEGIN_VERSE
    *процедура:* (enum-set-indexer enum-set)
    *возвращает:* a procedure that returns the index of a symbol in the universe of enum-set
    *библиотеки:* (rnrs enums), (rnrs)
#+END_VERSE

    enum-set-indexer returns a procedure p that, when applied to a symbol in the universe of enum-set, returns the index
    of the symbol (zero-based) in the ordered set of symbols that form the universe. If applied to a symbol not in the
    universe, p returns #f.

#+begin_src scheme
(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a d)))
(define p (enum-set-indexer e2))
(list (p 'a) (p 'c) (p 'e)) → (0 2 #f)
#+end_src

#+LATEX: \newpage
[[./images/ch7.png]]

** Input and Output
*** Transcoders
*** Opening Files
*** Standard Ports
*** String and Bytevector Ports
*** Opening Custom Ports
*** Port Operations
*** Input Operations
*** Output Operations
*** Convenience I/O
*** Filesystem Operations
*** Bytevector/String Conversions

#+LATEX: \newpage
[[./images/ch8.png]]

** Syntactic Extension
*** Keyword Bindings
*** Syntax-Rules Transformers
*** Syntax-Case Transformers
*** Examples

#+LATEX: \newpage
[[./images/ch9.png]]

** Records
*** Defining Records
*** Procedural Interface
*** Inspection

#+LATEX: \newpage
[[./images/ch10.png]]

** Libraries and Top-Level Programs
*** Standard Libraries
*** Defining New Libraries
*** Top-Level Programs
*** Examples

#+LATEX: \newpage
[[./images/ch11.png]]

** Exceptions and Conditions
*** Raising and Handling Exceptions
*** Defining Condition Types
*** Standard Condition Types

#+LATEX: \newpage
[[./images/ch12.png]]

** Extended Examples
*** Matrix and Vector Multiplication
*** Sorting
*** A Set Constructor
*** Word Frequency Counting
*** Scheme Printer
*** Formatted Output
*** A Meta-Circular Interpreter for Scheme
*** Defining Abstract Objects
*** Fast Fourier Transform
*** A Unification Algorithm
*** Multitasking with Engines

#+LATEX: \newpage
** Ответы к заданиям

#+LATEX: \newpage
* Формальный синтаксис

#+LATEX: \newpage
* Таблица синтаксических форм

#+LATEX: \newpage
* Предметный указатель


#+LATEX: \newpage
* Footnotes

[fn:1] Michael Adams and R. Kent Dybvig. Efficient nondestructive equality checking for trees and graphs. In Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming, 179-188, September 2008.

[fn:2] J. Michael Ashley and R. Kent Dybvig. An efficient implementation of multiple return values in Scheme. In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, 140-149, June 1994.

[fn:3] Alan Bawden. Quasiquotation in lisp. In Partial Evaluation and Semantic-Based Program Manipulation, 88-99, 1999.

[fn:4] William Briggs and Van Emden Henson. The DFT: An Owner's Manual for the Discrete Fourier Transform. Society for Industrial and Applied Mathematics, Philadelphia, PA, 1995.

[fn:5] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, 108-116, May 1996.

[fn:6] William F. Clocksin and Christopher S. Mellish. Programming in Prolog, second edition. Springer-Verlag, Berlin, 1984.

[fn:7] Sam M. Daniel. Efficient recursive FFT implementation in Prolog. In Proceedings of the Second International Conference on the Practical Application of Prolog, 175-185, 1994.

[fn:8] Mark Davis. Unicode Standard Annex #29: Text boundaries, 2006. http://www.unicode.org/reports/tr29/.

[fn:9] R. Kent Dybvig. Chez Scheme User's Guide: Version 8. Cadence Research Systems, 2009. http://www.scheme.com/csug8/.

[fn:10] R. Kent Dybvig and Robert Hieb. Engines from continuations. Computer Languages, 14(2):109-123, 1989.

[fn:11] R. Kent Dybvig and Robert Hieb. A new approach to procedures with variable arity. Lisp and Symbolic Computation, 3(3):229-244, September 1990.

[fn:12] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295-326, 1993.

[fn:13] Daniel P. Friedman and Matthias Felleisen. The Little Schemer, fourth edition. MIT Press, Cambridge, MA, 1996.

[fn:14] Daniel P. Friedman, Christopher T. Haynes, and Eugene E. Kohlbecker. Programming with continuations. In P. Pepper, editor, Program Transformation and Programming Environments, 263-274. Springer-Verlag, New York, 1984.

[fn:15] Christopher T. Haynes and Daniel P. Friedman. Abstracting timed preemption with engines. Computer Languages, 12(2):109-121, 1987.

[fn:16] Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. Obtaining coroutines with continuations. Computer Languages, 11(3/4):143-153, 1986.

[fn:17] Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of first-class continuations. In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, 66-77, June 1990.

[fn:18] IEEE Computer Society. IEEE Standard for the Scheme Programming Language, May 1991. IEEE Std 1178-1990.

[fn:19] Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language, second edition. Prentice Hall, Englewood Cliffs, NJ, 1988.

[fn:20] P. Leach, M. Mealling, and R. Salz. A Universally Unique IDentifier (UUID) URN namespace, July 2005. RFC 4122. http://www.ietf.org/rfc/rfc4122.txt.

[fn:21] Peter Naur et al. Revised report on the algorithmic language ALGOL 60. Communications of the ACM, 6(1):1-17, January 1963.

[fn:22] David A. Plaisted. Constructs for sets, quantifiers, and rewrite rules in Lisp. Technical Report UIUCDCS-R-84-1176, University of Illinois at Urbana-Champaign Department of Computer Science, June 1984.

[fn:23] J. A. Robinson. A machine-oriented logic based on the resolution principle. Journal of the ACM, 12(1):23-41, 1965.

[fn:24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme, September 2007. http://www.r6rs.org/.

[fn:25] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---non-normative appendices, September 2007. http://www.r6rs.org/.

[fn:26] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised6 report on the algorithmic language Scheme---standard libraries, September 2007. http://www.r6rs.org/.

[fn:27] Guy L. Steele Jr. Common Lisp, the Language, second edition. Digital Press, Bedford, Massachusetts, 1990.

[fn:28] Guy L. Steele Jr. and Gerald J. Sussman. The revised report on Scheme, a dialect of Lisp. MIT AI Memo 452, Massachusetts Institute of Technology, January 1978.

[fn:29] Gerald J. Sussman and Guy L. Steele Jr. Scheme: An interpreter for extended lambda calculus. Higher-Order and Symbolic Computation, 11(4):405-439, 1998. Reprinted from the AI Memo 349, MIT (1975), with a foreword.

[fn:30] The Unicode Consortium. The Unicode Standard, Version 5.0, fifth edition. Addison-Wesley Professional, Boston, MA, 2006.

[fn:31] Oscar Waddell, Dipanwita Sarkar, and R. Kent Dybvig. Fixing letrec: A faithful yet efficient implementation of Scheme's recursive binding construct. Higher-Order and Symbolic Computation, 18(3/4):299-326, 2005.

[fn:32] Mitchell Wand. Continuation-based multiprocessing. Higher-Order and Symbolic Computation, 12(3):285-299, 1999. Reprinted from the proceedings of the 1980 Lisp Conference, with a foreword.
